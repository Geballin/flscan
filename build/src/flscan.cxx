// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include <libintl.h>
#include "flscan.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <strings.h>
#include <FL/filename.H>
#include <FL/fl_ask.H>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include "Output_File.H"
Trigger running; 
#define TEXT_TO_SLIDER 1
#define SLIDER_TO_TEXT !TEXT_TO_SLIDER
#define DECREASE_SIZE -1
#define INCREASE_SIZE -2
#define FIT_TO_SCREEN -3
#define FL_SCAN_OUTPUT_FILE_RESOLUTION -4
#define FL_SCAN_CONVERTERS_SETTINGS -3
#define FL_SCAN_HISTOGRAM -2
#define FL_SCAN_DEVICE_SELECTION -1
#define FL_SCAN_SCAN_MODE 0
#define FL_SCAN_VIEW_MODE !FL_SCAN_SCAN_MODE
static int preview_ndx=-1; 
static int tl_x_ndx=-1; 
static int tl_y_ndx=-1; 
static int br_x_ndx=-1; 
static int br_y_ndx=-1; 
C_Sane *sane; 
static C_Sane_Option *currentOption=0; 
static SANE_Int currentOption_num=0; 
static Fl_Group *lastOption=0; 
static Fl_Window *copyrightWindow=0; 
char *sane_host; 
static char *scan_buf=0; 
static Output_File FlScanOutputFile; 
static int FlScanZoomFilter=Image_Stream::UNDEFINED_FILTER; 

EatEvent::EatEvent(int x,int y,int w,int h,const char *l): Fl_Box(x,y,w,h,l) {
}

int EatEvent::handle(int e) {
  //
    switch (e) {
        case FL_PUSH:
        case FL_RELEASE:
            return 1;
        default:
            return 0;
    }
    return 0;
}

void ImageSavingMonitor::thread() {
  bool allSaved=false;
  const char *pStrProgress;
  
      FL_TOGGLE_THREAD();
      while (!allSaved) {
  //        Fl::wait(1);
          allSaved=true;
          for (
              int i=0;
              (pStrProgress=FlScanConversionArea->get_value(i,2));
              i++
          ) {
              if (strcmp(pStrProgress,"Completed")) {
                  allSaved=false;
                  break;
              }
          }
          FlScanEeWaitForSaving->redraw();
          sleep(1);
      }
      FL_TOGGLE_THREAD();
}

ImageSavingMonitor::ImageSavingMonitor() {
  #ifdef THREADED_SAVING
       create();
  #else
       thread();
  #endif
}

void auth_callback(SANE_String_Const domain,SANE_Char username[SANE_MAX_USERNAME_LEN],SANE_Char password[SANE_MAX_PASSWORD_LEN]) {
  printf ("Client '%s' requested authorization.\nUser:\n", domain);
      scanf ("%s", username);
      printf ("Password:\n");
      scanf ("%s", password);
}

Fl_Double_Window *FlScan=(Fl_Double_Window *)0;

Fl_Group *FlScanContainer=(Fl_Group *)0;

Fl_Tree_Browser *FlScanScannerOptions=(Fl_Tree_Browser *)0;

Fl_Group *FlScanSettings=(Fl_Group *)0;

Fl_Group *FlScanMisc=(Fl_Group *)0;

Fl_Sorted_Choice *FlScanScanFileType=(Fl_Sorted_Choice *)0;

static void cb_FlScanScanFileTypeJPEG(Fl_Menu_*, void*) {
  FlScanOutputFile.type(Output_File::JPEG);
}

static void cb_FlScanScanFileTypePNG(Fl_Menu_*, void*) {
  FlScanOutputFile.type(Output_File::PNG);
}

static void cb_FlScanScanFileTypePNM(Fl_Menu_*, void*) {
  /* FlScanOutputFile.type(Output_File::PNM); */;
}

static void cb_FlScanScanFileTypeRAW(Fl_Menu_*, void*) {
  /* FlScanOutputFile.type(Output_File::RAW);*/;
}

static void cb_FlScanScanFileTypeTIFF(Fl_Menu_*, void*) {
  /* FlScanOutputFile.type(Output_File::TIFF);*/;
}

unsigned char menu_FlScanScanFileType_i18n_done = 0;
Fl_Menu_Item menu_FlScanScanFileType[] = {
 {".jpeg", 0,  (Fl_Callback*)cb_FlScanScanFileTypeJPEG, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {".png", 0,  (Fl_Callback*)cb_FlScanScanFileTypePNG, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {".pnm", 0,  (Fl_Callback*)cb_FlScanScanFileTypePNM, 0, 16, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {".raw", 0,  (Fl_Callback*)cb_FlScanScanFileTypeRAW, 0, 16, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {".tiff", 0,  (Fl_Callback*)cb_FlScanScanFileTypeTIFF, 0, 16, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Input *FlScanTxFileName=(Fl_Input *)0;

static void cb_FlScanTxFileName(Fl_Input*, void*) {
  if (strlen(FlScanTxFileName->value())) {
    FlScanPbScan->activate();
} else {
    FlScanPbScan->deactivate();
};
}

Fl_Box *FlScanLbSeparator=(Fl_Box *)0;

Fl_Button *FlScanPbFileSelector=(Fl_Button *)0;

static void cb_FlScanPbFileSelector(Fl_Button*, void*) {
  char *outputName;

    outputName=fl_file_chooser("Save Scan As ...",FlScanOutputFile.filter(),NULL);
    if (outputName) {
        FlScanTxFileName->value(outputName);
    } else {
        FlScanTxFileName->value("");
    }
    FlScanTxFileName->do_callback();
}

#include <FL/Fl_Pixmap.H>
static const char *idata_file[] = {
"19 19 4 1",
" \tc white",
".\tc gray50",
"X\tc gray30",
"o\tc none",
"                   ",
" .................X",
" .................X",
" .XX...........XX.X",
" .XX...........XX.X",
" .................X",
" .................X",
" .................X",
" .................X",
" .................X",
" .................X",
" .................X",
" .................X",
" ....         ....X",
" .... ....    ....X",
" .... ....    ....X",
" .... ....    ....X",
"oX... ....    ....X",
"ooXXXXXXXXXXXXXXXXX"
};
static Fl_Image *image_file() {
  static Fl_Image *image = new Fl_Pixmap(idata_file);
  return image;
}

Fl_Button *FlScanPbPreview=(Fl_Button *)0;

static void cb_FlScanPbPreview(Fl_Button*, void*) {
  FlScanPreviewCB(0,0,C_Sane::USER_MODE);
}

Fl_Button *FlScanPbScan=(Fl_Button *)0;

static void cb_FlScanPbScan(Fl_Button*, void*) {
  FlScanPbCancel->activate();
FlScanScanCB(0,0,C_Sane::USER_MODE);
FlScanPbCancel->deactivate();
}

Fl_Button *FlScanPbReset=(Fl_Button *)0;

static void cb_FlScanPbReset(Fl_Button*, void*) {
  FlScanSaveCurrentDevice();
sane->open(NULL); /* reopen current device */
FlScanLoadCurrentDevice();
update_tree();
}

Fl_Button *FlScanPbCancel=(Fl_Button *)0;

static void cb_FlScanPbCancel(Fl_Button*, void*) {
  sane->cancel();
}

Fl_Group *FlScanSetOption=(Fl_Group *)0;

Fl_Button *FlScanPbAutoOption=(Fl_Button *)0;

static void cb_FlScanPbAutoOption(Fl_Button*, void*) {
  FlScanSaneSetCB(true);
}

Fl_Button *FlScanPbSetOption=(Fl_Button *)0;

static void cb_FlScanPbSetOption(Fl_Button*, void*) {
  FlScanSaneSetCB(false);
FlScanPbSetOption->hide();
}

Fl_Group *FlScanBoolGroup=(Fl_Group *)0;

Fl_Light_Button *FlScanTbBoolType=(Fl_Light_Button *)0;

static void cb_FlScanTbBoolType(Fl_Light_Button*, void*) {
  FlScanSaneSetCB(false);
}

Fl_Group *FlScanFixedGroup=(Fl_Group *)0;

Fl_Float_Input *FlScanTxFixedType=(Fl_Float_Input *)0;

static void cb_FlScanTxFixedType(Fl_Float_Input*, void*) {
  FlScanPbSetOption->show();
}

Fl_Group *FlScanIntGroup=(Fl_Group *)0;

Fl_Int_Input *FlScanTxIntType=(Fl_Int_Input *)0;

static void cb_FlScanTxIntType(Fl_Int_Input*, void*) {
  FlScanPbSetOption->show();
}

Fl_Group *FlScanStringGroup=(Fl_Group *)0;

Fl_Input *FlScanTxStringType=(Fl_Input *)0;

static void cb_FlScanTxStringType(Fl_Input*, void*) {
  FlScanPbSetOption->show();
}

Fl_Group *FlScanButtonGroup=(Fl_Group *)0;

Fl_Button *FlScanPbButtonType=(Fl_Button *)0;

static void cb_FlScanPbButtonType(Fl_Button*, void*) {
  FlScanSaneSetCB(false);
}

Fl_Group *FlScanRangeGroup=(Fl_Group *)0;

Fl_Slider *FlScanSlRangeType=(Fl_Slider *)0;

static void cb_FlScanSlRangeType(Fl_Slider*, void*) {
  FlScanViRangeType->value(FlScanSlRangeType->value());
FlScanPbSetOption->show();
}

Fl_Value_Input *FlScanViRangeType=(Fl_Value_Input *)0;

static void cb_FlScanViRangeType(Fl_Value_Input*, void*) {
  FlScanSlRangeType->value(FlScanViRangeType->value());
FlScanPbSetOption->show();
}

Fl_Group *FlScanListGroup=(Fl_Group *)0;

Fl_Sorted_Choice *FlScanMnListType=(Fl_Sorted_Choice *)0;

Fl_Group *FlScanMessage=(Fl_Group *)0;

Fl_Group *FlScanTableGroup=(Fl_Group *)0;

Fl_RaiseButton *FlScanRbSplineTable=(Fl_RaiseButton *)0;

static void cb_FlScanRbSplineTable(Fl_RaiseButton*, void*) {
  FlScanTableGammaCurve->type(Fl_Curve::SPLINE);
}

static const char *idata_spline[] = {
"16 16 4 1",
". c None",
"B c #000000",
"+ c #BC2D2D",
"r c #FF0000",
"..............BB",
".........rrrrrrB",
".......rr.......",
".....B+.........",
"....BBB.........",
"....+B..........",
"....r...........",
"...r............",
"...r............",
"..r.............",
"..r.............",
".r..............",
".r..............",
".r..............",
"B+..............",
"BB.............."
};
static Fl_Image *image_spline() {
  static Fl_Image *image = new Fl_Pixmap(idata_spline);
  return image;
}

Fl_RaiseButton *FlScanRbLinearTable=(Fl_RaiseButton *)0;

static void cb_FlScanRbLinearTable(Fl_RaiseButton*, void*) {
  FlScanTableGammaCurve->type(Fl_Curve::LINEAR);
}

static const char *idata_linear[] = {
"16 16 5 1",
". c None",
"B c #000000",
"\' c #7F7F7F",
"+ c #824141",
"r c #FF0000",
"..............BB",
"..............+B",
"..............r.",
".............r..",
".............r..",
"....\'B\'.....r...",
"....BBB.....r...",
"....+B+....r....",
"....r.r....r....",
"...r...r..r.....",
"...r...r..r.....",
"..r.....rB+.....",
"..r.....BBB.....",
".r......\'B\'.....",
"B+..............",
"BB.............."
};
static Fl_Image *image_linear() {
  static Fl_Image *image = new Fl_Pixmap(idata_linear);
  return image;
}

Fl_RaiseButton *FlScanRbFreeTable=(Fl_RaiseButton *)0;

static void cb_FlScanRbFreeTable(Fl_RaiseButton*, void*) {
  FlScanTableGammaCurve->type(Fl_Curve::FREE);
}

static const char *idata_free[] = {
"16 16 2 1",
". c None",
"r c #FF0000",
"................",
"................",
"......r.........",
"......r.........",
".......r........",
".......r........",
".......r........",
"........r.......",
"........r.......",
"........r.......",
".....r...r.rrrrr",
"....r....r......",
"...r.....r......",
"..r.......r.....",
".r........r.....",
"r..............."
};
static Fl_Image *image_free() {
  static Fl_Image *image = new Fl_Pixmap(idata_free);
  return image;
}

Fl_RaiseButton *FlScanPbGammaTable=(Fl_RaiseButton *)0;

static void cb_FlScanPbGammaTable(Fl_RaiseButton*, void*) {
  FlScanTableSetGamma();
}

static const char *idata_gamma[] = {
"16 16 10 1",
". c None",
"B c #000000",
"& c #171717",
"# c #2F2F2F",
"X c #464646",
"= c #5E5E5E",
"/ c #757575",
"+ c #8C8C8C",
"- c #A4A4A4",
"` c #BBBBBB",
"................",
"................",
"................",
"....B=..+B+.....",
"....X&`./&-.....",
"...../+.XX......",
"......B.B+......",
"......X.X.......",
"......X&+.......",
"......-B........",
"....../=........",
"......#B........",
"......BB........",
"......B#........",
"................",
"................"
};
static Fl_Image *image_gamma() {
  static Fl_Image *image = new Fl_Pixmap(idata_gamma);
  return image;
}

Fl_Float_Input *FlScanTxGammaTable=(Fl_Float_Input *)0;

static void cb_FlScanTxGammaTable(Fl_Float_Input*, void*) {
  FlScanTableSetGamma();
}

Fl_RaiseButton *FlScanPbResetTable=(Fl_RaiseButton *)0;

static void cb_FlScanPbResetTable(Fl_RaiseButton*, void*) {
  FlScanTableGammaCurve->reset();
}

static const char *idata_reset[] = {
"16 16 4 1",
". c None",
"B c #000000",
"+ c #824141",
"r c #FF0000",
"..............BB",
"..............+B",
".............r..",
"............r...",
"...........r....",
"..........r.....",
".........r......",
"........r.......",
".......r........",
"......r.........",
".....r..........",
"....r...........",
"...r............",
"..r.............",
"B+..............",
"BB.............."
};
static Fl_Image *image_reset() {
  static Fl_Image *image = new Fl_Pixmap(idata_reset);
  return image;
}

Fl_Group *FlScanGroupTableType=(Fl_Group *)0;

Fl_Curve *FlScanTableGammaCurve=(Fl_Curve *)0;

static void cb_FlScanTableGammaCurve(Fl_Curve*, void*) {
  switch (FlScanTableGammaCurve->type()) {
    case Fl_Curve::FREE:
        FlScanRbFreeTable->setonly();
        break;
    case Fl_Curve::LINEAR:
        FlScanRbLinearTable->setonly();
        break;
    case Fl_Curve::SPLINE:
        FlScanRbSplineTable->setonly();
        break;
}
FlScanPbSetOption->show();
}

Fl_Group *FlScanOutputResolutions=(Fl_Group *)0;

Fl_Browser *FlScanLsOutputGeometries=(Fl_Browser *)0;

Fl_Sorted_Choice *FlScanOmZoomFilter=(Fl_Sorted_Choice *)0;

static void cb_Point(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::POINT_FILTER;
}

static void cb_Box(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::BOX_FILTER;
}

static void cb_Triangle(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::TRIANGLE_FILTER;
}

static void cb_Hermite(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::HERMITE_FILTER;
}

static void cb_Hanning(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::HANNING_FILTER;
}

static void cb_Hamming(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::HAMMING_FILTER;
}

static void cb_Blackman(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::BLACKMAN_FILTER;
}

static void cb_Gaussian(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::GAUSSIAN_FILTER;
}

static void cb_Quadratic(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::QUADRATIC_FILTER;
}

static void cb_Cubic(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::CUBIC_FILTER;
}

static void cb_Catrom(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::CATROM_FILTER;
}

static void cb_Mitchell(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::MITCHELL_FILTER;
}

static void cb_Lanczos(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::LANCZOS_FILTER;
}

static void cb_Bessel(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::BESSEL_FILTER;
}

static void cb_Sinc(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::SINC_FILTER;
}

unsigned char menu_FlScanOmZoomFilter_i18n_done = 0;
Fl_Menu_Item menu_FlScanOmZoomFilter[] = {
 {"Point", 0,  (Fl_Callback*)cb_Point, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Box", 0,  (Fl_Callback*)cb_Box, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Triangle", 0,  (Fl_Callback*)cb_Triangle, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Hermite", 0,  (Fl_Callback*)cb_Hermite, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Hanning", 0,  (Fl_Callback*)cb_Hanning, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Hamming", 0,  (Fl_Callback*)cb_Hamming, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Blackman", 0,  (Fl_Callback*)cb_Blackman, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Gaussian", 0,  (Fl_Callback*)cb_Gaussian, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Quadratic", 0,  (Fl_Callback*)cb_Quadratic, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Cubic", 0,  (Fl_Callback*)cb_Cubic, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Catrom", 0,  (Fl_Callback*)cb_Catrom, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Mitchell", 0,  (Fl_Callback*)cb_Mitchell, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Lanczos", 0,  (Fl_Callback*)cb_Lanczos, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Bessel", 0,  (Fl_Callback*)cb_Bessel, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {"Sinc", 0,  (Fl_Callback*)cb_Sinc, 0, 0, (uchar)FL_NORMAL_LABEL, 1, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Group *FlScanHistogram=(Fl_Group *)0;

Fl_Button *FlScanHistogramPbIntensity=(Fl_Button *)0;

static void cb_FlScanHistogramPbIntensity(Fl_Button*, void*) {
  FlScanHistogramTgIntensity->value(!FlScanHistogramTgIntensity->value());
FlScanHistogramTgIntensity->do_callback();
}

Fl_Button *FlScanHistogramPbRed=(Fl_Button *)0;

static void cb_FlScanHistogramPbRed(Fl_Button*, void*) {
  FlScanHistogramTgRed->value(!FlScanHistogramTgRed->value());
FlScanHistogramTgRed->do_callback();
}

Fl_Button *FlScanHistogramPbBlue=(Fl_Button *)0;

static void cb_FlScanHistogramPbBlue(Fl_Button*, void*) {
  FlScanHistogramTgBlue->value(!FlScanHistogramTgBlue->value());
FlScanHistogramTgBlue->do_callback();
}

Fl_Button *FlScanHistogramPbGreen=(Fl_Button *)0;

static void cb_FlScanHistogramPbGreen(Fl_Button*, void*) {
  FlScanHistogramTgGreen->value(!FlScanHistogramTgGreen->value());
FlScanHistogramTgGreen->do_callback();
}

Fl_Button *FlScanHistogramPbLog=(Fl_Button *)0;

static void cb_FlScanHistogramPbLog(Fl_Button*, void*) {
  FlScanHistogramTgLog->value(!FlScanHistogramTgLog->value());
FlScanHistogramTgLog->do_callback();
}

Fl_Button *FlScanHistogramPbPixel=(Fl_Button *)0;

static void cb_FlScanHistogramPbPixel(Fl_Button*, void*) {
  FlScanHistogramTgPixel->value(!FlScanHistogramTgPixel->value());
FlScanHistogramTgPixel->do_callback();
}

Fl_Group *FlScanHistogramCanvas=(Fl_Group *)0;

Fl_Light_Button *FlScanHistogramTgIntensity=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgIntensity(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgRed=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgRed(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgGreen=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgGreen(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgBlue=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgBlue(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgPixel=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgPixel(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgLog=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgLog(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Group *FlScanSetupJPEG=(Fl_Group *)0;

Fl_Int_Input *FlScanFFmtTxQltJPEG=(Fl_Int_Input *)0;

static void cb_FlScanFFmtTxQltJPEG(Fl_Int_Input*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlQltJPEG,
        FlScanFFmtTxQltJPEG,
        TEXT_TO_SLIDER
    );
}

Fl_Slider *FlScanFFmtSlQltJPEG=(Fl_Slider *)0;

static void cb_FlScanFFmtSlQltJPEG(Fl_Slider*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlQltJPEG,
        FlScanFFmtTxQltJPEG,
        SLIDER_TO_TEXT
    );
}

Fl_Int_Input *FlScanFFmtTxSmtJPEG=(Fl_Int_Input *)0;

static void cb_FlScanFFmtTxSmtJPEG(Fl_Int_Input*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlSmtJPEG,
        FlScanFFmtTxSmtJPEG,
        TEXT_TO_SLIDER
    );
}

Fl_Slider *FlScanFFmtSlSmtJPEG=(Fl_Slider *)0;

static void cb_FlScanFFmtSlSmtJPEG(Fl_Slider*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlSmtJPEG,
        FlScanFFmtTxSmtJPEG,
        SLIDER_TO_TEXT
    );
}

Fl_Light_Button *FlScanFFmtTbOptJPEG=(Fl_Light_Button *)0;

Fl_Box *FlScanLbJPEGSeparator=(Fl_Box *)0;

Fl_Int_Input *FlScanFFmtTxCompressionPNG=(Fl_Int_Input *)0;

static void cb_FlScanFFmtTxCompressionPNG(Fl_Int_Input*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlCompressionPNG,
        FlScanFFmtTxCompressionPNG,
        TEXT_TO_SLIDER
    );
}

Fl_Slider *FlScanFFmtSlCompressionPNG=(Fl_Slider *)0;

static void cb_FlScanFFmtSlCompressionPNG(Fl_Slider*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlCompressionPNG,
        FlScanFFmtTxCompressionPNG,
        SLIDER_TO_TEXT
    );
}

Fl_Group *FlScanSaneLogo=(Fl_Group *)0;

static const char *idata_sane[] = {
"116 124 63 1",
" \tc none",
"X\tc #EFBEEFBEEFBE",
"o\tc #CF3CBEFBA699",
"O\tc #DF7DD75CC71B",
"+\tc #F7DEEBADD75C",
"@\tc #EFBEDF7DCF3C",
"#\tc #DF7DDF7DD75C",
"$\tc #D75CCF3CB6DA",
"%\tc #CF3CCB2BA699",
"&\tc #BEFBB6DA9E79",
"*\tc #C71BA6998E38",
"=\tc #AEBAA6999E79",
"-\tc #CF3CC30B8E38",
";\tc #D75CCF3CA699",
":\tc #DF7DCB2B9E79",
">\tc #D75CC30B9658",
",\tc #E79DD75CB6DA",
"<\tc #CF3CD34C9658",
"1\tc #CF3CBAEA9658",
"2\tc #AEBAAEBA8E38",
"3\tc #CF3CB2CA8E38",
"4\tc #AEBAAAAA8617",
"5\tc #B6DA9E798617",
"6\tc #9E799E7979E7",
"7\tc #CF3CC30B9658",
"8\tc #CF3CC30B9E79",
"9\tc #CF3CBAEA9E79",
"0\tc #CF3CAEBA9658",
"q\tc #AEBA9A6979E7",
"w\tc #BEFBBAEA9658",
"e\tc #BEFBC30B9658",
"r\tc #BEFBBEFB8E38",
"t\tc #C71BB2CA9658",
"y\tc #CF3CB6DA8E38",
"u\tc #BEFBAAAA79E7",
"i\tc #D75CB2CA9658",
"p\tc #C71BB2CA79E7",
"a\tc #C71BB2CA8E38",
"s\tc #B6DAB6DA79E7",
"d\tc #BEFBA2898E38",
"f\tc #B6DABAEA8617",
"g\tc #BEFBBEFBBEFB",
"h\tc #CF3CB2CA9E79",
"j\tc #BEFBAAAA8E38",
"k\tc #B6DA9E7979E7",
"l\tc #9E798E386185",
"z\tc #8E3882076185",
"x\tc #AEBAAAAA71C6",
"c\tc #8E38820779E7",
"v\tc #71C669A65144",
"b\tc #49245144C71B",
"n\tc #79E779E75965",
"m\tc #59654D3430C2",
"M\tc #61855D755144",
"N\tc #30C234D35965",
"B\tc #30C230C228A2",
"V\tc #208120811040",
"C\tc #104010400820",
"Z\tc #000004100000",
"A\tc #B6DAC30BFFFF",
"S\tc #10401C71D75C",
"D\tc #596571C6FFFF",
"F\tc #38E34924FFFF",
"                                                                             \
                                       ",
"                                                                             \
                                       ",
"                                                                             \
                                       ",
"                                                 XoOO++@++@#@@@++#O@$O%&     \
                                       ",
"                                      +XXXX&*=-;$;;;:;O>%,$;<;,O:%-12=34o%56X\
#X                                     ",
"                                 +;#@@%o:7:$:,<<::$O$,;%$,$$:<$:o;89<o0-oo<<<\
q*#%o                                  ",
"                            OX$w,,$,O;O,@$:,;,;8:8o8%;<o:9e88:%:o0889or0to99;\
:o=y*uw#O                              ",
"                       X $$O&:O@$,+,$;o%<,%<;e00<*i=w>99e>:10p0&o989-5*8q0a0%\
88ooo80669oX                           ",
"                     X+O<,;:,,$:;;:;%077::%%>9sddf*ft8w08ii1qd-9<888ifqttff&:\
39888itat7t=qOg                        ",
"                  XX+O,,@$:;<$o18hp*s*i9<i1%ji=eiks0>uuw*4kdp0hihh>*-i7wkfp-*\
phadudp&>oosolz2#X                     ",
"                X$%O@:,+$$<%&>oif3=qdtr04rhoks8&e-0ro9tss04*sypsfp8qs98f-3eie\
w2f0quw3aaf&7ykdpz&#                   ",
"              X@,O@;O,e,:e91o0804x0uwaf4pa5dsf87*9f8>ojjqyq=p=puy4jja970w4i8>\
yuxs2as=adpj5318-wlceX                 ",
"            #O@@OO:os98198h9817=yx2658>f*4jqq*9ye*a9w*eaq0qqiwfa2*qq49prir&1f\
1&qdqqi1rtjpk549r1euql&X               ",
"           g$$@O;;::d933<1r>**f1as5skw*r7w:sty=%pe>32y00fx4x4wjie:dar*8ej:y4s\
t1fx4xptu&e>2t-*:9s:=qzl0+             ",
"          @O+;$,>%::r9o898988<0251s=uxo10<9-w>3o898<7ysxs0adx19yooy0>89889o<e\
jxs0adxw-0o%w3>-99<9o8=qzvbX           ",
"        #OO;$:o:>8o1yf790897;;8ap56pd-1<098hft<0ei0;;>ttd61xai77h9yfte3h81::8\
0au6wx*88811i2h89991::>0qlvcO          ",
"       ##@,$e:08<08w4=woyjy9%31&rudky*h<oh<51f>rq3&:=ww*4=qjsto99o*jt9<*s9o70\
wfx*q=s*<9y<**so9948>7=1aq6nm2         ",
"      #@+O,<*dyd899&k1h9-ah98dss*w1cl4lq*%34j:&zse88uu2p*7xkeas1>&40:09wp9&0f\
ufw-4ke*fi97sho3w=1h8wssjs*6zv*        ",
"     #+@,,:ipjq04p8i8ry80-u0->0xi91llnzln2&7fi2c0p0r%3qeyhs*qd3x<iofwriywpw7w\
x-w0s=k4aqe98uhr7ar*wi>u8eh46lMnO      ",
"    #+X+$<8*4tdx=qetrt88&pks*o<he8p5jju*lnx9j:xqpqs0eo9a9fktf4*ufy1f>8edsj3-<\
&h:0q*f2p4j0--99>audre793i-k5qzMmO     ",
"    +XX,$:7tjs0fs&7*aafsp*5w-9ee&3&p20jsi2n6y6l*s4j9:weew3wq3s4=82aua*st60>he\
e8y8y4sf=y>d=s3s*r5r>8&87e0rx*knNmO    ",
"   +++O><df-riuua97sha2qxpwty&jo*4e3>f5awilznzq6*rr3*fwiqp*axqpuh4t5kqqx7=yi5\
e34hriaurj<*p&kkcuriyy=ehq9yiszvMmN    ",
"  XO+,ohw04t>wte31oysq7xjau35p=t=x*%st-j19>5vqs4u5qkx6qklxf5q4qkxd66dqq55p4xp\
*a4y%ef&e197f*wy4afst5pswu4>odl5lnmb   ",
"  ++O:esxd38h1y*e8hfpq*5qetjprfkdf8hwas3>fr5nzql66cnznvvMvvnvvvnnnnvnnnqqkq5d\
x5ue0&e*s7iwsu55xri=sf34k4e1rcqafzmB#  ",
" ##+,<s1u5xs9s=w&s*9isq5q*>fw*rd6qs-sutdx4ucvnvMvMNmmBBBBVVVVVVVVBVBmmNMllzlq\
cqqs-f=fieu&hfquq2<0*-uwkufyclfatcvBn  ",
" XO@;e9;*d<r8o->e*sjss*p4ur3s8<i=%5siq5lzzvmmmBVCZVVVVVCmg&g=gg&gggzVBBmBBmvz\
c6su=;teoe*rssy4x5sedioej%iz2&ee*qnmVg ",
" g,O,1oo8y0890:&o%<3dfusaxwiw&iy5x4lzlnMMBVCZZBMNNg XXXX                czcNm\
vvzkud>98;<1df4=tx*88h88y0q4>889oilMC6 ",
"X+@,,oh<af=>ra0h<:9-ask5s*y>yffqlznvmBCZZVCcg=#                            #O\
nMNvlq4i9;9>fpqx4*38o9h8t6q13&18<i4mBB ",
"%,@:%:iaq3388t*97tdy=fykq=pr5kcnMBVCZZNMb                                    \
  &Mvlzk>ejy120sqsf*89874cq88*a88plvBCX",
"#$O:9auclw0e0r*7&8turd%uqwk6zvmVCCVM#g                                       \
   X&nn6*8edsjt-5kwu4ri*lnkiw-ie=1kzBVX",
"@+;sxncw>ire1yfdf-8d1885rqzvBVZZNg                                           \
      %q4i<-*oij4y6=fxd6qnt:yos0f8wnmC=",
"$wwncu1920i%7=k471<880f4q6vBZVc#X                                            \
       +y<@;89is5sixt44w46%w9xxw&<iqMZN",
"@w24*r8u*sp5x*sf881yo1fjdnBZB                                                \
        O$@%e&rffad2*eysj2fqdpjyi9*uNCN",
"++,<8=8ry=tuq5t012aiek-wuvCN                                                 \
        #,,:okje8>sfy&1y0=rqq=-0s4*6MZN",
"##,:1887sf51kwasup2faxf94vCg                                                 \
       XOOOra0s9>fw0r9op2k8s*rjsjsdlvCN",
",O,>o89iaux4ls>y2tu2ku*yqnVB                                                 \
       X@@:8qqs8r9*s18h=3qs6ky8ps*5lMZN",
"X@$$>jsf>w5sqqf0pe13q-sr*zmm                                                 \
      X@@@i<2jjdees:a2de9j54queuywy6MZN",
" @,O%e1f45-*juxw&y8<*y>w7qvVb                                                \
     X,+@$;;yi:7h8e8oe94xshsdxhr=>:xMZN",
" %@,:::8jt5q&43i<7980f>8ajlMm#                                               \
    XOO@O;o7&fa819>0::o0*sq=fuio7=&kMZN",
" $;$,;7h7xpqusf1ohohsf08rfqzmN                                               \
 X+O,O;:;e&>ysfo30r9:i&1r*kqdpto0y&cMZN",
" +:,$>pu=*3-ku9uw889ke%1iudqvm=                                              \
@;fykcccqkqs6d1t9rji8wds*s>dqwdrw8pnBZN",
" Ot$:7ojje*wxuk0du>>1a3-&y34zvm=                                             \
  $$6mMmmv66lk4=*-3wy89q7f-ds5u*2i1nmZN",
"  ;::;o<y8-d5wxqyqwa&he%trkpq6nB6                                            \
     #XcvMBMvzqx4skdrf>1h>&xy*4u52unVZ#",
"  %e:;$e8&wyqu&s*t-fs=1y04kdewcvMX                                           \
         Xg2mMmnlc66h>e<81-=qp&4u&lvVZX",
"  Xw$:%*<0p9eixjs8060f4qxj1-tp2lvM*                                          \
             Ozvmvzqqa=ei2iy8tle5>lmCZX",
"   $-:e*8s5ho0t-=98-jswx5ss32u*kzvMX                                         \
               X=Nmnllq2fxu<iytyt=6NZc ",
"   X89<14=sw>wtwy>8r5xjxfys*fssk6zzM&                                        \
                  6Mmn66q*j9ej0ri4nBZ= ",
"    %<78qk=-re3f9y*7h2uqqr>ss=4kq6lzN&                                       \
                   ##6Mnz6fe*efrwqvZBX ",
"    oi:,ta858ejo&s3=yfp5qqwpho>su0qczm&                                      \
                      #nvqxd<*-h5zmZN  ",
"    Xy$,:9o89ho8<<03qjrwpky%y1oet19pqcv&X                                    \
                       Xon6u0o8oinBZg  ",
"     $e:>90o319h<%<-sdq4*sio9h8wu2y46zvmN#                                   \
                         $2l491y2MCZ#  ",
"     X-:&e987yjho&=1wuax=s*e9a8fx6qlvNBBZC#                                  \
                           j6df0lBZc   ",
"      $8te<8hea-0eu2p41fl=pdr*2cznMBVZZZccg                              ###+\
+OOg                        260svCC#   ",
"       ;<iooyw=yr8oj1etxp2qjl5zvNVVZBNOX                 X+#XX++##+      X #@\
$<;$;of6XOX                  =6kmZN    ",
"       +a8%<:ax4-h<>0-1q4kkcnvmVZZC=X               X&$O+$8o1-o:%02$gwX      \
X;e;,,%10xog#                OnzBZ#    ",
"        oh89=yd*8>7f>f145czMmVZCMX              ++ooO;;;%,<$o:%,O;,7wa*x2+OX \
  X0qs=:;;<*7qoOX             $lVc     ",
"         jtp4ue31s=-%l5x6vmVZZM#            AXO+$:O,+$;,<e91<;:<>o:9>o>:5s6*g\
    #snj%::9:uqq6$             vB#     ",
"         $4>f9323q=4pqzzNBZCM#            #+o$@+,@,$:,:w9hjh99tjth8tw8>0o9ipd\
q$    ol6d*7y%siwckO           nz      ",
"          ;qu17r=sdllvmBZZM#           Xg@$:;O@$:<o<$e**41ls8st3su2kw:e8iw<7t\
qzcgX  #llk4ufw:jr5zqOX        XX      ",
"          Xq4p%w5sqzMBCZVc           ++:O,@>::::io79j8o0x5kq9i4yf0q2**9fe09rt\
iuzznX   $z54qar87j=qzlg               ",
"           #qd1exqzNVCCbX          #g;@@@+O<;%e:18>&tjs41=jq5ayw<otpow87w<hrs\
ssulzn+   gkuj<w8oe>&2zn=#             ",
"            &6p=lvmCZN           +%@,@OO:$;008i&&*k9<94x4qdq4shfh>ff=%yh>1oo>\
t5ac6vn&   %zki8oho9o<ulnMO            ",
"             qqcvVZCO          #$;$;;;;;-t34lk2klzlx46k6llc6xku46dqqqfusfa>8w\
8p4qqlzm=   &ndo&8y9%88*qnMgX          ",
"             OnvVZc#         #O@@,;ijjqq66cvnnnvNMnvvvMvvvMMvvnnzznzz66cl5d66\
5kxpql6vvX   %68193oo*jp5qcmn          ",
"              gBBc         #$+@,;w5nvvMNNmmBBBBBCVVVVVCVVVVVVVBBBmBmNNmmvnzzz\
zlcxqq6zmM#   $6t890-<*us5xzNnX        ",
"               gX         @@@OeqnMBVVCCVBVBVVBCNOgggggogggggggggoBBBBNNNmVBBm\
MnnznlzznBc    Of1-=38ia9>4lzmv        ",
"                        XO;8qnmVCZNnMMNo                                #vccc\
mBBBmNvnvmB=    wdd18ooo9eaqlnNv       ",
"                      +g9qvvMBc#ggX                 X #2oosczOX#             \
#OOONNMVMmBN    #5w7ooho9p&ujqvmn      ",
"                     Xpc%gz+                      O@&o@,;,7kcqqcgg           \
      #bnBBC=    gu>80fpeq-7iqcnmO     ",
"                    X$ +                        #;%:,,:es=f2x0:9klzOX        \
        X#=Bz     &98ewutu*i73qzMBO    ",
"                                               g%++;s4zvvMMzzl4-%hqMcg       \
           #c     #s><ywxxfi*ydqzmN    ",
"                                             Ow,O$4nmVVVCVBVBmvzcj95vBg      \
                   o-;ooq1wpor-&cmB=   ",
"                                            #o@OpzBCCBNSSSSSSNNmzl6d5zNO     \
                   X%,,;a8>9i889fcBNX  ",
"                                           #g@$qmCCNSbDDbbbbFDSSNNnkqqlmg    \
                    O:,:8*8e=>h9:jvVM  ",
"                                          +w+;lBCBSSSSFDFSbSFFSFSSNnq5qvBg   \
                    X>@;ts9earpo8kzBN  ",
"                                          O+$qBZNbSSSSFDFbFFDFSFSSSNzuqqvBX  \
                    XOO;s-9892a87qzmV& ",
"                                         O,+fBZNbFSbSSFDFFFFDFbFSSFbSzf*lmc  \
                     @@,%8y13-0*yolMBN ",
"                                         ++$MCNSSFbbbSSDDFFFDFFSSFFSSN6%qvVg \
                     $;@8888954*y<=zBCX",
"                                        XX+6VBSSSbFFSFSDAFFDDFFSFFbSSSNs:cmN \
                     $$,oe0rw0qp%ircMCc",
"                                        O+&mZNSSSSFDFbSFADDADFbbFSSSbbSc:sMB=\
                      @;$efqkseiwf34MCM",
"                                       $,O6ZNFSSSbbFDFFFAAAAADFDFSSSFFDc>:zVn\
                      +@:tp2u*stskpqnVM",
"                                       O@$MZSFFFSSbSFADDAAAAADADSSFDDDDb2<*mB\
#                     +Oo3fu41f2*auqvBV",
"                       #X             #w+2VZSSbFFFbbFAAAA   AAADDDAADDFbc,ovZ\
g                     +@gy246r:drj4qvBZ",
"                    go4&              X$+5VNbSSbFFDFDAA     A AAAAADFbFSb,$nB\
#                     @,$7p25jr=a8%4zmZ",
"               X+#e%vn*               X@@cVNSSbbFFFDAAA       A ADDFFFDDb$@yM\
b                    #+Oo959kdfoy78izmZ",
"            X +#$:6NNX                 +,mZNSSSSFbFDAA         AAADDDFFFbo+;z\
m                     +@1rqdpshoo0ofzNZ",
"           X$%,,fmC&                   #emCSSSSSbbFDAA          AAADDDDFbg+:z\
M                    +@,:uekdyf&>yi2zmZ",
"         XO@;$rvCM#                   XewMCSbbbbFbFDAX         AADDDDDDFbg+ov\
N                   X@+:<*od4pf*y19kzNZ",
"        X++@;qNZN                     X02vCNSSbbDDAAAX        AAAAFFbSSSSg@2m\
V                   +++%78h4=*q&qr8hzmZ",
"      XX@+@:zmZN                      #s0vVNFFDDDDDDAA        AADFFFFFFSb$@lC\
=                  #+++:1<yqxr0x*uyuzmZ",
"     X+X++:kmZN                       +s$qBNFFFFFbSFAAA    XA AAAFbSSbFSb@$vZ\
g                  @X+O>8&&1*rkaqp*knBZ",
"    X@@#@%svCV                        #j,wmBSbbSSFDDDDAXAA AAAAADFDFSSSSb+%mZ\
O                 X+@$ioix=->0stc6wqvVZ",
"   +O@@$<=zmZb                         $;;zVNSSSFFFFFAAAAA ADAADDFFFFSSSg,qCB\
                 X@+,78*w3do1p&>5coqMZB",
"  X$+@;7*lnBZ#                         O$:qBNSbFFFFbDDDDAAAASFADFDFSbFSb+$nZM\
                #O++$<d34ut7f8xt:6znmZN",
"  XX@O%>4lzVN                           4%7zBNFbbbbDFFFFDDAAbSFDFFDFSSSgX=BZO\
               #%,+Oo1144-d1e0eh&xzvBZM",
"  O+@,o;w5zBC#                          6t>qMBSbSSFFFFFFFFDDFSSFDSFFFSb@;nZN \
              X:+O$<77;:de-0>188&dqMVZX",
" +$+O:87e6cNV#                           %oalmNSSbFFFSbFFFDDFSSbDFSFSb@$qBZg \
             XO@@;:>oh7oat81w890<8lmZCX",
" XO@@:187kqnB=                           g4:=nmNbFFbbbbFFFFDFSSSFDbSbg@&mZN  \
           X++O$:o88o998f*eepyy9>5vBZ= ",
" +$,;<9oquuqvB=                           v2f2zNNSSFSSFSbFFFFSSSSFbb,+<vCC#  \
          X#OO,$e00t>98y41>9<2p>2zmZB  ",
" X$::9<1*e*qlvmw                          +zq85lvNSSSFFSbFFFFSSSSSb,+>vCC#   \
        #OO@@$;<*xr=uy8yp0fe3efdkvVZb  ",
" Oy;%u=oyfe7fznvoX                         Xcqqj5nvNSSSSSbFFFSSSbg++$MCC#    \
       X#@+O,;:df9ks=4eiy1e8w5u6nmZVX  ",
" Xo;:889fs10-5clnqg                         Xzl6jauqnMNSSSSbbbboX+,2MCC#     \
     #$$++@O$891kswjx3wrf*93-26cMCC#   ",
"  O0o882ttskqsd0f5llcO                       #Mz664=<ijpk*0e>$@@$fcmZC#      \
   X;O,@OO;<:1t&wiu4teid72kq4qzvVZM    ",
"   8;o>erjsjlsfy04czqz=&                      #2Mv6l*>8o<<&>;;icnmCZc#       \
XOOO:,$;$7=teuse7rw*f8<3sdrqqkvVZN     ",
"   Oy;$8s5xwxt*p4z**f*rai*w#O                   XbNmvzcq0-s5cvNVCZB=      X#X\
O;$O;;<o=jaudyj1>s1-w9itqu*4cvBZC      ",
"   Xi:ihofqkkq:t6l4fq50:-9-y4%o4#XX               #cmvmvnzmVVZVCcgX   X o$@$@\
@,$:y0oo3sffqkfwh9sa1e*1*46lvBCZ=      ",
"    Ok=&y7*squ=ez2;e58e&<&o<>u1w0s5w#Oo#              =c2&2ccMg    $Xg$+O+O;:\
#<<0*5y0*88-2f1x<90<i5stwqlMBCZ=       ",
"     %yaw*wjf5u=l=:;rio&oooo%:8*r97yufu<$:;=w#XXXXX           $o$@O%,@@+@@O@:\
&=9s32xte3o:ito1e:o98ey4llvBZZ=        ",
"     #q*4a5xau-oc5991fi8hh88;;<h>s*&3<;;oe:-w:%e:%:OO$>ewye8>;O,$,$,$,:;,:$:;\
-fdq0u=-o809r*38*w1yooiqzmVZZ=         ",
"      #lq45fksj>e2:&uy198*0oe1e0ypfs&h%,;:$:e:,,::;O$::$oo<%,;@O;@::;,:>7::e&\
y74aqut0899:42&oyrdi9a6vmVZNX          ",
"       +zzqrkkeu&>8eqe18ir088jjtu=-k58*99;808:o:<:;::oe;<;08ooe:;8099%1e3999f\
ts*euqf=u&>&sj1&>*4*kzMVCZN            ",
"        #466l*qr4si>iys7-iphy>jj:h02pkwito888ioeie:7o9078e*&*=8p%87y91800w*7i\
qe1i43jxyq7hwf1r0t6lvmVZCO             ",
"          &vzqqkdq=ef3>9ejxjt8oyw<j4wuufkyy=f>98fd=h><8080x*s4fd3i7f>8-uxsa7<\
-h>fq*f5jdsw0j9aqlvmBZZc#              ",
"           gzv6ckf*5a4ts*2dp-89ooa8s5ejp=ery*tt0fqt>;ho:t-a5-yfwef&p=s&2ur&o8\
9owaekw2ut844q4lnNBCZBb                ",
"            XzMvlqsqa4k6qs07390i=p11&u2a17de=pqqpw30e0>rj0-os5*y>5*e*6k2a7*10\
8wu4yeakf*yq6zvmBVZC=X                 ",
"              Ocmncqlqukqjs*sksp3q1%13hy19:uujru327q4sa34t%ejofhoej4*=2ysas4s\
23ua91k1464zvmBCZBb                    ",
"                OzMMvzlcq4*5u3254581wepwiedsksqx1afat*dx4etwyt3:hyx4suqs334*f\
5qsafx5qlnMmVZZV=X                     ",
"                  $nmmmMvcq6qquqqusaa=trur8-6u5qu:sads5qk3r*rris*ye*25q5%pp2k\
2clqkzzMNBZZZcc                        ",
"                   XX=MmVmMnll=q634shpi8skjsws5k4*=38%e*er0:0<9y4a4ju4dld5k2u\
5zzvMmBCZZBg#                          ",
"                       g=MBmmmmvnnl666qu&rkc65xuq5tdy3>us3arp*r%-5qqqq6l6qcnn\
vNBVZZZMb=                             ",
"                         XX#MMnBBBmMNvvzzcllznzzcqxk6qq6cq6qxqks6lzzvvvvMmmBV\
CZCNB=XX                               ",
"                               g=gNBBmmBBBBBmMMmMMvvvvvvvvvvMvvMMMmNBVVCCCCZN\
gbg                                    ",
"                                   XX #vnnncNCCVVVVVVVVVVVVVVVVCCCCZNMMNNg X \
                                       ",
"                                            +gggggggggggggggggogggg=X        \
                                       "
};
static Fl_Image *image_sane() {
  static Fl_Image *image = new Fl_Pixmap(idata_sane);
  return image;
}

Fl_Button *showCopyright=(Fl_Button *)0;

static void cb_showCopyright(Fl_Button*, void*) {
  if (copyrightWindow) {
    copyrightWindow->show();
};
}

Fl_Group *FlScanImageSelector=(Fl_Group *)0;

FileBrowser *FlScanFileBrowser=(FileBrowser *)0;

static void cb_FlScanFileBrowser(FileBrowser*, void*) {
  FlScanChangeDirectory();
}

Fl_Progress *FlScanProgressBar=(Fl_Progress *)0;

Fl_Tabs *FlScanTabs=(Fl_Tabs *)0;

static void cb_FlScanTabs(Fl_Tabs*, void*) {
  if (FlScanTabs->value()==FlScanTabView) {
    FlScanSetMode(FL_SCAN_VIEW_MODE);
} else {
    FlScanSetMode(FL_SCAN_SCAN_MODE);
};
}

Fl_Group *FlScanTabThumbnails=(Fl_Group *)0;

static const char *idata_Thumbnails[] = {
"20 20 4 1",
" \tc none",
"X\tc gray30",
"a\tc white",
"o\tc black",
"aaaaaaaaaaaaaaaaaaaa",
"a        Xa        X",
"a        Xa        X",
"a XXXXXX Xa XXXXXX X",
"a Xooooa Xa Xooooa X",
"a Xooooa Xa Xooooa X",
"a Xaaaaa Xa Xaaaaa X",
"a        Xa        X",
"a        Xa        X",
"aXXXXXXXXXaXXXXXXXXX",
"aaaaaaaaaaaaaaaaaaaa",
"a        Xa        X",
"a        Xa        X",
"a XXXXXX Xa XXXXXX X",
"a Xooooa Xa Xooooa X",
"a Xooooa Xa Xooooa X",
"a Xaaaaa Xa Xaaaaa X",
"a        Xa        X",
"a        Xa        X",
"aXXXXXXXXXaXXXXXXXXX"
};
static Fl_Image *image_Thumbnails() {
  static Fl_Image *image = new Fl_Pixmap(idata_Thumbnails);
  return image;
}

Fl_Pack *FlScanThumbsRows=(Fl_Pack *)0;

Fl_Group *FlScanTabPreview=(Fl_Group *)0;

static const char *idata_Preview[] = {
"19 19 4 1",
" \tc none",
"X\tc gray30",
"a\tc white",
"o\tc black",
"aaaaaaaaaaaaaaaaaaa",
"a                 X",
"a                 X",
"a                 X",
"a                 X",
"a  XXXXXXXXXXXXX  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xaaaaaaaaaaaa  X",
"a                 X",
"a                 X",
"a                 X",
"a                 X",
"aXXXXXXXXXXXXXXXXXX"
};
static Fl_Image *image_Preview() {
  static Fl_Image *image = new Fl_Pixmap(idata_Preview);
  return image;
}

Fl_Image_Preview *FlScanPreviewArea=(Fl_Image_Preview *)0;

static void cb_FlScanPreviewArea(Fl_Image_Preview*, void*) {
  FlScanUpdateSelection();
}

Fl_Group *FlScanTabConversion=(Fl_Group *)0;

Conversions_List *FlScanConversionArea=(Conversions_List *)0;

Fl_Group *FlScanTabView=(Fl_Group *)0;

static const char *idata_Acquire[] = {
"20 14 4 1",
" \tc None",
".\tc black",
"X\tc white",
"o\tc gray50",
"       ........     ",
"      .XXXXXXXX.    ",
" .....Xo.....oX.... ",
".XXXXX.........XXXX.",
"........ooooo.......",
".Xooo..oXXXooo..ooo.",
".Xooo..oXooooo..ooo.",
".Xooo..oXooooo..ooo.",
".Xooo..ooooooo..ooo.",
".Xooo..ooooooo..ooo.",
".Xoooo..ooooo..oooo.",
".Xoooo.........oooo.",
".Xoooooo.....oooooo.",
" .................. "
};
static Fl_Image *image_Acquire() {
  static Fl_Image *image = new Fl_Pixmap(idata_Acquire);
  return image;
}

Fl_Scrolled_Image *FlScanSwViewArea=(Fl_Scrolled_Image *)0;

Fl_Image_View *FlScanViewArea=(Fl_Image_View *)0;

Fl_Group *FlScanToolBar=(Fl_Group *)0;

Fl_Group *FlScanPreviewTools=(Fl_Group *)0;

Fl_RaiseButton *FlScanThumbnailsRotateCCW=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsRotateCCW(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->rotate_cw();
}

static const char *idata_rotate_cw90[] = {
"19 19 2 1",
" \tnone",
".\tc black",
"                 ..",
"            .      ",
"            ..   ..",
"          .....  ..",
"        ........ ..",
"      .........  ..",
"     .....  ..     ",
"    ....    .    ..",
"   ....          ..",
"   ...           ..",
"  ....           ..",
"  ...              ",
" ....            ..",
" ...             ..",
" ...             ..",
" ...             ..",
"                   ",
"...................",
"..................."
};
static Fl_Image *image_rotate_cw90() {
  static Fl_Image *image = new Fl_Pixmap(idata_rotate_cw90);
  return image;
}

Fl_RaiseButton *FlScanThumbnailsRotateCW=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsRotateCW(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->rotate_ccw();
}

static const char *idata_rotate_ccw90[] = {
"19 19 2 1",
" \tc black",
".\tnone",
"  .................",
"...... ............",
"  ...  ............",
"  ..     ..........",
"  .        ........",
"  ..         ......",
".....  ..     .....",
"  .... ....    ....",
"  ..........    ...",
"  ...........   ...",
"  ...........    ..",
"..............   ..",
"  ............    .",
"  .............   .",
"  .............   .",
"  .............   .",
"...................",
"                   ",
"                   "
};
static Fl_Image *image_rotate_ccw90() {
  static Fl_Image *image = new Fl_Pixmap(idata_rotate_ccw90);
  return image;
}

Fl_RaiseButton *FlScanThumbnailsSetHorizont=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsSetHorizont(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->set_horizont(FlScanThumbnailsSetHorizont->value(),FlScanThumbnailsSetHorizont);
}

static const char *idata_set_horizont[] = {
"19 19 5 1",
" \tc gray80",
".\tc black",
"X\tnone",
"o\tc gray40",
"b\tc gray20",
"                   ",
"       .....       ",
"       .X.X.       ",
"       .X.X.       ",
"      .......      ",
"      .X.X.X.      ",
"      .X.X.X.      ",
"      .X.X.X.      ",
"      .......      ",
"      .X.X.X.      ",
"      .X.X.X.      ",
"      .X.X.X.      ",
"      .......      ",
"      .X.X.X. ooooo",
"     o.X.X.X.oooooo",
"oooooo.X.X.X.oooooo",
"oooobbbbbbbbbbboooo",
"oooobbbbbbbbbbboooo",
"oooobbbbbbbbbbboooo"
};
static Fl_Image *image_set_horizont() {
  static Fl_Image *image = new Fl_Pixmap(idata_set_horizont);
  return image;
}

Fl_RaiseButton *FlScanThumbnailsUndoRotate=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsUndoRotate(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->undo_rotate();
}

static const char *idata_undo_rotate[] = {
"19 19 2 1",
" \tnone",
".\tc #000000000000",
"                   ",
"                   ",
"       .....       ",
"     .........     ",
"    ...........    ",
"   ....     ....   ",
"   ...       ...   ",
"  ...         ...  ",
"  ...         ...  ",
"  ...         ...  ",
"  ...  .      ...  ",
"  ... ..      ...  ",
"   .....     ...   ",
"   .....    ....   ",
"   .....  .....    ",
"  ......  ....     ",
" .......  ..       ",
"                   ",
"                   "
};
static Fl_Image *image_undo_rotate() {
  static Fl_Image *image = new Fl_Pixmap(idata_undo_rotate);
  return image;
}

Fl_RaiseButton *FlScanThumbnailsHorizontalMirror=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsHorizontalMirror(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->flip_horizontal();
}

static const char *idata_horizontal_mirror[] = {
"    19    19        3            1",
". c black",
"  none",
"a c white",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"   .           .   ",
"  ..           ..  ",
" ................. ",
"...................",
" ................. ",
"  ..           ..  ",
"   .           .   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   "
};
static Fl_Image *image_horizontal_mirror() {
  static Fl_Image *image = new Fl_Pixmap(idata_horizontal_mirror);
  return image;
}

Fl_RaiseButton *FlScanThumbnailsVerticalMirror=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsVerticalMirror(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->flip_vertical();
}

static const char *idata_vertical_mirror[] = {
"    19    19        3            1",
". c black",
"  none",
"a c white",
"         .         ",
"        ...        ",
"       .....       ",
"      .......      ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"      .......      ",
"       .....       ",
"        ...        ",
"         .         "
};
static Fl_Image *image_vertical_mirror() {
  static Fl_Image *image = new Fl_Pixmap(idata_vertical_mirror);
  return image;
}

Fl_RaiseButton *FlScanPreviewZoomPlus=(Fl_RaiseButton *)0;

static void cb_FlScanPreviewZoomPlus(Fl_RaiseButton*, void*) {
  FlScanResize(INCREASE_SIZE);
}

static const char *idata_zoom_in[] = {
"    19    19        3            1",
"  none",
". c black",
"a c white",
"...................",
".aaaaaaaaa.aaaaaaa.",
"...................",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
"...........       .",
".                 .",
".           .     .",
".          ...  . .",
".           ..... .",
".            .... .",
".            .... .",
".           ..... .",
".                 .",
"..................."
};
static Fl_Image *image_zoom_in() {
  static Fl_Image *image = new Fl_Pixmap(idata_zoom_in);
  return image;
}

Fl_RaiseButton *FlScanPreviewZoomMinus=(Fl_RaiseButton *)0;

static void cb_FlScanPreviewZoomMinus(Fl_RaiseButton*, void*) {
  FlScanResize(DECREASE_SIZE);
}

static const char *idata_zoom_out[] = {
"    19    19        3            1",
"  none",
". c black",
"a c white",
"...................",
".aaaaaaaaa.aaaaaaa.",
"...................",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
"...........       .",
".                 .",
".          .....  .",
".          ....   .",
".          ....   .",
".          .....  .",
".          .  ... .",
".              .  .",
".                 .",
"..................."
};
static Fl_Image *image_zoom_out() {
  static Fl_Image *image = new Fl_Pixmap(idata_zoom_out);
  return image;
}

Fl_RaiseButton *FlScanPreviewZoomScreen=(Fl_RaiseButton *)0;

static void cb_FlScanPreviewZoomScreen(Fl_RaiseButton*, void*) {
  FlScanResize(FIT_TO_SCREEN);
}

static const char *idata_zoom_undo[] = {
"    19    19        3            1",
"  none",
". c black",
"a c white",
"         .         ",
"        ...        ",
"       .....       ",
"                   ",
"    ...........    ",
"    .aaaaaaaaa.    ",
"    ...........    ",
"  . .         . .  ",
" .. .         . .. ",
"... .         . ...",
" .. .         . .. ",
"  . .         . .  ",
"    .         .    ",
"    .         .    ",
"    ...........    ",
"                   ",
"       .....       ",
"        ...        ",
"         .         "
};
static Fl_Image *image_zoom_undo() {
  static Fl_Image *image = new Fl_Pixmap(idata_zoom_undo);
  return image;
}

Fl_RaiseButton *FlScanPreviewZoomMinimize=(Fl_RaiseButton *)0;

static void cb_FlScanPreviewZoomMinimize(Fl_RaiseButton*, void*) {
  FlScanResize(0);
}

static const char *idata_zoom_mini[] = {
"    19    19        3            1",
"  none",
". c black",
"a c white",
"       .....       ",
"        ...        ",
"         .         ",
"                   ",
"    ...........    ",
"    .aaaaaaaaa.    ",
"    ...........    ",
".   .         .   .",
"..  .         .  ..",
"... .         . ...",
"..  .         .  ..",
".   .         .   .",
"    .         .    ",
"    .         .    ",
"    ...........    ",
"                   ",
"         .         ",
"        ...        ",
"       .....       "
};
static Fl_Image *image_zoom_mini() {
  static Fl_Image *image = new Fl_Pixmap(idata_zoom_mini);
  return image;
}

EatEvent *FlScanEeLockView=(EatEvent *)0;

EatEvent *FlScanEeWaitForSaving=(EatEvent *)0;

Fl_Double_Window* makeFlSCAN(bool enable_scan) {
  { Fl_Double_Window* o = FlScan = new Fl_Double_Window(640, 480, gettext("Fl Scan"));
    { FlScanContainer = new Fl_Group(0, 0, 640, 480);
      { Fl_Group* o = new Fl_Group(460, 0, 175, 480);
        o->box(FL_FLAT_BOX);
        { FlScanScannerOptions = new Fl_Tree_Browser(460, 5, 175, 200, gettext("Scanner"));
          FlScanScannerOptions->tooltip(gettext("Scanner Specific Settings"));
          FlScanScannerOptions->type(1);
          FlScanScannerOptions->box(FL_THIN_DOWN_BOX);
          FlScanScannerOptions->color(FL_BACKGROUND_COLOR);
          FlScanScannerOptions->selection_color(FL_BACKGROUND_COLOR);
          FlScanScannerOptions->labeltype(FL_NO_LABEL);
          FlScanScannerOptions->labelfont(1);
          FlScanScannerOptions->labelsize(12);
          FlScanScannerOptions->labelcolor(FL_FOREGROUND_COLOR);
          FlScanScannerOptions->textsize(12);
          FlScanScannerOptions->callback((Fl_Callback*)cb_selectoption);
          FlScanScannerOptions->align(Fl_Align(FL_ALIGN_TOP));
          FlScanScannerOptions->when(FL_WHEN_RELEASE);
          Fl_Group::current()->resizable(FlScanScannerOptions);
        } // Fl_Tree_Browser* FlScanScannerOptions
        { FlScanSettings = new Fl_Group(460, 350, 175, 100);
          FlScanSettings->box(FL_THIN_DOWN_BOX);
          { FlScanMisc = new Fl_Group(461, 351, 173, 98);
            FlScanMisc->box(FL_FLAT_BOX);
            FlScanMisc->labeltype(FL_NO_LABEL);
            FlScanMisc->align(Fl_Align(FL_ALIGN_CENTER));
            { FlScanScanFileType = new Fl_Sorted_Choice(570, 355, 60, 20);
              FlScanScanFileType->box(FL_ENGRAVED_BOX);
              FlScanScanFileType->down_box(FL_BORDER_BOX);
              FlScanScanFileType->color(FL_BACKGROUND_COLOR);
              FlScanScanFileType->selection_color(FL_SELECTION_COLOR);
              FlScanScanFileType->labeltype(FL_NO_LABEL);
              FlScanScanFileType->labelfont(1);
              FlScanScanFileType->labelsize(14);
              FlScanScanFileType->labelcolor(FL_FOREGROUND_COLOR);
              FlScanScanFileType->align(Fl_Align(FL_ALIGN_LEFT));
              FlScanScanFileType->when(FL_WHEN_RELEASE);
              if (!menu_FlScanScanFileType_i18n_done) {
                int i=0;
                for ( ; i<5; i++)
                  if (menu_FlScanScanFileType[i].label())
                    menu_FlScanScanFileType[i].label(gettext(menu_FlScanScanFileType[i].label()));
                menu_FlScanScanFileType_i18n_done = 1;
              }
              FlScanScanFileType->menu(menu_FlScanScanFileType);
            } // Fl_Sorted_Choice* FlScanScanFileType
            { FlScanTxFileName = new Fl_Input(465, 355, 105, 20);
              FlScanTxFileName->tooltip(gettext("Output file name"));
              FlScanTxFileName->box(FL_THIN_DOWN_BOX);
              FlScanTxFileName->labeltype(FL_NO_LABEL);
              FlScanTxFileName->labelfont(1);
              FlScanTxFileName->labelsize(12);
              FlScanTxFileName->textfont(1);
              FlScanTxFileName->textsize(12);
              FlScanTxFileName->callback((Fl_Callback*)cb_FlScanTxFileName);
              FlScanTxFileName->when(FL_WHEN_CHANGED);
            } // Fl_Input* FlScanTxFileName
            { FlScanLbSeparator = new Fl_Box(465, 379, 165, 2);
              FlScanLbSeparator->box(FL_THIN_DOWN_FRAME);
              FlScanLbSeparator->labeltype(FL_NO_LABEL);
              FlScanLbSeparator->hide();
            } // Fl_Box* FlScanLbSeparator
            { FlScanPbFileSelector = new Fl_Button(465, 355, 20, 20);
              FlScanPbFileSelector->box(FL_ENGRAVED_BOX);
              FlScanPbFileSelector->image( image_file() );
              FlScanPbFileSelector->callback((Fl_Callback*)cb_FlScanPbFileSelector);
              FlScanPbFileSelector->hide();
            } // Fl_Button* FlScanPbFileSelector
            { FlScanPbPreview = new Fl_Button(465, 380, 80, 30, gettext("Preview"));
              FlScanPbPreview->box(FL_ENGRAVED_BOX);
              FlScanPbPreview->labelfont(1);
              FlScanPbPreview->labelsize(12);
              FlScanPbPreview->callback((Fl_Callback*)cb_FlScanPbPreview);
            } // Fl_Button* FlScanPbPreview
            { FlScanPbScan = new Fl_Button(550, 380, 80, 30, gettext("Scan"));
              FlScanPbScan->box(FL_ENGRAVED_BOX);
              FlScanPbScan->labelfont(1);
              FlScanPbScan->labelsize(12);
              FlScanPbScan->callback((Fl_Callback*)cb_FlScanPbScan);
              FlScanPbScan->deactivate();
            } // Fl_Button* FlScanPbScan
            { FlScanPbReset = new Fl_Button(550, 415, 80, 30, gettext("Reset"));
              FlScanPbReset->box(FL_ENGRAVED_BOX);
              FlScanPbReset->labelfont(1);
              FlScanPbReset->labelsize(12);
              FlScanPbReset->callback((Fl_Callback*)cb_FlScanPbReset);
              FlScanPbReset->hide();
            } // Fl_Button* FlScanPbReset
            { FlScanPbCancel = new Fl_Button(465, 415, 80, 30, gettext("Cancel"));
              FlScanPbCancel->box(FL_ENGRAVED_BOX);
              FlScanPbCancel->labelfont(1);
              FlScanPbCancel->labelsize(12);
              FlScanPbCancel->callback((Fl_Callback*)cb_FlScanPbCancel);
              FlScanPbCancel->deactivate();
            } // Fl_Button* FlScanPbCancel
            FlScanMisc->end();
          } // Fl_Group* FlScanMisc
          FlScanSettings->end();
        } // Fl_Group* FlScanSettings
        { FlScanSetOption = new Fl_Group(460, 205, 175, 145);
          FlScanSetOption->box(FL_THIN_DOWN_BOX);
          FlScanSetOption->labelsize(12);
          FlScanSetOption->align(Fl_Align(69|FL_ALIGN_INSIDE));
          { FlScanPbAutoOption = new Fl_Button(465, 325, 80, 20, gettext("Auto"));
            FlScanPbAutoOption->box(FL_ENGRAVED_BOX);
            FlScanPbAutoOption->labelfont(1);
            FlScanPbAutoOption->labelsize(12);
            FlScanPbAutoOption->callback((Fl_Callback*)cb_FlScanPbAutoOption);
            FlScanPbAutoOption->hide();
          } // Fl_Button* FlScanPbAutoOption
          { FlScanPbSetOption = new Fl_Button(550, 325, 80, 20, gettext("Set"));
            FlScanPbSetOption->box(FL_ENGRAVED_BOX);
            FlScanPbSetOption->labelfont(1);
            FlScanPbSetOption->labelsize(12);
            FlScanPbSetOption->callback((Fl_Callback*)cb_FlScanPbSetOption);
            FlScanPbSetOption->hide();
          } // Fl_Button* FlScanPbSetOption
          { FlScanBoolGroup = new Fl_Group(461, 206, 173, 143);
            FlScanBoolGroup->labeltype(FL_NO_LABEL);
            FlScanBoolGroup->labelsize(12);
            FlScanBoolGroup->align(Fl_Align(FL_ALIGN_CLIP));
            FlScanBoolGroup->hide();
            { FlScanTbBoolType = new Fl_Light_Button(461, 270, 173, 20);
              FlScanTbBoolType->box(FL_NO_BOX);
              FlScanTbBoolType->labelsize(12);
              FlScanTbBoolType->callback((Fl_Callback*)cb_FlScanTbBoolType);
              FlScanTbBoolType->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Light_Button* FlScanTbBoolType
            FlScanBoolGroup->end();
          } // Fl_Group* FlScanBoolGroup
          { FlScanFixedGroup = new Fl_Group(461, 206, 173, 119);
            FlScanFixedGroup->labeltype(FL_NO_LABEL);
            FlScanFixedGroup->labelsize(12);
            FlScanFixedGroup->align(Fl_Align(FL_ALIGN_CLIP));
            FlScanFixedGroup->hide();
            { FlScanTxFixedType = new Fl_Float_Input(535, 275, 95, 20, gettext("Real Input:"));
              FlScanTxFixedType->type(1);
              FlScanTxFixedType->box(FL_THIN_DOWN_BOX);
              FlScanTxFixedType->labelsize(12);
              FlScanTxFixedType->textsize(12);
              FlScanTxFixedType->callback((Fl_Callback*)cb_FlScanTxFixedType);
              FlScanTxFixedType->when(FL_WHEN_CHANGED);
            } // Fl_Float_Input* FlScanTxFixedType
            FlScanFixedGroup->end();
          } // Fl_Group* FlScanFixedGroup
          { FlScanIntGroup = new Fl_Group(461, 206, 173, 119);
            FlScanIntGroup->labeltype(FL_NO_LABEL);
            FlScanIntGroup->labelsize(12);
            FlScanIntGroup->align(Fl_Align(FL_ALIGN_CLIP));
            FlScanIntGroup->hide();
            { FlScanTxIntType = new Fl_Int_Input(550, 275, 80, 20, gettext("Integer Input:"));
              FlScanTxIntType->type(2);
              FlScanTxIntType->box(FL_THIN_DOWN_BOX);
              FlScanTxIntType->labelsize(12);
              FlScanTxIntType->textsize(12);
              FlScanTxIntType->callback((Fl_Callback*)cb_FlScanTxIntType);
              FlScanTxIntType->when(FL_WHEN_CHANGED);
            } // Fl_Int_Input* FlScanTxIntType
            FlScanIntGroup->end();
          } // Fl_Group* FlScanIntGroup
          { FlScanStringGroup = new Fl_Group(461, 206, 173, 119);
            FlScanStringGroup->labeltype(FL_NO_LABEL);
            FlScanStringGroup->labelsize(12);
            FlScanStringGroup->align(Fl_Align(FL_ALIGN_CLIP));
            FlScanStringGroup->hide();
            { FlScanTxStringType = new Fl_Input(465, 275, 165, 20, gettext("Input:"));
              FlScanTxStringType->box(FL_THIN_DOWN_BOX);
              FlScanTxStringType->labeltype(FL_NO_LABEL);
              FlScanTxStringType->labelsize(12);
              FlScanTxStringType->textsize(12);
              FlScanTxStringType->callback((Fl_Callback*)cb_FlScanTxStringType);
              FlScanTxStringType->when(FL_WHEN_CHANGED);
            } // Fl_Input* FlScanTxStringType
            FlScanStringGroup->end();
          } // Fl_Group* FlScanStringGroup
          { FlScanButtonGroup = new Fl_Group(461, 206, 173, 143);
            FlScanButtonGroup->labeltype(FL_NO_LABEL);
            FlScanButtonGroup->labelsize(12);
            FlScanButtonGroup->align(Fl_Align(FL_ALIGN_CLIP));
            FlScanButtonGroup->hide();
            { FlScanPbButtonType = new Fl_Button(465, 260, 165, 45, gettext("Execute"));
              FlScanPbButtonType->box(FL_ENGRAVED_BOX);
              FlScanPbButtonType->labelfont(1);
              FlScanPbButtonType->labelsize(12);
              FlScanPbButtonType->callback((Fl_Callback*)cb_FlScanPbButtonType);
            } // Fl_Button* FlScanPbButtonType
            FlScanButtonGroup->end();
          } // Fl_Group* FlScanButtonGroup
          { FlScanRangeGroup = new Fl_Group(461, 206, 173, 119);
            FlScanRangeGroup->labeltype(FL_NO_LABEL);
            FlScanRangeGroup->labelsize(12);
            FlScanRangeGroup->align(Fl_Align(FL_ALIGN_CLIP));
            FlScanRangeGroup->hide();
            { FlScanSlRangeType = new Fl_Slider(520, 275, 110, 20);
              FlScanSlRangeType->type(5);
              FlScanSlRangeType->box(FL_THIN_DOWN_BOX);
              FlScanSlRangeType->callback((Fl_Callback*)cb_FlScanSlRangeType);
            } // Fl_Slider* FlScanSlRangeType
            { FlScanViRangeType = new Fl_Value_Input(465, 275, 55, 20);
              FlScanViRangeType->box(FL_THIN_DOWN_BOX);
              FlScanViRangeType->labeltype(FL_NO_LABEL);
              FlScanViRangeType->labelsize(12);
              FlScanViRangeType->textfont(1);
              FlScanViRangeType->textsize(12);
              FlScanViRangeType->callback((Fl_Callback*)cb_FlScanViRangeType);
            } // Fl_Value_Input* FlScanViRangeType
            FlScanRangeGroup->end();
          } // Fl_Group* FlScanRangeGroup
          { FlScanListGroup = new Fl_Group(461, 206, 173, 143);
            FlScanListGroup->labeltype(FL_NO_LABEL);
            FlScanListGroup->labelsize(12);
            FlScanListGroup->align(Fl_Align(FL_ALIGN_CLIP));
            FlScanListGroup->hide();
            { FlScanMnListType = new Fl_Sorted_Choice(465, 275, 165, 20);
              FlScanMnListType->box(FL_ENGRAVED_BOX);
              FlScanMnListType->down_box(FL_BORDER_BOX);
              FlScanMnListType->color(FL_BACKGROUND_COLOR);
              FlScanMnListType->selection_color(FL_SELECTION_COLOR);
              FlScanMnListType->labeltype(FL_NORMAL_LABEL);
              FlScanMnListType->labelfont(0);
              FlScanMnListType->labelsize(12);
              FlScanMnListType->labelcolor(FL_FOREGROUND_COLOR);
              FlScanMnListType->textsize(12);
              FlScanMnListType->align(Fl_Align(FL_ALIGN_LEFT));
              FlScanMnListType->when(FL_WHEN_RELEASE);
            } // Fl_Sorted_Choice* FlScanMnListType
            FlScanListGroup->end();
          } // Fl_Group* FlScanListGroup
          { FlScanMessage = new Fl_Group(461, 220, 173, 129);
            FlScanMessage->box(FL_FLAT_BOX);
            FlScanMessage->labelsize(12);
            FlScanMessage->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            FlScanMessage->hide();
            FlScanMessage->end();
          } // Fl_Group* FlScanMessage
          { FlScanTableGroup = new Fl_Group(461, 220, 173, 105);
            FlScanTableGroup->box(FL_FLAT_BOX);
            FlScanTableGroup->labelfont(1);
            FlScanTableGroup->labelsize(12);
            FlScanTableGroup->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            FlScanTableGroup->hide();
            { Fl_RaiseButton* o = FlScanRbSplineTable = new Fl_RaiseButton(465, 220, 20, 20);
              FlScanRbSplineTable->tooltip(gettext("Spline Curve"));
              FlScanRbSplineTable->type(102);
              FlScanRbSplineTable->box(FL_FLAT_BOX);
              FlScanRbSplineTable->down_box(FL_THIN_DOWN_BOX);
              FlScanRbSplineTable->color(FL_BACKGROUND_COLOR);
              FlScanRbSplineTable->selection_color((Fl_Color)3);
              FlScanRbSplineTable->image( image_spline() );
              FlScanRbSplineTable->labeltype(FL_NORMAL_LABEL);
              FlScanRbSplineTable->labelfont(0);
              FlScanRbSplineTable->labelsize(14);
              FlScanRbSplineTable->labelcolor(FL_FOREGROUND_COLOR);
              FlScanRbSplineTable->callback((Fl_Callback*)cb_FlScanRbSplineTable);
              FlScanRbSplineTable->align(Fl_Align(FL_ALIGN_CENTER));
              FlScanRbSplineTable->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanRbSplineTable
            { Fl_RaiseButton* o = FlScanRbLinearTable = new Fl_RaiseButton(485, 220, 20, 20);
              FlScanRbLinearTable->tooltip(gettext("Linear Curve"));
              FlScanRbLinearTable->type(102);
              FlScanRbLinearTable->box(FL_FLAT_BOX);
              FlScanRbLinearTable->down_box(FL_THIN_DOWN_BOX);
              FlScanRbLinearTable->color(FL_BACKGROUND_COLOR);
              FlScanRbLinearTable->selection_color((Fl_Color)3);
              FlScanRbLinearTable->image( image_linear() );
              FlScanRbLinearTable->labeltype(FL_NORMAL_LABEL);
              FlScanRbLinearTable->labelfont(0);
              FlScanRbLinearTable->labelsize(14);
              FlScanRbLinearTable->labelcolor(FL_FOREGROUND_COLOR);
              FlScanRbLinearTable->callback((Fl_Callback*)cb_FlScanRbLinearTable);
              FlScanRbLinearTable->align(Fl_Align(FL_ALIGN_CENTER));
              FlScanRbLinearTable->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanRbLinearTable
            { Fl_RaiseButton* o = FlScanRbFreeTable = new Fl_RaiseButton(505, 220, 20, 20);
              FlScanRbFreeTable->tooltip(gettext("Free Curve"));
              FlScanRbFreeTable->type(102);
              FlScanRbFreeTable->box(FL_FLAT_BOX);
              FlScanRbFreeTable->down_box(FL_THIN_DOWN_BOX);
              FlScanRbFreeTable->color(FL_BACKGROUND_COLOR);
              FlScanRbFreeTable->selection_color((Fl_Color)3);
              FlScanRbFreeTable->image( image_free() );
              FlScanRbFreeTable->labeltype(FL_NORMAL_LABEL);
              FlScanRbFreeTable->labelfont(0);
              FlScanRbFreeTable->labelsize(14);
              FlScanRbFreeTable->labelcolor(FL_FOREGROUND_COLOR);
              FlScanRbFreeTable->callback((Fl_Callback*)cb_FlScanRbFreeTable);
              FlScanRbFreeTable->align(Fl_Align(FL_ALIGN_CENTER));
              FlScanRbFreeTable->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanRbFreeTable
            { Fl_Box* o = new Fl_Box(527, 220, 2, 20);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
            } // Fl_Box* o
            { Fl_RaiseButton* o = FlScanPbGammaTable = new Fl_RaiseButton(530, 220, 20, 20);
              FlScanPbGammaTable->tooltip(gettext("Gamma"));
              FlScanPbGammaTable->box(FL_FLAT_BOX);
              FlScanPbGammaTable->down_box(FL_THIN_DOWN_BOX);
              FlScanPbGammaTable->color(FL_BACKGROUND_COLOR);
              FlScanPbGammaTable->selection_color((Fl_Color)3);
              FlScanPbGammaTable->image( image_gamma() );
              FlScanPbGammaTable->labeltype(FL_NORMAL_LABEL);
              FlScanPbGammaTable->labelfont(0);
              FlScanPbGammaTable->labelsize(14);
              FlScanPbGammaTable->labelcolor(FL_FOREGROUND_COLOR);
              FlScanPbGammaTable->callback((Fl_Callback*)cb_FlScanPbGammaTable);
              FlScanPbGammaTable->align(Fl_Align(FL_ALIGN_CENTER));
              FlScanPbGammaTable->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanPbGammaTable
            { FlScanTxGammaTable = new Fl_Float_Input(550, 220, 55, 20);
              FlScanTxGammaTable->type(1);
              FlScanTxGammaTable->box(FL_THIN_DOWN_BOX);
              FlScanTxGammaTable->labeltype(FL_NO_LABEL);
              FlScanTxGammaTable->labelsize(12);
              FlScanTxGammaTable->textsize(12);
              FlScanTxGammaTable->callback((Fl_Callback*)cb_FlScanTxGammaTable);
              FlScanTxGammaTable->when(FL_WHEN_ENTER_KEY);
            } // Fl_Float_Input* FlScanTxGammaTable
            { Fl_Box* o = new Fl_Box(607, 220, 2, 20);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
            } // Fl_Box* o
            { Fl_RaiseButton* o = FlScanPbResetTable = new Fl_RaiseButton(610, 220, 20, 20);
              FlScanPbResetTable->tooltip(gettext("Reset Curve"));
              FlScanPbResetTable->box(FL_FLAT_BOX);
              FlScanPbResetTable->down_box(FL_THIN_DOWN_BOX);
              FlScanPbResetTable->color(FL_BACKGROUND_COLOR);
              FlScanPbResetTable->selection_color(FL_BACKGROUND_COLOR);
              FlScanPbResetTable->image( image_reset() );
              FlScanPbResetTable->labeltype(FL_NORMAL_LABEL);
              FlScanPbResetTable->labelfont(0);
              FlScanPbResetTable->labelsize(14);
              FlScanPbResetTable->labelcolor(FL_FOREGROUND_COLOR);
              FlScanPbResetTable->callback((Fl_Callback*)cb_FlScanPbResetTable);
              FlScanPbResetTable->align(Fl_Align(FL_ALIGN_CENTER));
              FlScanPbResetTable->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanPbResetTable
            { FlScanGroupTableType = new Fl_Group(465, 240, 165, 80);
              FlScanGroupTableType->box(FL_THIN_DOWN_BOX);
              { FlScanTableGammaCurve = new Fl_Curve(466, 241, 163, 78);
                FlScanTableGammaCurve->box(FL_FLAT_BOX);
                FlScanTableGammaCurve->color(FL_BACKGROUND2_COLOR);
                FlScanTableGammaCurve->selection_color(FL_BACKGROUND_COLOR);
                FlScanTableGammaCurve->labeltype(FL_NO_LABEL);
                FlScanTableGammaCurve->labelfont(0);
                FlScanTableGammaCurve->labelsize(14);
                FlScanTableGammaCurve->labelcolor(FL_FOREGROUND_COLOR);
                FlScanTableGammaCurve->callback((Fl_Callback*)cb_FlScanTableGammaCurve);
                FlScanTableGammaCurve->align(Fl_Align(FL_ALIGN_CENTER));
                FlScanTableGammaCurve->when(FL_WHEN_CHANGED);
              } // Fl_Curve* FlScanTableGammaCurve
              FlScanGroupTableType->end();
            } // Fl_Group* FlScanGroupTableType
            FlScanTableGroup->end();
          } // Fl_Group* FlScanTableGroup
          { FlScanOutputResolutions = new Fl_Group(461, 220, 173, 129);
            FlScanOutputResolutions->box(FL_FLAT_BOX);
            FlScanOutputResolutions->labeltype(FL_NO_LABEL);
            FlScanOutputResolutions->hide();
            { Fl_Browser* o = FlScanLsOutputGeometries = new Fl_Browser(465, 220, 165, 105, gettext("Output Image will..."));
              FlScanLsOutputGeometries->tooltip(gettext("Select the geometries of the output image files"));
              FlScanLsOutputGeometries->type(3);
              FlScanLsOutputGeometries->box(FL_THIN_DOWN_BOX);
              FlScanLsOutputGeometries->labeltype(FL_NO_LABEL);
              FlScanLsOutputGeometries->labelsize(12);
              FlScanLsOutputGeometries->align(Fl_Align(FL_ALIGN_TOP_LEFT));
              FlScanFillInGeometries(o);
            } // Fl_Browser* FlScanLsOutputGeometries
            { Fl_Sorted_Choice* o = FlScanOmZoomFilter = new Fl_Sorted_Choice(505, 325, 125, 20, gettext("Filter"));
              FlScanOmZoomFilter->box(FL_ENGRAVED_BOX);
              FlScanOmZoomFilter->down_box(FL_BORDER_BOX);
              FlScanOmZoomFilter->color(FL_BACKGROUND_COLOR);
              FlScanOmZoomFilter->selection_color(FL_SELECTION_COLOR);
              FlScanOmZoomFilter->labeltype(FL_NORMAL_LABEL);
              FlScanOmZoomFilter->labelfont(0);
              FlScanOmZoomFilter->labelsize(12);
              FlScanOmZoomFilter->labelcolor(FL_FOREGROUND_COLOR);
              FlScanOmZoomFilter->textsize(12);
              FlScanOmZoomFilter->align(Fl_Align(FL_ALIGN_LEFT));
              FlScanOmZoomFilter->when(FL_WHEN_RELEASE);
              if (!menu_FlScanOmZoomFilter_i18n_done) {
                int i=0;
                for ( ; i<15; i++)
                  if (menu_FlScanOmZoomFilter[i].label())
                    menu_FlScanOmZoomFilter[i].label(gettext(menu_FlScanOmZoomFilter[i].label()));
                menu_FlScanOmZoomFilter_i18n_done = 1;
              }
              FlScanOmZoomFilter->menu(menu_FlScanOmZoomFilter);
              o->value(1);
              FlScanZoomFilter=Image_Stream::BOX_FILTER;
            } // Fl_Sorted_Choice* FlScanOmZoomFilter
            FlScanOutputResolutions->end();
          } // Fl_Group* FlScanOutputResolutions
          { FlScanHistogram = new Fl_Group(461, 220, 173, 129);
            FlScanHistogram->tooltip(gettext("Histogram"));
            FlScanHistogram->box(FL_FLAT_BOX);
            FlScanHistogram->labeltype(FL_NO_LABEL);
            FlScanHistogram->hide();
            { FlScanHistogramPbIntensity = new Fl_Button(475, 330, 15, 15, gettext("I"));
              FlScanHistogramPbIntensity->tooltip(gettext("Toggle Intensity"));
              FlScanHistogramPbIntensity->box(FL_BORDER_BOX);
              FlScanHistogramPbIntensity->color(FL_FOREGROUND_COLOR);
              FlScanHistogramPbIntensity->selection_color(FL_FOREGROUND_COLOR);
              FlScanHistogramPbIntensity->labelfont(1);
              FlScanHistogramPbIntensity->labelsize(12);
              FlScanHistogramPbIntensity->labelcolor(FL_BACKGROUND2_COLOR);
              FlScanHistogramPbIntensity->callback((Fl_Callback*)cb_FlScanHistogramPbIntensity);
              FlScanHistogramPbIntensity->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Button* FlScanHistogramPbIntensity
            { FlScanHistogramPbRed = new Fl_Button(510, 330, 15, 15, gettext("R"));
              FlScanHistogramPbRed->tooltip(gettext("Toggle Red"));
              FlScanHistogramPbRed->box(FL_BORDER_BOX);
              FlScanHistogramPbRed->color((Fl_Color)1);
              FlScanHistogramPbRed->selection_color((Fl_Color)1);
              FlScanHistogramPbRed->labelfont(1);
              FlScanHistogramPbRed->labelsize(12);
              FlScanHistogramPbRed->labelcolor(FL_BACKGROUND2_COLOR);
              FlScanHistogramPbRed->callback((Fl_Callback*)cb_FlScanHistogramPbRed);
              FlScanHistogramPbRed->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Button* FlScanHistogramPbRed
            { FlScanHistogramPbBlue = new Fl_Button(560, 330, 15, 15, gettext("B"));
              FlScanHistogramPbBlue->tooltip(gettext("Toggle Blue"));
              FlScanHistogramPbBlue->box(FL_BORDER_BOX);
              FlScanHistogramPbBlue->color((Fl_Color)4);
              FlScanHistogramPbBlue->selection_color((Fl_Color)4);
              FlScanHistogramPbBlue->labelfont(1);
              FlScanHistogramPbBlue->labelsize(12);
              FlScanHistogramPbBlue->labelcolor(FL_BACKGROUND2_COLOR);
              FlScanHistogramPbBlue->callback((Fl_Callback*)cb_FlScanHistogramPbBlue);
              FlScanHistogramPbBlue->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Button* FlScanHistogramPbBlue
            { FlScanHistogramPbGreen = new Fl_Button(535, 330, 15, 15, gettext("G"));
              FlScanHistogramPbGreen->tooltip(gettext("Toggle Green"));
              FlScanHistogramPbGreen->box(FL_BORDER_BOX);
              FlScanHistogramPbGreen->color((Fl_Color)2);
              FlScanHistogramPbGreen->selection_color((Fl_Color)2);
              FlScanHistogramPbGreen->labelfont(1);
              FlScanHistogramPbGreen->labelsize(12);
              FlScanHistogramPbGreen->callback((Fl_Callback*)cb_FlScanHistogramPbGreen);
              FlScanHistogramPbGreen->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Button* FlScanHistogramPbGreen
            { FlScanHistogramPbLog = new Fl_Button(615, 330, 15, 15, gettext("L"));
              FlScanHistogramPbLog->tooltip(gettext("Toggle Logarithmic Representation"));
              FlScanHistogramPbLog->box(FL_BORDER_BOX);
              FlScanHistogramPbLog->labelfont(1);
              FlScanHistogramPbLog->labelsize(12);
              FlScanHistogramPbLog->callback((Fl_Callback*)cb_FlScanHistogramPbLog);
              FlScanHistogramPbLog->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Button* FlScanHistogramPbLog
            { FlScanHistogramPbPixel = new Fl_Button(590, 330, 15, 15, gettext("P"));
              FlScanHistogramPbPixel->tooltip(gettext("Toggle Point Representation"));
              FlScanHistogramPbPixel->box(FL_BORDER_BOX);
              FlScanHistogramPbPixel->labelfont(1);
              FlScanHistogramPbPixel->labelsize(12);
              FlScanHistogramPbPixel->callback((Fl_Callback*)cb_FlScanHistogramPbPixel);
              FlScanHistogramPbPixel->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Button* FlScanHistogramPbPixel
            { FlScanHistogramCanvas = new Fl_Group(465, 220, 165, 110);
              FlScanHistogramCanvas->box(FL_THIN_DOWN_BOX);
              FlScanHistogramCanvas->color(FL_BACKGROUND2_COLOR);
              FlScanHistogramCanvas->labeltype(FL_NO_LABEL);
              FlScanHistogramCanvas->labelfont(1);
              FlScanHistogramCanvas->labelsize(12);
              FlScanHistogramCanvas->end();
            } // Fl_Group* FlScanHistogramCanvas
            { FlScanHistogramTgIntensity = new Fl_Light_Button(465, 330, 10, 15);
              FlScanHistogramTgIntensity->tooltip(gettext("Toggle Intensity"));
              FlScanHistogramTgIntensity->box(FL_NO_BOX);
              FlScanHistogramTgIntensity->color(FL_LIGHT1);
              FlScanHistogramTgIntensity->labeltype(FL_NO_LABEL);
              FlScanHistogramTgIntensity->labelfont(1);
              FlScanHistogramTgIntensity->labelsize(10);
              FlScanHistogramTgIntensity->callback((Fl_Callback*)cb_FlScanHistogramTgIntensity);
            } // Fl_Light_Button* FlScanHistogramTgIntensity
            { FlScanHistogramTgRed = new Fl_Light_Button(500, 330, 10, 15);
              FlScanHistogramTgRed->tooltip(gettext("Toggle Red"));
              FlScanHistogramTgRed->box(FL_NO_BOX);
              FlScanHistogramTgRed->color(FL_LIGHT1);
              FlScanHistogramTgRed->labeltype(FL_NO_LABEL);
              FlScanHistogramTgRed->labelfont(1);
              FlScanHistogramTgRed->labelsize(12);
              FlScanHistogramTgRed->callback((Fl_Callback*)cb_FlScanHistogramTgRed);
            } // Fl_Light_Button* FlScanHistogramTgRed
            { FlScanHistogramTgGreen = new Fl_Light_Button(525, 330, 10, 15);
              FlScanHistogramTgGreen->tooltip(gettext("Toggle Green"));
              FlScanHistogramTgGreen->box(FL_NO_BOX);
              FlScanHistogramTgGreen->color(FL_LIGHT1);
              FlScanHistogramTgGreen->labeltype(FL_NO_LABEL);
              FlScanHistogramTgGreen->labelfont(1);
              FlScanHistogramTgGreen->labelsize(10);
              FlScanHistogramTgGreen->callback((Fl_Callback*)cb_FlScanHistogramTgGreen);
            } // Fl_Light_Button* FlScanHistogramTgGreen
            { FlScanHistogramTgBlue = new Fl_Light_Button(550, 330, 10, 15);
              FlScanHistogramTgBlue->tooltip(gettext("Toggle Blue"));
              FlScanHistogramTgBlue->box(FL_NO_BOX);
              FlScanHistogramTgBlue->color(FL_LIGHT1);
              FlScanHistogramTgBlue->labeltype(FL_NO_LABEL);
              FlScanHistogramTgBlue->labelfont(1);
              FlScanHistogramTgBlue->labelsize(10);
              FlScanHistogramTgBlue->callback((Fl_Callback*)cb_FlScanHistogramTgBlue);
            } // Fl_Light_Button* FlScanHistogramTgBlue
            { FlScanHistogramTgPixel = new Fl_Light_Button(580, 330, 10, 15);
              FlScanHistogramTgPixel->tooltip(gettext("Toggle Point Representation"));
              FlScanHistogramTgPixel->box(FL_NO_BOX);
              FlScanHistogramTgPixel->color(FL_LIGHT1);
              FlScanHistogramTgPixel->labeltype(FL_NO_LABEL);
              FlScanHistogramTgPixel->labelfont(1);
              FlScanHistogramTgPixel->labelsize(10);
              FlScanHistogramTgPixel->callback((Fl_Callback*)cb_FlScanHistogramTgPixel);
            } // Fl_Light_Button* FlScanHistogramTgPixel
            { FlScanHistogramTgLog = new Fl_Light_Button(605, 330, 10, 15);
              FlScanHistogramTgLog->tooltip(gettext("Toggle Logarithmic Representation"));
              FlScanHistogramTgLog->box(FL_NO_BOX);
              FlScanHistogramTgLog->color(FL_LIGHT1);
              FlScanHistogramTgLog->labeltype(FL_NO_LABEL);
              FlScanHistogramTgLog->labelfont(1);
              FlScanHistogramTgLog->labelsize(10);
              FlScanHistogramTgLog->callback((Fl_Callback*)cb_FlScanHistogramTgLog);
            } // Fl_Light_Button* FlScanHistogramTgLog
            FlScanHistogram->end();
          } // Fl_Group* FlScanHistogram
          { FlScanSetupJPEG = new Fl_Group(461, 220, 173, 129);
            FlScanSetupJPEG->box(FL_FLAT_BOX);
            FlScanSetupJPEG->labeltype(FL_NO_LABEL);
            FlScanSetupJPEG->hide();
            { FlScanFFmtTxQltJPEG = new Fl_Int_Input(465, 235, 35, 15, gettext("JPEG image quality:"));
              FlScanFFmtTxQltJPEG->tooltip(gettext("Quality in percent of the JPEG compressed file"));
              FlScanFFmtTxQltJPEG->type(2);
              FlScanFFmtTxQltJPEG->box(FL_THIN_DOWN_BOX);
              FlScanFFmtTxQltJPEG->labelsize(12);
              FlScanFFmtTxQltJPEG->textsize(12);
              FlScanFFmtTxQltJPEG->callback((Fl_Callback*)cb_FlScanFFmtTxQltJPEG);
              FlScanFFmtTxQltJPEG->align(Fl_Align(FL_ALIGN_TOP_LEFT));
              FlScanFFmtTxQltJPEG->when(FL_WHEN_CHANGED);
            } // Fl_Int_Input* FlScanFFmtTxQltJPEG
            { FlScanFFmtSlQltJPEG = new Fl_Slider(500, 235, 130, 15);
              FlScanFFmtSlQltJPEG->tooltip(gettext("Quality in percent of the JPEG compressed file"));
              FlScanFFmtSlQltJPEG->type(5);
              FlScanFFmtSlQltJPEG->box(FL_THIN_DOWN_BOX);
              FlScanFFmtSlQltJPEG->labeltype(FL_NO_LABEL);
              FlScanFFmtSlQltJPEG->labelfont(1);
              FlScanFFmtSlQltJPEG->maximum(100);
              FlScanFFmtSlQltJPEG->step(1);
              FlScanFFmtSlQltJPEG->value(100);
              FlScanFFmtSlQltJPEG->callback((Fl_Callback*)cb_FlScanFFmtSlQltJPEG);
              FlScanSliderGlue(FlScanFFmtSlQltJPEG,FlScanFFmtTxQltJPEG,SLIDER_TO_TEXT);
            } // Fl_Slider* FlScanFFmtSlQltJPEG
            { FlScanFFmtTxSmtJPEG = new Fl_Int_Input(465, 270, 35, 15, gettext("JPEG smoothing factor:"));
              FlScanFFmtTxSmtJPEG->tooltip(gettext("Smoothing factor in percent of the JPEG compressed file"));
              FlScanFFmtTxSmtJPEG->type(2);
              FlScanFFmtTxSmtJPEG->box(FL_THIN_DOWN_BOX);
              FlScanFFmtTxSmtJPEG->labelsize(12);
              FlScanFFmtTxSmtJPEG->textsize(12);
              FlScanFFmtTxSmtJPEG->callback((Fl_Callback*)cb_FlScanFFmtTxSmtJPEG);
              FlScanFFmtTxSmtJPEG->align(Fl_Align(FL_ALIGN_TOP_LEFT));
              FlScanFFmtTxSmtJPEG->when(FL_WHEN_CHANGED);
            } // Fl_Int_Input* FlScanFFmtTxSmtJPEG
            { FlScanFFmtSlSmtJPEG = new Fl_Slider(500, 270, 130, 15);
              FlScanFFmtSlSmtJPEG->tooltip(gettext("Smoothing factor in percent of the JPEG compressed file"));
              FlScanFFmtSlSmtJPEG->type(5);
              FlScanFFmtSlSmtJPEG->box(FL_THIN_DOWN_BOX);
              FlScanFFmtSlSmtJPEG->labeltype(FL_NO_LABEL);
              FlScanFFmtSlSmtJPEG->labelfont(1);
              FlScanFFmtSlSmtJPEG->maximum(100);
              FlScanFFmtSlSmtJPEG->step(1);
              FlScanFFmtSlSmtJPEG->callback((Fl_Callback*)cb_FlScanFFmtSlSmtJPEG);
              FlScanSliderGlue(FlScanFFmtSlSmtJPEG,FlScanFFmtTxSmtJPEG,SLIDER_TO_TEXT);
            } // Fl_Slider* FlScanFFmtSlSmtJPEG
            { FlScanFFmtTbOptJPEG = new Fl_Light_Button(465, 288, 165, 20, gettext("JPEG optimization"));
              FlScanFFmtTbOptJPEG->tooltip(gettext("Enable/disable JPEG encoding optimization"));
              FlScanFFmtTbOptJPEG->box(FL_NO_BOX);
              FlScanFFmtTbOptJPEG->value(1);
              FlScanFFmtTbOptJPEG->labelsize(12);
              FlScanFFmtTbOptJPEG->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Light_Button* FlScanFFmtTbOptJPEG
            { FlScanLbJPEGSeparator = new Fl_Box(465, 310, 165, 2);
              FlScanLbJPEGSeparator->box(FL_THIN_DOWN_FRAME);
              FlScanLbJPEGSeparator->labeltype(FL_NO_LABEL);
            } // Fl_Box* FlScanLbJPEGSeparator
            { FlScanFFmtTxCompressionPNG = new Fl_Int_Input(465, 330, 35, 15, gettext("PNG compression:"));
              FlScanFFmtTxCompressionPNG->tooltip(gettext("Compression factor [1-9] of the PNG compressed file"));
              FlScanFFmtTxCompressionPNG->type(2);
              FlScanFFmtTxCompressionPNG->box(FL_THIN_DOWN_BOX);
              FlScanFFmtTxCompressionPNG->labelsize(12);
              FlScanFFmtTxCompressionPNG->textsize(12);
              FlScanFFmtTxCompressionPNG->callback((Fl_Callback*)cb_FlScanFFmtTxCompressionPNG);
              FlScanFFmtTxCompressionPNG->align(Fl_Align(FL_ALIGN_TOP_LEFT));
              FlScanFFmtTxCompressionPNG->when(FL_WHEN_CHANGED);
            } // Fl_Int_Input* FlScanFFmtTxCompressionPNG
            { FlScanFFmtSlCompressionPNG = new Fl_Slider(500, 330, 130, 15);
              FlScanFFmtSlCompressionPNG->tooltip(gettext("Compression factor [1-9] of the PNG compressed file"));
              FlScanFFmtSlCompressionPNG->type(5);
              FlScanFFmtSlCompressionPNG->box(FL_THIN_DOWN_BOX);
              FlScanFFmtSlCompressionPNG->labeltype(FL_NO_LABEL);
              FlScanFFmtSlCompressionPNG->labelfont(1);
              FlScanFFmtSlCompressionPNG->minimum(1);
              FlScanFFmtSlCompressionPNG->maximum(9);
              FlScanFFmtSlCompressionPNG->step(1);
              FlScanFFmtSlCompressionPNG->value(9);
              FlScanFFmtSlCompressionPNG->callback((Fl_Callback*)cb_FlScanFFmtSlCompressionPNG);
              FlScanSliderGlue(FlScanFFmtSlCompressionPNG,FlScanFFmtTxCompressionPNG,SLIDER_TO_TEXT);
            } // Fl_Slider* FlScanFFmtSlCompressionPNG
            FlScanSetupJPEG->end();
          } // Fl_Group* FlScanSetupJPEG
          { FlScanSaneLogo = new Fl_Group(460, 205, 175, 145);
            FlScanSaneLogo->box(FL_THIN_DOWN_BOX);
            FlScanSaneLogo->image( image_sane() );
            FlScanSaneLogo->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
            { Fl_Box* o = new Fl_Box(465, 210, 165, 65, gettext("FlScan 1.0.2"));
              o->labeltype(FL_SHADOW_LABEL);
              o->labelfont(1);
              o->labelsize(24);
              o->labelcolor((Fl_Color)3);
            } // Fl_Box* o
            { Fl_Box* o = new Fl_Box(465, 310, 165, 20, gettext("\251""2001-2003 by"));
              o->labeltype(FL_SHADOW_LABEL);
              o->labelfont(1);
              o->labelcolor((Fl_Color)3);
              o->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            } // Fl_Box* o
            { Fl_Box* o = new Fl_Box(461, 329, 173, 20, gettext("Francesco Bradascio"));
              o->labeltype(FL_SHADOW_LABEL);
              o->labelfont(1);
              o->labelcolor((Fl_Color)3);
              o->align(Fl_Align(FL_ALIGN_WRAP));
            } // Fl_Box* o
            { showCopyright = new Fl_Button(461, 206, 173, 143);
              showCopyright->tooltip(gettext("Show Copyright ..."));
              showCopyright->box(FL_NO_BOX);
              showCopyright->labeltype(FL_NO_LABEL);
              showCopyright->labelfont(1);
              showCopyright->labelcolor(FL_BACKGROUND2_COLOR);
              showCopyright->callback((Fl_Callback*)cb_showCopyright);
              showCopyright->align(Fl_Align(194|FL_ALIGN_INSIDE));
            } // Fl_Button* showCopyright
            FlScanSaneLogo->end();
          } // Fl_Group* FlScanSaneLogo
          FlScanSetOption->end();
        } // Fl_Group* FlScanSetOption
        { FlScanImageSelector = new Fl_Group(460, 5, 175, 445);
          FlScanImageSelector->box(FL_THIN_DOWN_BOX);
          FlScanImageSelector->hide();
          { FileBrowser* o = FlScanFileBrowser = new FileBrowser(460, 5, 175, 445);
            FlScanFileBrowser->type(1);
            FlScanFileBrowser->box(FL_THIN_DOWN_BOX);
            FlScanFileBrowser->color(FL_BACKGROUND2_COLOR);
            FlScanFileBrowser->selection_color(FL_SELECTION_COLOR);
            FlScanFileBrowser->labeltype(FL_NO_LABEL);
            FlScanFileBrowser->labelfont(0);
            FlScanFileBrowser->labelsize(14);
            FlScanFileBrowser->labelcolor(FL_FOREGROUND_COLOR);
            FlScanFileBrowser->callback((Fl_Callback*)cb_FlScanFileBrowser);
            FlScanFileBrowser->align(Fl_Align(FL_ALIGN_BOTTOM));
            FlScanFileBrowser->when(FL_WHEN_RELEASE_ALWAYS);
            o->filter("*.{png|jpeg|jpg}");
            o->load(".");
          } // FileBrowser* FlScanFileBrowser
          FlScanImageSelector->end();
        } // Fl_Group* FlScanImageSelector
        { FlScanProgressBar = new Fl_Progress(460, 455, 175, 20);
          FlScanProgressBar->box(FL_THIN_DOWN_BOX);
          FlScanProgressBar->color(FL_BACKGROUND_COLOR);
          FlScanProgressBar->selection_color((Fl_Color)3);
        } // Fl_Progress* FlScanProgressBar
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(0, 0, 455, 480);
        o->box(FL_FLAT_BOX);
        { FlScanTabs = new Fl_Tabs(5, 0, 450, 475);
          FlScanTabs->callback((Fl_Callback*)cb_FlScanTabs);
          { FlScanTabThumbnails = new Fl_Group(5, 25, 450, 450);
            FlScanTabThumbnails->tooltip(gettext("Thumbnails"));
            FlScanTabThumbnails->box(FL_UP_BOX);
            FlScanTabThumbnails->image( image_Thumbnails() );
            FlScanTabThumbnails->labelfont(1);
            FlScanTabThumbnails->labelsize(12);
            FlScanTabThumbnails->hide();
            FlScanTabThumbnails->deactivate();
            { Fl_Scroll* o = new Fl_Scroll(10, 30, 440, 424);
              o->type(6);
              o->box(FL_DOWN_BOX);
              o->color(FL_BACKGROUND2_COLOR);
              o->labeltype(FL_NO_LABEL);
              o->align(Fl_Align(FL_ALIGN_CENTER));
              o->hide();
              { FlScanThumbsRows = new Fl_Pack(12, 32, 420, 420);
                { Fl_Pack* o = new Fl_Pack(12, 32, 420, 140);
                o->type(1);
                { Fl_Group* o = new Fl_Group(12, 32, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(20, 55, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(152, 32, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(160, 56, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(292, 32, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(300, 56, 123, 90);
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelsize(12);
                o->align(Fl_Align(FL_ALIGN_BOTTOM));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Pack* o
                { Fl_Pack* o = new Fl_Pack(12, 172, 420, 140);
                o->type(1);
                { Fl_Group* o = new Fl_Group(12, 172, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(20, 195, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(152, 172, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(160, 195, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(292, 172, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(300, 195, 123, 90);
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelsize(12);
                o->align(Fl_Align(FL_ALIGN_BOTTOM));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Pack* o
                { Fl_Pack* o = new Fl_Pack(12, 312, 420, 140);
                o->type(1);
                { Fl_Group* o = new Fl_Group(12, 312, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(20, 335, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(152, 312, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(160, 335, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(292, 312, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                { Fl_Group* o = new Fl_Group(300, 335, 123, 90);
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                o->labelsize(12);
                o->align(Fl_Align(FL_ALIGN_BOTTOM));
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Pack* o
                FlScanThumbsRows->end();
                Fl_Group::current()->resizable(FlScanThumbsRows);
              } // Fl_Pack* FlScanThumbsRows
              o->end();
            } // Fl_Scroll* o
            { Fl_Scroll* o = new Fl_Scroll(10, 30, 440, 424);
              o->type(6);
              o->box(FL_DOWN_BOX);
              o->color(FL_BACKGROUND2_COLOR);
              o->labeltype(FL_NO_LABEL);
              o->align(Fl_Align(FL_ALIGN_CENTER));
              o->hide();
              { Fl_Group* o = new Fl_Group(12, 32, 420, 420);
                o->color(FL_BACKGROUND2_COLOR);
                { Fl_Group* o = new Fl_Group(12, 32, 210, 210);
                o->box(FL_UP_BOX);
                { Fl_Group* o = new Fl_Group(42, 88, 150, 100);
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(12, 242, 210, 210);
                o->box(FL_UP_BOX);
                { Fl_Group* o = new Fl_Group(42, 297, 150, 100);
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(222, 242, 210, 210);
                o->box(FL_UP_BOX);
                { Fl_Group* o = new Fl_Group(252, 297, 150, 100);
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(222, 32, 210, 210);
                o->box(FL_UP_BOX);
                { Fl_Group* o = new Fl_Group(252, 88, 150, 100);
                o->box(FL_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->end();
                } // Fl_Group* o
                o->end();
                } // Fl_Group* o
                { Fl_Button* o = new Fl_Button(17, 37, 200, 200, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(17, 247, 200, 200, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(227, 247, 200, 200, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(227, 37, 200, 200, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                o->end();
                Fl_Group::current()->resizable(o);
              } // Fl_Group* o
              o->end();
            } // Fl_Scroll* o
            { Fl_Box* o = new Fl_Box(10, 455, 440, 15, gettext("Foto 1/6"));
              o->box(FL_THIN_DOWN_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->align(Fl_Align(FL_ALIGN_BOTTOM|FL_ALIGN_INSIDE));
            } // Fl_Box* o
            { Fl_Group* o = new Fl_Group(10, 30, 440, 424);
              o->box(FL_DOWN_BOX);
              o->color(FL_BACKGROUND2_COLOR);
              { Fl_Group* o = new Fl_Group(10, 31, 422, 421);
                { Fl_Group* o = new Fl_Group(12, 32, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(29, 67, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(31, 69, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(152, 32, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(169, 67, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(171, 69, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(292, 32, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(309, 67, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(311, 69, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(12, 172, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(29, 207, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(31, 209, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(152, 172, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(169, 207, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(171, 209, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(292, 172, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(309, 207, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(311, 209, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(12, 312, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(29, 347, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(31, 349, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(152, 312, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(169, 347, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(171, 349, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Group* o = new Fl_Group(292, 312, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(309, 347, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                { Fl_Box* o = new Fl_Box(311, 349, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_NO_LABEL);
                } // Fl_Box* o
                o->end();
                } // Fl_Group* o
                { Fl_Button* o = new Fl_Button(17, 37, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(17, 177, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(17, 317, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(157, 37, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(157, 177, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(157, 317, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(297, 37, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(297, 177, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                { Fl_Button* o = new Fl_Button(297, 317, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(FL_FOREGROUND_COLOR);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(FL_BACKGROUND2_COLOR);
                o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
                } // Fl_Button* o
                o->end();
                Fl_Group::current()->resizable(o);
              } // Fl_Group* o
              { Fl_Slider* o = new Fl_Slider(432, 32, 16, 420);
                o->type(4);
                o->box(FL_FLAT_BOX);
                o->color(FL_DARK2);
                o->minimum(1);
                o->maximum(5);
                o->step(1);
                o->slider_size(0.2);
              } // Fl_Slider* o
              o->end();
              Fl_Group::current()->resizable(o);
            } // Fl_Group* o
            FlScanTabThumbnails->end();
          } // Fl_Group* FlScanTabThumbnails
          { FlScanTabPreview = new Fl_Group(5, 25, 450, 450);
            FlScanTabPreview->tooltip(gettext("Image Previewer"));
            FlScanTabPreview->box(FL_THIN_UP_BOX);
            FlScanTabPreview->image( image_Preview() );
            FlScanTabPreview->labelfont(1);
            FlScanTabPreview->labelsize(12);
            FlScanTabPreview->hide();
            { Fl_Group* o = new Fl_Group(10, 30, 440, 440);
              o->box(FL_DOWN_BOX);
              o->color(FL_BACKGROUND2_COLOR);
              o->labeltype(FL_NO_LABEL);
              { FlScanPreviewArea = new Fl_Image_Preview(12, 32, 436, 436);
                FlScanPreviewArea->box(FL_FLAT_BOX);
                FlScanPreviewArea->color(FL_BACKGROUND2_COLOR);
                FlScanPreviewArea->selection_color(FL_BACKGROUND_COLOR);
                FlScanPreviewArea->labeltype(FL_NO_LABEL);
                FlScanPreviewArea->labelfont(0);
                FlScanPreviewArea->labelsize(14);
                FlScanPreviewArea->labelcolor(FL_FOREGROUND_COLOR);
                FlScanPreviewArea->callback((Fl_Callback*)cb_FlScanPreviewArea);
                FlScanPreviewArea->align(Fl_Align(FL_ALIGN_CENTER));
                FlScanPreviewArea->when(FL_WHEN_CHANGED);
              } // Fl_Image_Preview* FlScanPreviewArea
              o->end();
              Fl_Group::current()->resizable(o);
            } // Fl_Group* o
            FlScanTabPreview->end();
          } // Fl_Group* FlScanTabPreview
          { FlScanTabConversion = new Fl_Group(5, 25, 450, 450);
            FlScanTabConversion->tooltip(gettext("Conversions Status"));
            FlScanTabConversion->box(FL_THIN_UP_BOX);
            FlScanTabConversion->image( image_file() );
            FlScanTabConversion->labelfont(1);
            FlScanTabConversion->labelsize(12);
            FlScanTabConversion->hide();
            { FlScanConversionArea = new Conversions_List(10, 30, 440, 440, gettext("Conversions In Progress"));
              FlScanConversionArea->box(FL_DOWN_BOX);
              FlScanConversionArea->color(FL_BACKGROUND2_COLOR);
              FlScanConversionArea->selection_color(FL_BACKGROUND_COLOR);
              FlScanConversionArea->labeltype(FL_NO_LABEL);
              FlScanConversionArea->labelfont(0);
              FlScanConversionArea->labelsize(14);
              FlScanConversionArea->labelcolor(FL_FOREGROUND_COLOR);
              FlScanConversionArea->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
              FlScanConversionArea->when(FL_WHEN_CHANGED);
              Fl_Group::current()->resizable(FlScanConversionArea);
            } // Conversions_List* FlScanConversionArea
            FlScanTabConversion->end();
            Fl_Group::current()->resizable(FlScanTabConversion);
          } // Fl_Group* FlScanTabConversion
          { FlScanTabView = new Fl_Group(5, 25, 450, 450);
            FlScanTabView->tooltip(gettext("Image Viewer"));
            FlScanTabView->box(FL_THIN_UP_BOX);
            FlScanTabView->image( image_Acquire() );
            FlScanTabView->labelfont(1);
            FlScanTabView->labelsize(12);
            { FlScanSwViewArea = new Fl_Scrolled_Image(10, 30, 440, 440);
              FlScanSwViewArea->box(FL_DOWN_BOX);
              FlScanSwViewArea->color(FL_BACKGROUND2_COLOR);
              FlScanSwViewArea->selection_color(FL_BACKGROUND_COLOR);
              FlScanSwViewArea->labeltype(FL_NO_LABEL);
              FlScanSwViewArea->labelfont(0);
              FlScanSwViewArea->labelsize(14);
              FlScanSwViewArea->labelcolor(FL_FOREGROUND_COLOR);
              FlScanSwViewArea->align(Fl_Align(FL_ALIGN_TOP));
              FlScanSwViewArea->when(FL_WHEN_RELEASE);
              { FlScanViewArea = new Fl_Image_View(12, 32, 436, 436);
                FlScanViewArea->box(FL_FLAT_BOX);
                FlScanViewArea->color(FL_BACKGROUND2_COLOR);
                FlScanViewArea->selection_color(FL_BACKGROUND_COLOR);
                FlScanViewArea->labeltype(FL_NO_LABEL);
                FlScanViewArea->labelfont(0);
                FlScanViewArea->labelsize(14);
                FlScanViewArea->labelcolor(FL_FOREGROUND_COLOR);
                FlScanViewArea->align(Fl_Align(FL_ALIGN_CENTER));
                FlScanViewArea->when(FL_WHEN_CHANGED);
              } // Fl_Image_View* FlScanViewArea
              FlScanSwViewArea->end();
              Fl_Group::current()->resizable(FlScanSwViewArea);
            } // Fl_Scrolled_Image* FlScanSwViewArea
            FlScanTabView->end();
          } // Fl_Group* FlScanTabView
          FlScanTabs->end();
          Fl_Group::current()->resizable(FlScanTabs);
        } // Fl_Tabs* FlScanTabs
        { FlScanToolBar = new Fl_Group(130, 0, 325, 25);
          FlScanToolBar->box(FL_FLAT_BOX);
          { Fl_Box* o = new Fl_Box(130, 0, 2, 25);
            o->box(FL_THIN_DOWN_BOX);
            o->labeltype(FL_NO_LABEL);
          } // Fl_Box* o
          { FlScanPreviewTools = new Fl_Group(133, 0, 160, 25);
            { Fl_RaiseButton* o = FlScanThumbnailsRotateCCW = new Fl_RaiseButton(133, 0, 25, 25);
              FlScanThumbnailsRotateCCW->tooltip(gettext("Rotate Clockwise"));
              FlScanThumbnailsRotateCCW->box(FL_FLAT_BOX);
              FlScanThumbnailsRotateCCW->color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsRotateCCW->selection_color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsRotateCCW->image( image_rotate_cw90() );
              FlScanThumbnailsRotateCCW->labeltype(FL_NORMAL_LABEL);
              FlScanThumbnailsRotateCCW->labelfont(1);
              FlScanThumbnailsRotateCCW->labelsize(12);
              FlScanThumbnailsRotateCCW->labelcolor(FL_FOREGROUND_COLOR);
              FlScanThumbnailsRotateCCW->callback((Fl_Callback*)cb_FlScanThumbnailsRotateCCW);
              FlScanThumbnailsRotateCCW->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
              FlScanThumbnailsRotateCCW->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanThumbnailsRotateCCW
            { Fl_RaiseButton* o = FlScanThumbnailsRotateCW = new Fl_RaiseButton(158, 0, 25, 25);
              FlScanThumbnailsRotateCW->tooltip(gettext("Rotate Counter Clockwise"));
              FlScanThumbnailsRotateCW->box(FL_FLAT_BOX);
              FlScanThumbnailsRotateCW->color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsRotateCW->selection_color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsRotateCW->image( image_rotate_ccw90() );
              FlScanThumbnailsRotateCW->labeltype(FL_NORMAL_LABEL);
              FlScanThumbnailsRotateCW->labelfont(1);
              FlScanThumbnailsRotateCW->labelsize(12);
              FlScanThumbnailsRotateCW->labelcolor(FL_FOREGROUND_COLOR);
              FlScanThumbnailsRotateCW->callback((Fl_Callback*)cb_FlScanThumbnailsRotateCW);
              FlScanThumbnailsRotateCW->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
              FlScanThumbnailsRotateCW->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanThumbnailsRotateCW
            { Fl_RaiseButton* o = FlScanThumbnailsSetHorizont = new Fl_RaiseButton(183, 0, 25, 25);
              FlScanThumbnailsSetHorizont->tooltip(gettext("Set the horizont\nClick, drag the rubber line and release.\nThe image will be\
 rotaded by the closest\nangle of the rubber line near 0\260 or 90\260."));
              FlScanThumbnailsSetHorizont->type(1);
              FlScanThumbnailsSetHorizont->box(FL_FLAT_BOX);
              FlScanThumbnailsSetHorizont->down_box(FL_THIN_DOWN_BOX);
              FlScanThumbnailsSetHorizont->color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsSetHorizont->selection_color((Fl_Color)3);
              FlScanThumbnailsSetHorizont->image( image_set_horizont() );
              FlScanThumbnailsSetHorizont->labeltype(FL_NORMAL_LABEL);
              FlScanThumbnailsSetHorizont->labelfont(1);
              FlScanThumbnailsSetHorizont->labelsize(12);
              FlScanThumbnailsSetHorizont->labelcolor(FL_FOREGROUND_COLOR);
              FlScanThumbnailsSetHorizont->callback((Fl_Callback*)cb_FlScanThumbnailsSetHorizont);
              FlScanThumbnailsSetHorizont->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
              FlScanThumbnailsSetHorizont->when(FL_WHEN_CHANGED);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanThumbnailsSetHorizont
            { Fl_RaiseButton* o = FlScanThumbnailsUndoRotate = new Fl_RaiseButton(208, 0, 25, 25);
              FlScanThumbnailsUndoRotate->tooltip(gettext("Undo/Redo last rotation"));
              FlScanThumbnailsUndoRotate->box(FL_FLAT_BOX);
              FlScanThumbnailsUndoRotate->color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsUndoRotate->selection_color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsUndoRotate->image( image_undo_rotate() );
              FlScanThumbnailsUndoRotate->labeltype(FL_NORMAL_LABEL);
              FlScanThumbnailsUndoRotate->labelfont(1);
              FlScanThumbnailsUndoRotate->labelsize(12);
              FlScanThumbnailsUndoRotate->labelcolor(FL_FOREGROUND_COLOR);
              FlScanThumbnailsUndoRotate->callback((Fl_Callback*)cb_FlScanThumbnailsUndoRotate);
              FlScanThumbnailsUndoRotate->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
              FlScanThumbnailsUndoRotate->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanThumbnailsUndoRotate
            { Fl_Box* o = new Fl_Box(235, 0, 2, 25);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
            } // Fl_Box* o
            { Fl_RaiseButton* o = FlScanThumbnailsHorizontalMirror = new Fl_RaiseButton(238, 0, 25, 25);
              FlScanThumbnailsHorizontalMirror->tooltip(gettext("Flip Horizontal"));
              FlScanThumbnailsHorizontalMirror->box(FL_FLAT_BOX);
              FlScanThumbnailsHorizontalMirror->color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsHorizontalMirror->selection_color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsHorizontalMirror->image( image_horizontal_mirror() );
              FlScanThumbnailsHorizontalMirror->labeltype(FL_NORMAL_LABEL);
              FlScanThumbnailsHorizontalMirror->labelfont(1);
              FlScanThumbnailsHorizontalMirror->labelsize(12);
              FlScanThumbnailsHorizontalMirror->labelcolor(FL_FOREGROUND_COLOR);
              FlScanThumbnailsHorizontalMirror->callback((Fl_Callback*)cb_FlScanThumbnailsHorizontalMirror);
              FlScanThumbnailsHorizontalMirror->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
              FlScanThumbnailsHorizontalMirror->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanThumbnailsHorizontalMirror
            { Fl_RaiseButton* o = FlScanThumbnailsVerticalMirror = new Fl_RaiseButton(263, 0, 25, 25);
              FlScanThumbnailsVerticalMirror->tooltip(gettext("Flip Vertical"));
              FlScanThumbnailsVerticalMirror->box(FL_FLAT_BOX);
              FlScanThumbnailsVerticalMirror->color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsVerticalMirror->selection_color(FL_BACKGROUND_COLOR);
              FlScanThumbnailsVerticalMirror->image( image_vertical_mirror() );
              FlScanThumbnailsVerticalMirror->labeltype(FL_NORMAL_LABEL);
              FlScanThumbnailsVerticalMirror->labelfont(1);
              FlScanThumbnailsVerticalMirror->labelsize(12);
              FlScanThumbnailsVerticalMirror->labelcolor(FL_FOREGROUND_COLOR);
              FlScanThumbnailsVerticalMirror->callback((Fl_Callback*)cb_FlScanThumbnailsVerticalMirror);
              FlScanThumbnailsVerticalMirror->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
              FlScanThumbnailsVerticalMirror->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            } // Fl_RaiseButton* FlScanThumbnailsVerticalMirror
            { Fl_Box* o = new Fl_Box(290, 0, 2, 25);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
            } // Fl_Box* o
            FlScanPreviewTools->end();
          } // Fl_Group* FlScanPreviewTools
          { Fl_Box* o = new Fl_Box(295, 0, 10, 25);
            o->labeltype(FL_NO_LABEL);
            Fl_Group::current()->resizable(o);
          } // Fl_Box* o
          { Fl_RaiseButton* o = FlScanPreviewZoomPlus = new Fl_RaiseButton(355, 0, 25, 25);
            FlScanPreviewZoomPlus->tooltip(gettext("Increase Window Size"));
            FlScanPreviewZoomPlus->box(FL_FLAT_BOX);
            FlScanPreviewZoomPlus->color(FL_BACKGROUND_COLOR);
            FlScanPreviewZoomPlus->selection_color(FL_BACKGROUND_COLOR);
            FlScanPreviewZoomPlus->image( image_zoom_in() );
            FlScanPreviewZoomPlus->labeltype(FL_NORMAL_LABEL);
            FlScanPreviewZoomPlus->labelfont(1);
            FlScanPreviewZoomPlus->labelsize(12);
            FlScanPreviewZoomPlus->labelcolor(FL_FOREGROUND_COLOR);
            FlScanPreviewZoomPlus->callback((Fl_Callback*)cb_FlScanPreviewZoomPlus);
            FlScanPreviewZoomPlus->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            FlScanPreviewZoomPlus->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          } // Fl_RaiseButton* FlScanPreviewZoomPlus
          { Fl_RaiseButton* o = FlScanPreviewZoomMinus = new Fl_RaiseButton(380, 0, 25, 25);
            FlScanPreviewZoomMinus->tooltip(gettext("Decrease Window Size"));
            FlScanPreviewZoomMinus->box(FL_FLAT_BOX);
            FlScanPreviewZoomMinus->color(FL_BACKGROUND_COLOR);
            FlScanPreviewZoomMinus->selection_color(FL_BACKGROUND_COLOR);
            FlScanPreviewZoomMinus->image( image_zoom_out() );
            FlScanPreviewZoomMinus->labeltype(FL_NORMAL_LABEL);
            FlScanPreviewZoomMinus->labelfont(1);
            FlScanPreviewZoomMinus->labelsize(12);
            FlScanPreviewZoomMinus->labelcolor(FL_FOREGROUND_COLOR);
            FlScanPreviewZoomMinus->callback((Fl_Callback*)cb_FlScanPreviewZoomMinus);
            FlScanPreviewZoomMinus->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            FlScanPreviewZoomMinus->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          } // Fl_RaiseButton* FlScanPreviewZoomMinus
          { Fl_RaiseButton* o = FlScanPreviewZoomScreen = new Fl_RaiseButton(405, 0, 25, 25);
            FlScanPreviewZoomScreen->tooltip(gettext("Fit Window Size to Screen Size"));
            FlScanPreviewZoomScreen->box(FL_FLAT_BOX);
            FlScanPreviewZoomScreen->color(FL_BACKGROUND_COLOR);
            FlScanPreviewZoomScreen->selection_color(FL_BACKGROUND_COLOR);
            FlScanPreviewZoomScreen->image( image_zoom_undo() );
            FlScanPreviewZoomScreen->labeltype(FL_NORMAL_LABEL);
            FlScanPreviewZoomScreen->labelfont(1);
            FlScanPreviewZoomScreen->labelsize(12);
            FlScanPreviewZoomScreen->labelcolor(FL_FOREGROUND_COLOR);
            FlScanPreviewZoomScreen->callback((Fl_Callback*)cb_FlScanPreviewZoomScreen);
            FlScanPreviewZoomScreen->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            FlScanPreviewZoomScreen->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          } // Fl_RaiseButton* FlScanPreviewZoomScreen
          { Fl_RaiseButton* o = FlScanPreviewZoomMinimize = new Fl_RaiseButton(430, 0, 25, 25);
            FlScanPreviewZoomMinimize->tooltip(gettext("Resize Window to Minimum Size"));
            FlScanPreviewZoomMinimize->box(FL_FLAT_BOX);
            FlScanPreviewZoomMinimize->color(FL_BACKGROUND_COLOR);
            FlScanPreviewZoomMinimize->selection_color(FL_BACKGROUND_COLOR);
            FlScanPreviewZoomMinimize->image( image_zoom_mini() );
            FlScanPreviewZoomMinimize->labeltype(FL_NORMAL_LABEL);
            FlScanPreviewZoomMinimize->labelfont(1);
            FlScanPreviewZoomMinimize->labelsize(12);
            FlScanPreviewZoomMinimize->labelcolor(FL_FOREGROUND_COLOR);
            FlScanPreviewZoomMinimize->callback((Fl_Callback*)cb_FlScanPreviewZoomMinimize);
            FlScanPreviewZoomMinimize->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
            FlScanPreviewZoomMinimize->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          } // Fl_RaiseButton* FlScanPreviewZoomMinimize
          FlScanToolBar->end();
        } // Fl_Group* FlScanToolBar
        { FlScanEeLockView = new EatEvent(5, 0, 125, 25);
          FlScanEeLockView->box(FL_NO_BOX);
          FlScanEeLockView->color(FL_BACKGROUND_COLOR);
          FlScanEeLockView->selection_color(FL_BACKGROUND_COLOR);
          FlScanEeLockView->labeltype(FL_NO_LABEL);
          FlScanEeLockView->labelfont(0);
          FlScanEeLockView->labelsize(14);
          FlScanEeLockView->labelcolor(FL_FOREGROUND_COLOR);
          FlScanEeLockView->align(Fl_Align(FL_ALIGN_CENTER));
          FlScanEeLockView->when(FL_WHEN_RELEASE);
          FlScanEeLockView->hide();
        } // EatEvent* FlScanEeLockView
        o->end();
        Fl_Group::current()->resizable(o);
      } // Fl_Group* o
      { FlScanEeWaitForSaving = new EatEvent(0, 0, 640, 480, gettext("Wait for Saving Completion"));
        FlScanEeWaitForSaving->box(FL_NO_BOX);
        FlScanEeWaitForSaving->color(FL_BACKGROUND_COLOR);
        FlScanEeWaitForSaving->selection_color(FL_BACKGROUND_COLOR);
        FlScanEeWaitForSaving->labeltype(FL_SHADOW_LABEL);
        FlScanEeWaitForSaving->labelfont(1);
        FlScanEeWaitForSaving->labelsize(30);
        FlScanEeWaitForSaving->labelcolor((Fl_Color)3);
        FlScanEeWaitForSaving->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
        FlScanEeWaitForSaving->when(FL_WHEN_RELEASE);
        FlScanEeWaitForSaving->hide();
      } // EatEvent* FlScanEeWaitForSaving
      FlScanContainer->end();
    } // Fl_Group* FlScanContainer
    o->size_range(640,480,640,480);
    copyrightWindow=make_copyright_window(copyrightText);
    Fl_RGB_Image rgb_sane((const Fl_Pixmap*)image_sane());o->icon(&rgb_sane);
    FlScan->set_modal();
    FlScan->end();
  } // Fl_Double_Window* FlScan
  if (!enable_scan) {
      FlScanTabThumbnails->deactivate();
      FlScanTabPreview->deactivate();
      FlScanTabConversion->deactivate();
      FlScanTabs->push(0);
      FlScanTabs->value(FlScanTabView);
      FlScanTabs->do_callback();
      FlScanSwViewArea->activate();
      FlScanEeLockView->set_visible();
  }
  lastOption=FlScanSaneLogo;
  update_tree();
  return FlScan;
}

void FlScanSetMode(int mode) {
  if (mode==FL_SCAN_SCAN_MODE) {
      FlScanImageSelector->hide();
      FlScanScannerOptions->show();
      FlScanSettings->show();
      FlScanSetOption->show();
      FlScanPreviewTools->show();
  } else {
      FlScanScannerOptions->hide();
      FlScanSettings->hide();
      FlScanSetOption->hide();
      FlScanPreviewTools->hide();
      FlScanImageSelector->show();
  }
}

void FlScanSliderGlue(Fl_Valuator *slider, Fl_Input *text,bool textToSlider) {
  double val, cval;
  char *ptr, str[256];
  
      if (text && slider) {
          if (textToSlider) {
              ptr=(char *)text->value();
              if (ptr) {
                  val = atof(ptr);
                  cval = slider->clamp(val);
                  slider->value(cval);
                  if (cval!=val) {
                      slider->format(str);
                      text->value((const char *)str);
                  }
              }
          } else {
              slider->format(str);
              text->value((const char *)str);
          }
      }
}

void FlScanResize(int how) {
  static int hh[] = { 530, 600, 768, 864, 1024 };
  static int res=0;
  static int maxres=-1;
  int reqres;
  int numres;
  
  numres=(sizeof(hh)/sizeof(int))-1;
  
  if (maxres<0) {
      if (Fl::h()<=hh[0]) {
          maxres=0;
      } else if (Fl::h()>=hh[numres]) {
          maxres=numres;
      } else {
          for (int i=0; i<numres; i++) {
              if (Fl::h()==hh[i]) {
                  maxres=i;
                  break;
              } else if (
                  Fl::h()>hh[i] &&
                  Fl::h()<hh[i+1]
              ) {
                  maxres=i;
                  break;
              }
          }
      }
  }
  if (how==DECREASE_SIZE && res>0) {
      reqres=res-1;
  } else if (how==INCREASE_SIZE && res<maxres) {
      reqres=res+1;
  } else if (how==FIT_TO_SCREEN) {
      reqres=maxres;
  } else {
      reqres=how;
  }
  if (reqres>=0) {
      reqres=(reqres<0)?0:(reqres>maxres)?maxres:reqres;
      if (reqres!=res) {
          res=reqres;
          FlScan->resize (
              FlScan->x(), FlScan->y(),
              hh[res]+110, hh[res]-50
          );
          FlScanContainer->resize(0,0,hh[res]+110,hh[res]-50);
          FlScanToolBar->resize(130,0,hh[res]-205,25);
          FlScanEeLockView->resize(5,0,125,26);
          FlScanEeWaitForSaving->resize(0,0,hh[res]+110,hh[res]-50);
      }
  }
}

void cb_selectoption(Fl_Widget *w, void *v) {
  size_t opt_num;
  Fl_Tree_Browser* tree = (Fl_Tree_Browser*)w;
  C_Sane_Option *opt;
  
      if (tree->selected()) {
          opt_num = (size_t)((Fl_Tree_Item*)(tree->selected()))->data();
  
          tree->redraw();
          Fl::flush();
  
          if (opt_num>0) {
              opt = sane->option(opt_num);
              if (opt && opt->descriptor()) {
                  if (opt_num != currentOption_num) {
                      currentOption_num = opt_num;
                      currentOption=opt;
                      FlScanSelOption();
                  }
              } else {
                  tree->deselect();
                  tree->redraw();
                  FlScanScannerOptions->damage(FL_DAMAGE_ALL);
                  FlScanScannerOptions->redraw();
                  Fl::flush();
              }
          } else if (opt_num<=0) { /* Other stuff */
              currentOption=(C_Sane_Option*)0;
              currentOption_num = opt_num;
              FlScanSelOption();
          }
      } else {
          currentOption=(C_Sane_Option*)0;
          currentOption_num = 0;
          FlScanSelOption();
      }
}

void update_tree() {
  int i;
  int x,y;
  int firstItem = 1;
  int rows = 0;
  Fl_Tree_Item *application = 0;
  Fl_Tree_Item *scanner = 0;
  Fl_Tree_Item *first = 0;
  Fl_Tree_Item *group = 0;
  Fl_Tree_Item *item = 0;
  
      preview_ndx=-1;
      tl_x_ndx=-1;
      tl_y_ndx=-1;
      br_x_ndx=-1;
      br_y_ndx=-1;
  
      FlScanScannerOptions->clear();
      FlScanScannerOptions->has_scrollbar(Fl_Browser_::BOTH);
      FlScanScannerOptions->draw_lines(false);
      FlScanScannerOptions->pixmap_offset(16);
      FlScanScannerOptions->label_offset(0);
      /*
       * fill tree
       */
      rows++;
      application = first = new Fl_Tree_Item (
          /* label     : */ "Application Settings",
          /* pixmap    : */ 0,
          /* tooltip   : */ 0,
          /* data      : */ 0,
          /* color     : */ FlScanScannerOptions->textcolor(),
          /* font      : */ FlScanScannerOptions->textfont()+1,
          /* font_size : */ FlScanScannerOptions->textsize(),
          /* can_open  : */ true,
          /* opened    : */ true,
          /* parent    : */ FlScanScannerOptions,
          /* father    : */ 0,
          /* prev      : */ 0,
          /* next      : */ 0
      );
          rows++;
          group = new Fl_Tree_Item (
              /* label     : */ "Output file resolutions",
              /* pixmap    : */ 0,
              /* tooltip   : */ 0,
              /* data      : */ (void*)FL_SCAN_OUTPUT_FILE_RESOLUTION,
              /* color     : */ FlScanScannerOptions->textcolor(),
              /* font      : */ FlScanScannerOptions->textfont(),
              /* font_size : */ FlScanScannerOptions->textsize(),
              /* can_open  : */ false,
              /* opened    : */ true,
              /* parent    : */ FlScanScannerOptions,
              /* father    : */ application,
              /* prev      : */ 0,
              /* next      : */ 0
          );
          rows++;
          group = new Fl_Tree_Item (
              /* label     : */ "Image Convertes Settings",
              /* pixmap    : */ 0,
              /* tooltip   : */ 0,
              /* data      : */ (void*)FL_SCAN_CONVERTERS_SETTINGS,
              /* color     : */ FlScanScannerOptions->textcolor(),
              /* font      : */ FlScanScannerOptions->textfont(),
              /* font_size : */ FlScanScannerOptions->textsize(),
              /* can_open  : */ false,
              /* opened    : */ true,
              /* parent    : */ FlScanScannerOptions,
              /* father    : */ application,
              /* prev      : */ group,
              /* next      : */ 0
          );
      rows++;
      scanner = new Fl_Tree_Item (
          /* label     : */ "Scanner Settings",
          /* pixmap    : */ 0,
          /* tooltip   : */ 0,
          /* data      : */ 0,
          /* color     : */ FlScanScannerOptions->textcolor(),
          /* font      : */ FlScanScannerOptions->textfont()+1,
          /* font_size : */ FlScanScannerOptions->textsize(),
          /* can_open  : */ true,
          /* opened    : */ true,
          /* parent    : */ FlScanScannerOptions,
          /* father    : */ 0,
          /* prev      : */ application,
          /* next      : */ 0
      );
      group = 0;
  #if 0
          rows++;
          group = new Fl_Tree_Item (
              /* label     : */ "Device Selection",
              /* pixmap    : */ 0,
              /* tooltip   : */ 0,
              /* data      : */ 0,
              /* color     : */ FlScanScannerOptions->textcolor(),
              /* font      : */ FlScanScannerOptions->textfont(),
              /* font_size : */ FlScanScannerOptions->textsize(),
              /* can_open  : */ false,
              /* opened    : */ true,
              /* parent    : */ FlScanScannerOptions,
              /* father    : */ scanner,
              /* prev      : */ 0,
              /* next      : */ 0
          );
              rows++;
              item = new Fl_Tree_Item (
                  /* label     : */ "Device",
                  /* pixmap    : */ 0,
                  /* tooltip   : */ 0,
                  /* data      : */ (void*)FL_SCAN_DEVICE_SELECTION,
                  /* color     : */ FlScanScannerOptions->textcolor(),
                  /* font      : */ FlScanScannerOptions->textfont(),
                  /* font_size : */ FlScanScannerOptions->textsize(),
                  /* can_open  : */ false,
                  /* opened    : */ true,
                  /* parent    : */ FlScanScannerOptions,
                  /* father    : */ group,
                  /* prev      : */ 0,
                  /* next      : */ 0
              );
  #endif
      C_Sane_Option *opt;
      for (i=1;i<sane->num_options() && (opt=sane->option(i));i++) {
          const SANE_Option_Descriptor *sod = opt->descriptor();
          if (sod && sod->title && strlen(sod->title)) {
              if (sod->type==SANE_TYPE_GROUP) {
                  if (!firstItem && !item && group) {
                      /*
                       * The previous group is empty, remove it
                       */
                      Fl_Tree_Item *prev = group->prev();
                      if (prev) {
                          prev->next(0);
                      }
                      Fl_Tree_Item *father = group->father();
                      if (father && father->childs() == group) {
                          father->childs(0);
                      }
                      group = prev;
                      rows--;
                  }
                  group = new Fl_Tree_Item (
                      /* label     : */ (char*)sod->title,
                      /* pixmap    : */ 0,
                      /* tooltip   : */ (char*)sod->desc,
                      /* data      : */ 0,
                      /* color     : */ FlScanScannerOptions->textcolor(),
                      /* font      : */ FlScanScannerOptions->textfont(),
                      /* font_size : */ FlScanScannerOptions->textsize(),
                      /* can_open  : */ false,
                      /* opened    : */ true,
                      /* parent    : */ FlScanScannerOptions,
                      /* father    : */ scanner,
                      /* prev      : */ group,
                      /* next      : */ 0
                  );
                  rows++;
                  item = 0;
  #if 0
              } else if (SANE_OPTION_IS_ACTIVE(sod->cap)) {
                  if (!strcmp(sod->name,SANE_NAME_PREVIEW)) {
                      preview_ndx=i;
                  } else if (!strcmp(sod->name,SANE_NAME_SCAN_TL_X)) {
                      tl_x_ndx=i;
                  } else if (!strcmp(sod->name,SANE_NAME_SCAN_TL_Y)) {
                      tl_y_ndx=i;
                  } else if (!strcmp(sod->name,SANE_NAME_SCAN_BR_X)) {
                      br_x_ndx=i;
                  } else if (!strcmp(sod->name,SANE_NAME_SCAN_BR_Y)) {
                      br_y_ndx=i;
                  } else {
                      item = new Fl_Tree_Item (
                          /* label     : */ (char*)sod->title,
                          /* pixmap    : */ 0,
                          /* tooltip   : */ (char*)sod->desc,
                          /* data      : */ (void*)opt->number(),
                          /* color     : */ FlScanScannerOptions->textcolor(),
                          /* font      : */ FlScanScannerOptions->textfont(),
                          /* font_size : */ FlScanScannerOptions->textsize(),
                          /* can_open  : */ false,
                          /* opened    : */ true,
                          /* parent    : */ FlScanScannerOptions,
                          /* father    : */ (group) ? group : scanner,
                          /* prev      : */ item,
                          /* next      : */ 0
                      );
                      firstItem = 0;
                      rows++;
                  }
  #else
              } else if (sod->title) {
                  if (!strcmp(sod->name,SANE_NAME_PREVIEW)) {
                      preview_ndx=i;
                  } else if (!strcmp(sod->name,SANE_NAME_SCAN_TL_X)) {
                      tl_x_ndx=i;
                  } else if (!strcmp(sod->name,SANE_NAME_SCAN_TL_Y)) {
                      tl_y_ndx=i;
                  } else if (!strcmp(sod->name,SANE_NAME_SCAN_BR_X)) {
                      br_x_ndx=i;
                  } else if (!strcmp(sod->name,SANE_NAME_SCAN_BR_Y)) {
                      br_y_ndx=i;
                  }
                  item = new Fl_Tree_Item (
                      /* label     : */ (char*)sod->title,
                      /* pixmap    : */ 0,
                      /* tooltip   : */ (char*)sod->desc,
                      /* data      : */ (void*)opt->number(),
                      /* color     : */ FlScanScannerOptions->textcolor(),
                      /* font      : */ FlScanScannerOptions->textfont(),
                      /* font_size : */ FlScanScannerOptions->textsize(),
                      /* can_open  : */ false,
                      /* opened    : */ true,
                      /* parent    : */ FlScanScannerOptions,
                      /* father    : */ (group) ? group : scanner,
                      /* prev      : */ item,
                      /* next      : */ 0
                  );
                  firstItem = 0;
                  rows++;
  #endif
              }
          }
      }
      FlScanScannerOptions->items(first);
      /*
       * Show the tree
       */
      FlScanScannerOptions->damage(FL_DAMAGE_ALL);
      FlScanScannerOptions->redraw();
      Fl::flush();
}

void FlScanSaneSetCB(bool automatic) {
  void *optval;
  bool to_be_freed=false;
  bool ok_to_set=false;
  double dval;
  SANE_Int val;
  const SANE_Option_Descriptor *sod;
  
      optval=0;
      if (currentOption) {
          /*
           * Get the value from the interface
           */
          sod = currentOption->descriptor();
          switch (sod->type) {
              case SANE_TYPE_BOOL:
                  if (
                      sod->size==sizeof(SANE_Word) &&
                      sod->constraint_type==SANE_CONSTRAINT_NONE
                  ) {
                      ok_to_set=true;
                      val=FlScanTbBoolType->value();
                      optval=(void*)&val;
                  }
                  break;
              case SANE_TYPE_INT:
                  if (sod->size==sizeof(SANE_Word)) {
                      switch (sod->constraint_type) {
                          case SANE_CONSTRAINT_NONE:
                              sscanf (
                                  FlScanTxIntType->value(),
                                  "%d",
                                  &val
                              );
                              ok_to_set=true;
                              optval=(void*)&val;
                              break;
                          case SANE_CONSTRAINT_RANGE:
                              ok_to_set=true;
                              val=(int)FlScanViRangeType->value();
                              optval=(void*)&val;
                              break;
                          case SANE_CONSTRAINT_WORD_LIST:
                              sscanf (
                                  FlScanMnListType->text (
                                      FlScanMnListType->value()
                                  ),
                                  "%d",
                                  &val
                              );
                              ok_to_set=true;
                              optval=(void*)&val;
                              break;
                           default:
                              break;
                      }
                  } else { /* table or array */
                      int size=sod->size/sizeof(SANE_Word);
                      double *vector=new double[size];
                      SANE_Int *ivect=new SANE_Int[size];
                      if (vector && ivect) {
                          FlScanTableGammaCurve->get_vector(size,vector);
                          for (int i=0;i<size;i++) {
                              ivect[i]=(int)vector[i];
                          }
                          to_be_freed=true;
                          ok_to_set=true;
                          optval=(void*)ivect;
                      }
                      if (vector) {
                          delete vector;
                      }
                  }
                  break;
              case SANE_TYPE_FIXED:
                  if (sod->size==sizeof(SANE_Word)) {
                      switch (sod->constraint_type) {
                          case SANE_CONSTRAINT_NONE:
                              sscanf (
                                  FlScanTxFixedType->value(),
                                  "%lf",
                                  &dval
                              );
                              val=(SANE_Int)SANE_FIX(dval);
                              ok_to_set=true;
                              optval=(void*)&val;
                              break;
                          case SANE_CONSTRAINT_RANGE:
                              val=(int)SANE_FIX(FlScanViRangeType->value());
                              ok_to_set=true;
                              optval=(void*)&val;
                              break;
                           default:
                              break;
                      }
                  } else { /* table or array */
                      int size=sod->size/sizeof(SANE_Word);
                      double *vector=new double[size];
                      SANE_Int *ivect=new SANE_Int[size];
                      if (vector && ivect) {
                          FlScanTableGammaCurve->get_vector(size,vector);
                          for (int i=0;i<size;i++) {
                              ivect[i]=(int)SANE_FIX(vector[i]);
                          }
                          to_be_freed=true;
                          ok_to_set=true;
                          optval=(void*)ivect;
                      }
                      if (vector) {
                          delete vector;
                      }
                  }
                  break;
              case SANE_TYPE_STRING:
                  switch (sod->constraint_type) {
                      case SANE_CONSTRAINT_NONE:
                          ok_to_set=true;
                          optval=(void*)FlScanTxStringType->value();
                          break;
                      case SANE_CONSTRAINT_STRING_LIST:
                          FlScanMnListType->value();
                          ok_to_set=true;
                          optval=(void*)FlScanMnListType->text (
                              FlScanMnListType->value()
                          );
                          break;
                      default:
                          break;
                  }
                  break;
              case SANE_TYPE_BUTTON:
                  ok_to_set=true;
                  optval=(void*)0;
                  break;
              default:
                  break;
          }
          /*
           * Set the SANE value
           */
          if (automatic) {
              currentOption->auto_value(optval);
          } else {
              currentOption->value(optval);
          }
          if (currentOption->status()==SANE_STATUS_GOOD) {
              if (currentOption->status()==SANE_INFO_RELOAD_OPTIONS) {
                  update_tree();
              }
  #if 0
              if (currentOption->status()==SANE_INFO_RELOAD_PARAMS) {
                  get_params(sane);
              }
  #endif
              if (currentOption->status()==SANE_INFO_INEXACT) {
  //                fprintf(stderr,"\nInexact Value for %s\n",optname);
              }
              C_Sane_Option *opt = sane->option(currentOption_num);
              if (opt && opt->descriptor()) {
                  currentOption=opt;
                  FlScanSelOption();
              }
          } else {
  /*
              fprintf (
                  stderr,
                  "\n%s [%s]\n",
                  (SANE_String_Const)currentOption->status(),
                  optname
              );
  */
          }
          if (to_be_freed) {
              delete (int *)optval;
          }
      }
}

void FlScanSelOption() {
  int i,d;
  const char *curdevice=0,*message=0;
  Fl_Group *group=0;
  C_Sane_Value val;
  static char buff[256];
  #define INVALID_FORMAT "Invalid Format"
  #define NOT_YET_IMPLEMENTED "Tables and Arrays\nare not yet implemented"
  
      if (currentOption) {
          const SANE_Option_Descriptor *sod = currentOption->descriptor();
          FlScanPbAutoOption->hide();
          if (sod->cap & SANE_CAP_AUTOMATIC) {
              FlScanPbAutoOption->show();
          }
          val=currentOption->value();
          switch (sod->type) {
              case SANE_TYPE_BOOL:
                  if (sod->size==sizeof(SANE_Word)) {
                      switch (sod->constraint_type) {
                          case SANE_CONSTRAINT_NONE:
                              group=FlScanBoolGroup;
                              FlScanTbBoolType->value((bool)val);
                              FlScanTbBoolType->label(currentOption->string_value());
                              break;
                          case SANE_CONSTRAINT_RANGE:
                          case SANE_CONSTRAINT_WORD_LIST:
                          case SANE_CONSTRAINT_STRING_LIST:
                          default:
                              message=INVALID_FORMAT;
                              break;
                      }
                  } else { /* table or array */
                      message=INVALID_FORMAT;
                  }
                  break;
              case SANE_TYPE_INT:
                  if (sod->size==sizeof(SANE_Word)) {
                      switch (sod->constraint_type) {
                          case SANE_CONSTRAINT_NONE:
                              group=FlScanIntGroup;
                              FlScanTxIntType->value (
                                  (char*)currentOption->string_value()
                              );
                              break;
                          case SANE_CONSTRAINT_RANGE:
                              group=FlScanRangeGroup;
                              FlScanViRangeType->value((double)((int)val));
                              FlScanViRangeType->minimum (
                                  (double)sod->constraint.range->min
                              );
                              FlScanViRangeType->maximum (
                                  (double)sod->constraint.range->max
                              );
                              FlScanViRangeType->step (
                                  (double)sod->constraint.range->quant
                              );
                              FlScanSlRangeType->value((double)((int)val));
                              FlScanSlRangeType->minimum (
                                  (double)sod->constraint.range->min
                              );
                              FlScanSlRangeType->maximum (
                                  (double)sod->constraint.range->max
                              );
                              FlScanSlRangeType->step (
                                  (double)sod->constraint.range->quant
                              );
                              break;
                          case SANE_CONSTRAINT_WORD_LIST:
                              group=FlScanListGroup;
                              FlScanMnListType->clear();
                              for (d=0,i=1;i<=sod->constraint.word_list[0];i++) {
                                  sprintf(buff,"%d",sod->constraint.word_list[i]);
                                  FlScanMnListType->add (
                                      FlScanMenuize(buff),
                                      0,
                                      (Fl_Callback *)FlScanChoiceCB,
                                      (void*)0
                                  );
                                  if ((int)val==sod->constraint.word_list[i]) {
                                      d=i-1;
                                  }
                              }
                              FlScanMnListType->value(d);
                              break;
                          case SANE_CONSTRAINT_STRING_LIST:
                          default:
                              message=INVALID_FORMAT;
                              break;
                      }
                  } else { /* table or array */
                      int size=sod->size/sizeof(SANE_Word);
                      double *vector=new double[size];
                      if (vector) {
                          group=FlScanTableGroup;
                          switch (sod->constraint_type) {
                              case SANE_CONSTRAINT_RANGE:
                                  FlScanTableGammaCurve->bounds (
                                      (double)0,
                                      (double)sod->constraint.range->min,
                                      (double)(size-1),
                                      (double)sod->constraint.range->max
                                  );
                                  break;
                              case SANE_CONSTRAINT_WORD_LIST: {
                                  double min, max, v;
                                      if (sod->constraint.word_list[0]>1) {
                                          max=(double)sod->constraint.word_list[1];
                                          min=max;
                                          for (
                                              i=2;
                                              i<sod->constraint.word_list[0];
                                              i++
                                          ) {
                                              v=(double)sod->constraint.word_list[i];
                                              if (v<min) {
                                                  min=v;
                                              }
                                              if (v>max) {
                                                  max=v;
                                              }
                                          }
                                      } else {
                                          min=max=0;
                                      }
                                      if (min==max) {
                                          message=INVALID_FORMAT;
                                          group=0;
                                      } else {
                                          FlScanTableGammaCurve->bounds (
                                              (double)0,
                                              min,
                                              (double)(size-1),
                                              max
                                          );
                                      }
                                  }
                                  break;
                              case SANE_CONSTRAINT_NONE:
                              case SANE_CONSTRAINT_STRING_LIST:
                              default:
                                  message=INVALID_FORMAT;
                                  break;
                          }
                          if (group) {
                              SANE_Int *pval=(SANE_Int*)((void*)val);
                              for (i=0;i<size;i++) {
                                  vector[i]=(double)pval[i];
                              }
                              FlScanTableGammaCurve->set_vector(size,vector);                            
                          }
                          delete vector;
                      } else {
                          message=INVALID_FORMAT;
                      }
                  }
                  break;
              case SANE_TYPE_FIXED:
                  if (sod->size==sizeof(SANE_Word)) {
                      switch (sod->constraint_type) {
                          case SANE_CONSTRAINT_NONE:
                              group=FlScanFixedGroup;
                              FlScanTxFixedType->value (
                                  (char*)currentOption->string_value()
                              );
                              break;
                          case SANE_CONSTRAINT_RANGE:
                              group=FlScanRangeGroup;
                              FlScanViRangeType->value((double)val);
                              FlScanViRangeType->minimum (
                                  (double)SANE_UNFIX(sod->constraint.range->min)
                              );
                              FlScanViRangeType->maximum (
                                  (double)SANE_UNFIX(sod->constraint.range->max)
                              );
                              FlScanViRangeType->step (
                                  (double)SANE_UNFIX(sod->constraint.range->quant)
                              );
                              FlScanSlRangeType->value((double)val);
                              FlScanSlRangeType->minimum (
                                  (double)SANE_UNFIX(sod->constraint.range->min)
                              );
                              FlScanSlRangeType->maximum (
                                  (double)SANE_UNFIX(sod->constraint.range->max)
                              );
                              FlScanSlRangeType->step (
                                  (double)SANE_UNFIX(sod->constraint.range->quant)
                              );
                              break;
                          case SANE_CONSTRAINT_WORD_LIST:
                          case SANE_CONSTRAINT_STRING_LIST:
                          default:
                              message=INVALID_FORMAT;
                              break;
                      }
                  } else { /* table or array */
                      int size=sod->size/sizeof(SANE_Word);
                      double *vector=new double[size];
                      if (vector) {
                          group=FlScanTableGroup;
                          switch (sod->constraint_type) {
                              case SANE_CONSTRAINT_RANGE:
                                  FlScanTableGammaCurve->bounds (
                                      (double)0,
                                      (double)SANE_UNFIX(sod->constraint.range->min),
                                      (double)(size-1),
                                      (double)SANE_UNFIX(sod->constraint.range->max)
                                  );
                                  break;
                              case SANE_CONSTRAINT_WORD_LIST: {
                                  double min, max, val;
                                      if (sod->constraint.word_list[0]>1) {
                                          min=max=(double)SANE_UNFIX (
                                              sod->constraint.word_list[1]
                                          );
                                          for (
                                              i=2;
                                              i<sod->constraint.word_list[0];
                                              i++
                                          ) {
                                              val=(double)SANE_UNFIX (
                                                  sod->constraint.word_list[i]
                                              );
                                              if (val<min) {
                                                  min=val;
                                              }
                                              if (val>max) {
                                                  max=val;
                                              }
                                          }
                                      } else {
                                          min=max=0;
                                      }
                                      if (min==max) {
                                          message=INVALID_FORMAT;
                                          group=0;
                                      } else {
                                          FlScanTableGammaCurve->bounds (
                                              (double)0,
                                              min,
                                              (double)(size-1),
                                              max
                                          );
                                      }
                                  }
                                  break;
                              case SANE_CONSTRAINT_NONE:
                              case SANE_CONSTRAINT_STRING_LIST:
                              default:
                                  message=INVALID_FORMAT;
                                  break;
                          }
                          if (group) {
                              SANE_Int *pval=(SANE_Int*)((void*)val);
                              for (i=0;i<size;i++) {
                                  vector[i]=(double)SANE_UNFIX(pval[i]);
                              }
                              FlScanTableGammaCurve->set_vector(size,vector);                            
                          }
                          delete vector;
                      } else {
                          message=INVALID_FORMAT;
                      }
                  }
                  break;
              case SANE_TYPE_STRING:
                  switch (sod->constraint_type) {
                      case SANE_CONSTRAINT_NONE:
                          group=FlScanStringGroup;
                          FlScanTxStringType->value((char*)val);
                          break;
                      case SANE_CONSTRAINT_STRING_LIST:
                          group=FlScanListGroup;
                          FlScanMnListType->clear();
                          for (d=0,i=0;sod->constraint.string_list[i];i++) {
                              FlScanMnListType->add (
                                  FlScanMenuize(sod->constraint.string_list[i]),
                                  0,
                                  (Fl_Callback *)FlScanChoiceCB,
                                  (void*)0
                              );
                              if (!strcmp((char*)val,sod->constraint.string_list[i])) {
                                  d=i;
                              }
                          }
                          FlScanMnListType->value(d);
                          break;
                      case SANE_CONSTRAINT_RANGE:
                      case SANE_CONSTRAINT_WORD_LIST:
                      default:
                          message=INVALID_FORMAT;
                          break;
                  }
                  break;
              case SANE_TYPE_BUTTON:
                  group=FlScanButtonGroup;
                  break;
              default:
                  group=0;
                  break;
          }
          FlScanPbSetOption->hide();
          if (sod->unit==SANE_UNIT_NONE) {
              strcpy(buff,sod->title);
          } else {
              sprintf (
                  buff,
                  "%s [%s]",
                  sod->title,
                  (sod->unit==SANE_UNIT_PIXEL      ) ? "pixel" :
                  (sod->unit==SANE_UNIT_BIT        ) ? "bit"   :
                  (sod->unit==SANE_UNIT_DPI        ) ? "dpi"   :
                  (sod->unit==SANE_UNIT_PERCENT    ) ? "%"     :
                  (sod->unit==SANE_UNIT_MM         ) ? "mm"    :
                  (sod->unit==SANE_UNIT_MICROSECOND) ? "\256s" : "none"
              );
          }
          if (group) {
              FlScanShowOption(group,buff,sod->desc);
          } else {
              FlScanMessage->label(message);
              FlScanShowOption(FlScanMessage,buff,(char*)0);
          }
      } else { /* Device Selection */
          switch (currentOption_num) {
              case FL_SCAN_DEVICE_SELECTION:
                  FlScanMnListType->clear();
                  d=0;
                  if (sane->device() && sane->device()->name) {
                      curdevice=strdup(sane->device()->name);
                  }
                  for (i=0;i<sane->num_devices() && sane->device(i);i++) {
                      FlScanMnListType->add (
                          FlScanMenuize(sane->device(i)->name),
                          0,
                          (Fl_Callback *)FlScanChoiceCB,
                          (void*)sane->device(i)
                      );
                      if (
                          curdevice && 
                          sane->device(i)->name &&
                          !strcmp(sane->device(i)->name,curdevice)
                      ) {
                          d=i;
                      }
                  }
                  FlScanMnListType->value(d);
                  FlScanShowOption(FlScanListGroup,"Device","Select a device");
                  break;
              case FL_SCAN_CONVERTERS_SETTINGS:
                  FlScanShowOption(FlScanSetupJPEG,"Image Converters Setting","Configure Image converters");
                  break;
              case FL_SCAN_HISTOGRAM:
                  FlScanShowOption(FlScanHistogram,"Histogram","Show image histogram");
                  break;
              case FL_SCAN_OUTPUT_FILE_RESOLUTION:
                  FlScanShowOption(FlScanOutputResolutions,"Output file resolution will...","Select the output files resolutions\nand zoom filter type");
                  break;
              default:
                  FlScanShowOption(FlScanSaneLogo,NULL,"Powered by...");
                  break;
          }
      }
}

void FlScanShowOption(Fl_Group *w,const char *l,const char *t) {
  /**/
      if (lastOption) {
          lastOption->hide();
      }
      if (l) {
          FlScanSetOption->label(l);
          FlScanSetOption->redraw();
      }
      if (w) {
          w->tooltip(t);
          w->show();
          w->redraw();
          lastOption=w;
      }
}

char * FlScanMenuize(const char *str) {
  static char title[256];
  int i=0,j=0;
  
      for (i=0,j=0; str && str[i]; i++, j++) {
          if (str[i]=='/' || str[i]=='|' || str[i]=='\\') {
              title[j]='\\'; j++;
          }
          title[j]=str[i];
      }
      title[j]='\0';
      return title;
}

void FlScanChoiceCB(Fl_Widget *w,void *d) {
  /**/
      if (currentOption) {
          FlScanSaneSetCB(false);
      } else { /* Device Selection */
          if (sane->device()!=(SANE_Device*)d) {
              FlScanSaveCurrentDevice();
              sane->open(((SANE_Device*)d)->name);
              FlScanLoadCurrentDevice();
              update_tree();
              FlScanSelOption();
          }
      }
      return;
}

void FlScanTableSetGamma() {
  double val;
  const char *cval;
  
      cval=FlScanTxGammaTable->value();
      if (cval && sscanf(cval,"%lf",&val)!=EOF) {
          FlScanTableGammaCurve->gamma(val);
      }
      FlScanTxGammaTable->value("");
}

void FlScanScannerCB(int fd,void *d) {
  /**/
      if (d) {
          sane->scanner (
              scan_buf,
              4096*3,
              (C_Sane_ScanCB)d
          );
      }
}

bool FlScanPreviewCB(void *d,int l,int m) {
  SANE_Parameters *p;
  static int started=0;
  static int frame=-1;
  static int scan_fd=0;
  int zoomFilter;
  
      p=(SANE_Parameters*)d;
      switch (m) {
          case C_Sane::USER_MODE:
              if (!scan_buf) {
                  scan_buf = new char[4096*3];
              }
              if (scan_buf) {
                  if (preview_ndx>=0) {
                      void *optval=0;
                      SANE_Bool set=true;
                      C_Sane_Option *opt = sane->option(preview_ndx);
                      if (opt) {
                          optval=(void*)&set;
                          opt->value(optval);
                      }
                  }
                  FlScanPbPreview->deactivate();
                  FlScanPbScan->deactivate();
                  FlScanPbReset->deactivate();
                  FlScanPbCancel->activate();
                  FlScanUpdateProgress("Device Initialization",false);
                  sane->scan (
                      scan_buf,
                      4096*3,
                      (C_Sane_ScanCB)FlScanPreviewCB
                  );
              }
              // started=0;
              break;
          case C_Sane::START_FRAME:
              frame=(p->format==SANE_FRAME_GRAY)?Image_Stream::FRAME_GRAY:
                    (p->format==SANE_FRAME_RGB)?Image_Stream::FRAME_RGB:
                    (p->format==SANE_FRAME_RED)?Image_Stream::FRAME_RED:
                    (p->format==SANE_FRAME_GREEN)?Image_Stream::FRAME_GREEN:
                    (p->format==SANE_FRAME_BLUE)?Image_Stream::FRAME_BLUE:-1;
              FlScanUpdateProgress (
                   (p->format==SANE_FRAME_GRAY)?"Receiving GRAY data":
                   (p->format==SANE_FRAME_RGB)?"Receiving RGB data":
                   (p->format==SANE_FRAME_RED)?"Receiving RED data":
                   (p->format==SANE_FRAME_GREEN)?"Receiving GREEN data":
                   (p->format==SANE_FRAME_BLUE)?"Receiving BLUE data":"Receiving data",
                   false
              );
              if (!started) {
                  FlScanPreviewArea->begin (
                      p->pixels_per_line,
                      p->depth,
                      (frame!=SANE_FRAME_GRAY)
                  );
              } else {
                  FlScanPreviewArea->rewind();
              }
              started=1;
              scan_fd=l;
              if (scan_fd) {
                  Fl::add_fd(scan_fd,FL_READ|FL_EXCEPT,FlScanScannerCB,(void*)FlScanPreviewCB);
              } else {
                  FlScanScannerCB(0,(void*)FlScanPreviewCB);
              }
              break;
          case C_Sane::END_OF_DATA:
              started=0;
              if (scan_fd) {
                  Fl::remove_fd(scan_fd);
              }
              FlScanUpdateProgress("Updating Preview Window",false);
              zoomFilter = FlScanPreviewArea->filter();
              FlScanPreviewArea->filter(Image_Stream::UNDEFINED_FILTER);
              FlScanPreviewArea->end();
              FlScanPreviewArea->filter(zoomFilter);
              FlScanPbCancel->deactivate();
              FlScanPbPreview->activate();
              FlScanPbReset->activate();
              if (strlen(FlScanTxFileName->value())) {
                  FlScanPbScan->activate();
              }
              FlScanUpdateProgress("",false);
              break;
          case C_Sane::NEW_DATA:
              if (frame>=0) {
                  FlScanUpdateProgress(0,true);
                  FlScanPreviewArea->add_row_data((unsigned char*)d,l,frame);
              }
              break;
          case C_Sane::DATA_ERROR:
              started=0;
              if (scan_fd) {
                  Fl::remove_fd(scan_fd);
              }
              FlScanPbCancel->deactivate();
              FlScanPbPreview->activate();
              FlScanPbReset->activate();
              if (strlen(FlScanTxFileName->value())) {
                  FlScanPbScan->activate();
              }
              FlScanUpdateProgress("ERROR",false);
              FlScanPreviewArea->reset();
              break;
      }
      return true;
}

void FlScanUpdateSelection() {
  double sx,sy,sw,sh;
  
      FlScanPreviewArea->selection(sx,sy,sw,sh);
  /*
      printf (
          "\nsx=%f\nsy=%f\nsw=%f\nsh=%f",
          sx*100.0,
          sy*100.0,
          sw*100.0,
          sh*100.0
      );
  */
      fflush(stdout);
}

void FlScanUpdateProgress(const char *msg,bool working) {
  static char *message=0;
  static int sense=1;
  double val;
  
      if (msg) {
          message=(char *)msg;
      }
      FlScanProgressBar->label((message)?message:"");
      if (working) {
          val=FlScanProgressBar->value() + sense;
          if (sense>0 && val>=FlScanProgressBar->maximum()) {
             sense=-1;
             val=FlScanProgressBar->maximum();
          } else if (sense<0 && val<=FlScanProgressBar->minimum()) {
             sense=+1;
             val=FlScanProgressBar->minimum();
          }
          FlScanProgressBar->value(val);
      } else {
          FlScanProgressBar->value(FlScanProgressBar->minimum());
          sense=+1;
      }
      FlScanProgressBar->damage(FL_DAMAGE_ALL);
      FlScanProgressBar->redraw();
      Fl::flush();
}

bool FlScanScanCB(void *d,int l,int m) {
  SANE_Parameters *p;
  static int started=0;
  static int frame=-1;
  static int scan_fd=0;
  double cx,cy,cw,ch;
  char *fname=NULL;
  int zoomFilter;
  
      p=(SANE_Parameters*)d;
      switch (m) {
          case C_Sane::USER_MODE:
              if (!scan_buf) {
                  scan_buf = new char[4096*3];
              }
              if (scan_buf) {
                  if (preview_ndx>=0) {
                      void *optval=0;
                      SANE_Bool set=false;
                      C_Sane_Option *opt = sane->option(preview_ndx);
                      if (opt) {
                          optval=(void*)&set;
                          opt->value(optval);
                      }
                  }
                  FlScanPbPreview->deactivate();
                  FlScanPbScan->deactivate();
                  FlScanPbReset->deactivate();
                  FlScanPbCancel->activate();
                  FlScanUpdateProgress("Device Initialization",false);
                  sane->scan (
                      scan_buf,
                      4096*3,
                      (C_Sane_ScanCB)FlScanScanCB
                  );
              }
              // started=0;
              break;
          case C_Sane::START_FRAME:
              frame=(p->format==SANE_FRAME_GRAY)?Image_Stream::FRAME_GRAY:
                    (p->format==SANE_FRAME_RGB)?Image_Stream::FRAME_RGB:
                    (p->format==SANE_FRAME_RED)?Image_Stream::FRAME_RED:
                    (p->format==SANE_FRAME_GREEN)?Image_Stream::FRAME_GREEN:
                    (p->format==SANE_FRAME_BLUE)?Image_Stream::FRAME_BLUE:-1;
              FlScanUpdateProgress (
                   (p->format==SANE_FRAME_GRAY)?"Receiving GRAY data":
                   (p->format==SANE_FRAME_RGB)?"Receiving RGB data":
                   (p->format==SANE_FRAME_RED)?"Receiving RED data":
                   (p->format==SANE_FRAME_GREEN)?"Receiving GREEN data":
                   (p->format==SANE_FRAME_BLUE)?"Receiving BLUE data":"Receiving data",
                   false
              );
              if (!started) {
                  FlScanOutputFile.begin (
                      p->pixels_per_line,
                      p->depth,
                      (frame!=SANE_FRAME_GRAY)
                  );
                  OutputImageFile *of=FlScanOutputFile.format(Output_File::JPEG);
                  if (of) {
                      of->set_quality((int)FlScanFFmtSlQltJPEG->value());
                      of->set_smoothing((int)FlScanFFmtSlSmtJPEG->value());
                      of->set_optimization((int)FlScanFFmtTbOptJPEG->value());
                  }
                  of=FlScanOutputFile.format(Output_File::PNG);
                  if (of) {
                      of->set_quality((int)FlScanFFmtSlCompressionPNG->value());
                  }
              } else {
                  FlScanOutputFile.rewind();
              }
              started=1;
              scan_fd=l;
              if (scan_fd) {
                  Fl::add_fd(scan_fd,FL_READ|FL_EXCEPT,FlScanScannerCB,(void*)FlScanScanCB);
              } else {
                  FlScanScannerCB(0,(void*)FlScanScanCB);
              }
              break;
          case C_Sane::END_OF_DATA:
              started=0;
              if (scan_fd) {
                  Fl::remove_fd(scan_fd);
              }
              fname=new char[strlen(FlScanTxFileName->value())+4+9+1];
              if (fname) {
                  bool one_saved=false;
                  char msg[40];
                  int ext_len=0;
                  if (FlScanOutputFile.extension()) {
                      ext_len=strlen(FlScanOutputFile.extension());
                  }
                  strcpy(fname,FlScanTxFileName->value());
                  char *strbuf = new char [strlen(fname)+4+9+1+ext_len];
                  if (strbuf) {
                      if (
                          FlScanOutputFile.extension() &&
                          !strcasecmp (
                              &fname[strlen(fname)-ext_len],
                              FlScanOutputFile.extension()
                          )
                      ) {
                          fname[strlen(fname)-ext_len]='\0';
                      }
                      zoomFilter = FlScanOutputFile.Image_Stream::filter();
                      FlScanOutputFile.Image_Stream::filter(FlScanZoomFilter);
                      // FlScanOutputFile.matrix(FlScanPreviewArea->matrix());
                      FlScanPreviewArea->selection(cx,cy,cw,ch);
                      // FlScanOutputFile.clip(cx,cy,cw,ch);
                      FlScanUpdateCounterInFilename(&fname,1,1,4);
                      FlScanTxFileName->value(fname);
                      for (int i=1;i<=FlScanLsOutputGeometries->size();i++) {
                          if (FlScanLsOutputGeometries->selected(i)) {
                              size_t geom = (size_t)FlScanLsOutputGeometries->data(i);
                              if (geom) {
                                  sprintf(msg,"Saving File - %d x %d",geom,geom);
                                  sprintf(strbuf,"%s_%d",fname,geom);
                              } else {
                                  sprintf(msg,"Saving File - Full Size");
                                  sprintf(strbuf,"%s_FullSize",fname);
                              }
                              if (FlScanOutputFile.extension()) {
                                  strcat(strbuf,FlScanOutputFile.extension());
                              }
                              FlScanUpdateProgress(msg,false);
                              FlScanOutputFile.matrix(FlScanPreviewArea->matrix());
                              FlScanOutputFile.clip(cx,cy,cw,ch);
                              FlScanOutputFile.write(strbuf,geom,FlScanSaveProgressCB);
                              FlScanOutputFile.clip(0.0,0.0,1.0,1.0);
                              one_saved=true;
                          }
                      }
                      if (!one_saved) {
                          sprintf(msg,"Saving File - Full Size");
                          FlScanUpdateProgress(msg,false);
                          sprintf(strbuf,"%s_FullSize",fname);
                          if (FlScanOutputFile.extension()) {
                              strcat(strbuf,FlScanOutputFile.extension());
                          }
                          FlScanOutputFile.matrix(FlScanPreviewArea->matrix());
                          FlScanOutputFile.clip(cx,cy,cw,ch);
                          FlScanOutputFile.write(strbuf,0,FlScanSaveProgressCB);
                          FlScanOutputFile.clip(0.0,0.0,1.0,1.0);
                      }
                      FlScanOutputFile.Image_Stream::filter(zoomFilter);
                      delete strbuf;
                  }
                  FlScanOutputFile.reset();
                  delete fname;
              }
              // FlScanOutputFile.clip(0.0,0.0,1.0,1.0);
              FlScanPbCancel->deactivate();
              FlScanPbPreview->activate();
              FlScanPbScan->activate();
              FlScanPbReset->activate();
              FlScanUpdateProgress("",false);
              break;
          case C_Sane::NEW_DATA:
              if (frame>=0) {
                  FlScanUpdateProgress(0,true);
                  FlScanOutputFile.add_row_data((unsigned char*)d,l,frame);
              }
              break;
          case C_Sane::DATA_ERROR:
              started=0;
              if (scan_fd) {
                  Fl::remove_fd(scan_fd);
              }
              FlScanPbCancel->deactivate();
              FlScanPbPreview->activate();
              FlScanPbScan->activate();
              FlScanPbReset->activate();
              FlScanUpdateProgress("ERROR",false);
              FlScanOutputFile.reset();
              break;
      }
      return true;
}

void dump_sane() {
  int hlp, x;
  SANE_Parameters *pars;
  const SANE_Option_Descriptor *sod;
  
      for (hlp=0;sane->num_devices() && sane->device(hlp);++hlp) {
          fprintf(stderr,"Device[%d].name   : %s\n",hlp,sane->device(hlp)->name);
          fprintf(stderr,"Device[%d].vendor : %s\n",hlp,sane->device(hlp)->vendor);
          fprintf(stderr,"Device[%d].model  : %s\n",hlp,sane->device(hlp)->model);
          fprintf(stderr,"Device[%d].type   : %s\n",hlp,sane->device(hlp)->type);
      }
      for (hlp = 0; hlp < sane->num_options() && sane->option(hlp); hlp++) {
          sod = sane->option(hlp)->descriptor();
          if (sod == NULL) {
              break;
          }
          fprintf (stderr, "Gopt(%d) : stat=%p {\n", hlp, sod);
          fprintf (stderr, "\tname : %s\n", sod->name);
          fprintf (stderr, "\ttitle: %s\n", sod->title);
          fprintf (stderr, "\tdesc : %s\n", sod->desc);
  
          fprintf (
              stderr,
              "\ttype : %d [%s]\n",
              sod->type,
              (sod->type==SANE_TYPE_BOOL)?"bool":
              (sod->type==SANE_TYPE_INT)?"int":
              (sod->type==SANE_TYPE_FIXED)?"fixed":
              (sod->type==SANE_TYPE_STRING)?"string":
              (sod->type==SANE_TYPE_BUTTON)?"button":
              (sod->type==SANE_TYPE_GROUP)?"group":"UNKNOWN"
          );
          fprintf (
              stderr,
              "\tunit : %d [%s]\n",
              sod->unit,
              (sod->unit==SANE_UNIT_NONE)?"unit-less (e.g., # of scans)":
              (sod->unit==SANE_UNIT_PIXEL)?"number of pixels":
              (sod->unit==SANE_UNIT_BIT)?"number of bits":
              (sod->unit==SANE_UNIT_MM)?"millimeters":
              (sod->unit==SANE_UNIT_DPI)?"resolution in dots/inch":
              (sod->unit==SANE_UNIT_PERCENT)?"percentage":
              (sod->unit==SANE_UNIT_MICROSECOND)?"micro seconds":"UNKNOWN"
          );
          fprintf (stderr, "\tsize : %d\n", sod->size);
          fprintf (stderr, "\tcap  : %d [", sod->cap);
          if (sod->cap&SANE_CAP_SOFT_SELECT) {
              fprintf (stderr, " SOFT_SELECT");
          }
          if (sod->cap&SANE_CAP_HARD_SELECT) {
              fprintf (stderr, " HARD_SELECT");
          }
          if (sod->cap&SANE_CAP_SOFT_DETECT) {
              fprintf (stderr, " SOFT_DETECT");
          }
          if (sod->cap&SANE_CAP_EMULATED) {
              fprintf (stderr, " EMULATED");
          }
          if (sod->cap&SANE_CAP_AUTOMATIC) {
              fprintf (stderr, " AUTOMATIC");
          }
          if (sod->cap&SANE_CAP_INACTIVE) {
              fprintf (stderr, " INACTIVE");
          }
          if (sod->cap&SANE_CAP_ADVANCED) {
              fprintf (stderr, " ADVANCED");
          }
  /*        if (sod->cap&SANE_CAP_ALWAYS_SETTABLE) {
              fprintf (stderr, " ALWAYS_SETTABLE");
          }
  */        fprintf (stderr, " ]\n");
          fprintf (
              stderr,
              "\tctyp : %d [%s]\n",
              sod->constraint_type,
              (sod->constraint_type==SANE_CONSTRAINT_NONE)?"no constraints":
              (sod->constraint_type==SANE_CONSTRAINT_RANGE)?"range":
              (sod->constraint_type==SANE_CONSTRAINT_WORD_LIST)?"word list":
              (sod->constraint_type==SANE_CONSTRAINT_STRING_LIST)?"string list":
              "UNKNOWN"
          );
          switch (sod->constraint_type) {
              case SANE_CONSTRAINT_NONE:
                  break;
              case SANE_CONSTRAINT_STRING_LIST:
                  fprintf(stderr,"\t\tstringlist:");
                  for (x=0;sod->constraint.string_list[x];x++) {
                      fprintf(stderr," %s,",sod->constraint.string_list[x]);
                  }
                  fprintf(stderr,"\n");
                  break;
              case SANE_CONSTRAINT_WORD_LIST:
                  fprintf (
                      stderr,
                      "\t\twordlist (%d) : ",
                      sod->constraint.word_list[0]
                  );
                  if (sod->type==SANE_TYPE_FIXED) {
                      for (x = 1; x <= sod->constraint.word_list[0]; x++) {
                          fprintf (
                              stderr,
                              " %g ",
                              SANE_UNFIX(sod->constraint.word_list[x])
                          );
                      }
                  } else {
                      for (x = 1; x <= sod->constraint.word_list[0]; x++) {
                          fprintf (
                              stderr,
                              " %d ",
                              sod->constraint.word_list[x]
                          );
                      }
                  }
                  fprintf(stderr,"\n");
                  break;
              case SANE_CONSTRAINT_RANGE:
                  if (sod->type==SANE_TYPE_FIXED) {
                      fprintf (
                          stderr,
                          "\t\trange: min=%g max=%g quantization=%g \n",
                          SANE_UNFIX(sod->constraint.range->min),
                          SANE_UNFIX(sod->constraint.range->max),
                          SANE_UNFIX(sod->constraint.range->quant)
                      );
                  } else {
                      fprintf (
                          stderr,
                          "\t\trange: min=%d max=%d quantization=%d \n",
                          sod->constraint.range->min,
                          sod->constraint.range->max,
                          sod->constraint.range->quant
                      );
                  }
                  break;
          }
          if (
              SANE_OPTION_IS_ACTIVE(sod->cap) &&
              (sod->type==SANE_TYPE_STRING ||
              sod->size==sizeof(SANE_Word))
          ) {
              C_Sane_Value val;
              fprintf(stderr,"\tvalue: ");
              val = sane->option(hlp)->value();
              switch (sod->type) {
                  case SANE_TYPE_BOOL:
                      fprintf(stderr,"%s",((bool)val)?"true":"false");
                      break;
                  case SANE_TYPE_INT:
                      fprintf(stderr,"%d",(int)val);
                      break;
                  case SANE_TYPE_FIXED:
                      fprintf(stderr,"%g",(double)val);
                      break;
                  case SANE_TYPE_STRING:
                      fprintf(stderr,"%s",(char*)val);
                      break;
                  default:
                      break;
              }
              fprintf(stderr,"\n");
          }
          fprintf(stderr,"}\n");
      }
      pars = sane->parameters();
      fprintf(stderr,"Parm : stat=%s {\n",(SANE_String_Const)sane->status());
      if (pars) {
          fprintf (
              stderr,
              "\tform=%d [%s]\n",
              pars->format,
              (pars->format==SANE_FRAME_GRAY)?
                  "FRAME GRAY (band covering human visual range)":
              (pars->format==SANE_FRAME_RGB)?
                  "FRAME RGB (pixel-interleaved red/green/blue bands)":
              (pars->format==SANE_FRAME_RED)?
                  "FRAME RED (red band only)":
              (pars->format==SANE_FRAME_GREEN)?
                  "FRAME GREEN (green band only)":
              (pars->format==SANE_FRAME_BLUE)?
                  "FRAME BLUE (blue band only)":"UNKNOWN"
          );
          fprintf(stderr,"\tlast frame=%s\n",(pars->last_frame)?"true":"false");
          fprintf(stderr,"\tbytes per line=%d\n",pars->bytes_per_line);
          fprintf(stderr,"\tpixels per line=%d\n",pars->pixels_per_line);
          fprintf(stderr,"\tlines=%d\n",pars->lines);
          fprintf(stderr,"\tdepth=%d\n}\n",pars->depth);
      }
      fflush(stderr);
}

void FlScanSaveProgressCB(int prog) {
  static int lastProg=0;
  
      if (!FlScanEeWaitForSaving->visible()) {
          Fl::wait(0);
      }
      if (prog!=lastProg) {
          if (prog>=0) {
              FlScanUpdateProgress(0,true);
          } else {
              FlScanUpdateProgress("Flushing data to file",false);
          }
          lastProg=prog;
      }
}

char* FlScanGetCurrentDeviceConfigFileName(void) {
  static const char hexdigit[] = "0123456789abcdef";
  static char cfgfile[1024];
  char *devicename,ch;
  int i,j;
  
      cfgfile[0]='\0';
      if (sane->device()) {
          if ((devicename=(char*)sane->device()->name)) {
              fl_filename_expand(cfgfile,"~/.sane");
              mkdir(cfgfile,0777);
              fl_filename_expand(cfgfile,"~/.sane/flscan-sane.cfg");
              mkdir(cfgfile,0777);
              strcat(cfgfile,"/");
              i=strlen(cfgfile);
              for (j=0;(ch=devicename[j])!='\0';j++) {
                  if (isalnum(ch)) {
                      cfgfile[i++]=ch;
                  } else {
                      cfgfile[i++]='-';
                      if (ch!='-') {
                          cfgfile[i++]=hexdigit[(ch>>4)&0x0f];
                          cfgfile[i++]=hexdigit[(ch>>0)&0x0f];
                      }
                      cfgfile[i++]='-';
                  }
              }
              cfgfile[i]='\0';
              if ((devicename=strdup(cfgfile))) {
                  fl_filename_expand(cfgfile,devicename);
                  free(devicename);
              } else {
                  cfgfile[0]='\0';
              }
          }
      }
      return cfgfile;
}

bool FlScanValidateOptionSaving(char *optname) {
  return (
      optname &&
      strcmp(optname,SANE_NAME_PREVIEW) &&
      strcmp(optname,SANE_NAME_SCAN_TL_X)
    /* &&
      strcmp(optname,SANE_NAME_SCAN_TL_Y) &&
      strcmp(optname,SANE_NAME_SCAN_BR_X) &&
      strcmp(optname,SANE_NAME_SCAN_BR_Y)
    */
  );
}

void FlScanSaveCurrentDevice(void) {
  char *cfgfile;
  FILE *pfcfg;
  
        cfgfile = FlScanGetCurrentDeviceConfigFileName();
        if (cfgfile && cfgfile[0]!='\0' && (pfcfg=fopen(cfgfile,"wb"))) {
            sane->save(pfcfg,FlScanValidateOptionSaving);
            fclose(pfcfg);
        }
}

void FlScanLoadCurrentDevice(void) {
  char *cfgfile;
  FILE *pfcfg;
  
        cfgfile = FlScanGetCurrentDeviceConfigFileName();
        if (cfgfile && cfgfile[0]!='\0' && (pfcfg=fopen(cfgfile,"rb"))) {
            sane->load(pfcfg,FlScanValidateOptionSaving);
            fclose(pfcfg);
        }
}

void FlScanUpdateCounterInFilename(char **filename,int skip,int step,int min_counter_len) {
  FILE *testfile;
  char *position_point = NULL;
  char *position_counter;
  char  buf[FILENAME_MAX];
  int   counter, i, j;
  int   counter_len;
  int   set_counter_len = min_counter_len;
  bool  last_was_space=false;
  
      for (i=0, j=0; (*filename)[i]; i++) {
          if (isspace((*filename)[i])) {
              last_was_space=true;
          } else {
              (*filename)[j++] = (last_was_space) ? toupper((*filename)[i])
                                                  : (*filename)[i];
              last_was_space=false;
          }
      }
      (*filename)[j++] = '\0';
      position_point = strrchr(*filename, '.');
      if (!position_point) { /* nothing usable ? */
          /* here is no point, but position - 1 is last character */
          position_point = *filename + strlen(*filename);
      }
      if (position_point) {
          /* go to last number of counter (if counter exists) */
          position_counter = position_point - 1;
          /* search non numeric char */
          while (
              ( position_counter >= *filename) &&
              (*position_counter >= '0'      ) &&
              (*position_counter <= '9'      )
          ) {
              position_counter--; /* search fisrt numeric character */
          }
          position_counter++;     /* go to first numeric charcter */
          counter_len = position_point - position_counter;
          if (counter_len) {      /* we have a counter */
              sscanf(position_counter,"%d",&counter);
  
              while (1) { /* may be we have to skip existing files */
                  counter += step;    /* update counter */
                  if (counter < 0) {
                      counter = 0;
  //                  xsane_back_gtk_warning (WARN_COUNTER_UNDERRUN, TRUE);
                      break;      /* last available number ("..999") */
                  }
                  /* set end of string mark to counter start */
                  *position_counter = 0;
                  if (set_counter_len == 0) {
                      set_counter_len = counter_len;
                  }
                  snprintf (
                      buf,
                      sizeof(buf),
                      "%s%0*d%s",
                      *filename,
                      set_counter_len,
                      counter,
                      position_point
                  );
                  if (skip) { /* test if filename already used */
                      /* read binary (b for win32) */
                      testfile = fopen(buf,"rb");
                      if (testfile) { /* filename used: skip */
                          fclose(testfile);
                      } else {
                          free(*filename);
                          *filename = strdup(buf);
                          break;  /* filename not used, ok */
                      }
                  } else {        /* do not test if filename already used */
                      free(*filename);
                      *filename = strdup(buf);
                      break;      /* filename ok */
                  }
              }
          }
      }
}

void FlScanFillInGeometries(Fl_Browser *o) {
  if (o) {
      o->add("... be Full Size",(void*)0);
      o->add("... fit in  400x 400",(void*)400);
      o->add("... fit in  512x 512",(void*)512);
      o->add("... fit in  700x 700",(void*)700);
      o->add("... fit in  912x 912",(void*)912);
      o->add("... fit in 1024x1024",(void*)1024);
  }
}

void FlScanSaveSettings(void) {
  #if 0 /* TODO */
  char cfgfile[1024];
  FILE *pfcfg;
  
        cfgfile = FlScanGetCurrentConfigFileName();
        fl_filename_expand(cfgfile,"~/.sane");
        mkdir(cfgfile,0777);
        fl_filename_expand(cfgfile,"~/.sane/flscan-sane.cfg");
        mkdir(cfgfile,0777);
        strcat(cfgfile,"/global_settings");
        if (cfgfile && cfgfile[0]!='\0' && (pfcfg=fopen(cfgfile,"wb"))) {
            // save settings
            fclose(pfcfg);
        }
  #endif
}

void FlScanLoadSettings(void) {
  #if 0 /* TODO */
  char cfgfile[1024];
  FILE *pfcfg;
  
        cfgfile = FlScanGetCurrentConfigFileName();
        fl_filename_expand(cfgfile,"~/.sane/flscan-sane.cfg/global_settings");
        if (cfgfile && cfgfile[0]!='\0' && (pfcfg=fopen(cfgfile,"rb"))) {
            // load settings
            fclose(pfcfg);
        }
  #endif
}

void FlScanUpdateDirectory(void) {
  char *pathname = new char[strlen(FlScanFileBrowser->directory())+3];
      if (pathname) {
          sprintf(pathname,"%s/.",FlScanFileBrowser->directory());
          FlScanFileBrowser->load(pathname);
      }
}

void FlScanChangeDirectory() {
  const char *item = FlScanFileBrowser->text(FlScanFileBrowser->value());
  if (item) {
      char *pathname = new char[strlen(FlScanFileBrowser->directory())+1+strlen(item)+1];
      if (pathname) {
          sprintf(pathname,"%s/%s",FlScanFileBrowser->directory(),item);
          if (fl_filename_isdir(pathname))  {
              FlScanFileBrowser->load(pathname);
          } else {
              FlScanShowImage(pathname);
          }
      }
  }
}

void FlScanShowImage(char *pname) {
  char *pathname;
  
      pathname=pname;
      if (strrchr(pname,'/') == NULL ){
          char* cur_dir = new char[1024];
          if ((getcwd(cur_dir,sizeof(cur_dir)))==NULL) return;
          char *path_name = new char[strlen(cur_dir)+1+strlen(pname)+3];
          sprintf(path_name,"%s/%s",cur_dir,pname);
          pathname=path_name;
      }  
      char *ext = strrchr(pathname, '.');
      if (ext) {
          if (strcmp(ext,".jpg") == 0 || strcmp (ext,".JPG") == 0 ||
          strcmp (ext,".jpeg") == 0 || strcmp (ext,".JPEG") == 0 ) {
              readJPEG(pathname,FlScanReadImageCB);
          } else if (strcmp(ext,".png")==0 || strcmp(ext,".PNG")==0) {
              readPNG(pathname,FlScanReadImageCB);
          }
      }
}

bool FlScanReadImageCB(unsigned char *row,int w,int d,int c,int m) {
  static int started=0;
  static int frame=-1;
  
      switch (m) {
          case 0:
              frame=(c==0)?Image_Stream::FRAME_GRAY:Image_Stream::FRAME_RGB;
              FlScanUpdateProgress (
                   (frame==Image_Stream::FRAME_GRAY)?"Receiving GRAY data":
                   (frame==Image_Stream::FRAME_RGB)?"Receiving RGB data":
                   (frame==Image_Stream::FRAME_RED)?"Receiving RED data":
                   (frame==Image_Stream::FRAME_GREEN)?"Receiving GREEN data":
                   (frame==Image_Stream::FRAME_BLUE)?"Receiving BLUE data":"Receiving data",
                   false
              );
              if (!started) {
                  FlScanViewArea->begin(w,d,(frame!=SANE_FRAME_GRAY));
              } else {
                  FlScanViewArea->rewind();
              }
              started=1;
              break;
          case 2:
              started=0;
              FlScanUpdateProgress("Updating Preview Window",false);
              FlScanViewArea->end();
              FlScanSwViewArea->position(0,0);
              FlScanSwViewArea->redraw();
              FlScanUpdateProgress("",false);
              break;
          case 1:
              if (frame>=0) {
                  FlScanUpdateProgress(0,true);
                  FlScanViewArea->add_row_data(row,d,frame);
              }
              break;
          case -1:
              started=0;
              FlScanUpdateProgress("ERROR",false);
              FlScanViewArea->reset();
              break;
      }
      return true;
}

bool FlScanCheckForImagesNotSaved() {
  bool allSaved=true;
  const char *pStrProgress;
  int exit=0;
  
      for (
          int i=0;
          (pStrProgress=FlScanConversionArea->get_value(i,2));
          i++
      ) {
          if (strcmp(pStrProgress,"Completed")) {
              allSaved=false;
              break;
          }
      }
      if (!allSaved) {
          // Show conversion area
          FlScanTabs->push(0);
          FlScanTabs->value(FlScanTabConversion);
          FlScanTabs->do_callback();
          fl_message_font(FL_HELVETICA_BOLD,12);
          exit=fl_choice (
              "There are still some images in saving progress",
              "Don't Exit",
              "Wait",
              "Exit Now"
          );
          if (exit==2) {
              allSaved=true;
          } else if (exit==1) {
              FlScanEeWaitForSaving->set_visible();
              new ImageSavingMonitor();
          }
      }
      return allSaved;
}

static void cb_OK(Fl_Return_Button* o, void*) {
  ((Fl_Window*)(o->parent()))->hide();
}

Fl_Double_Window* make_copyright_window(const char *copyright) {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(350, 350, gettext("FlScan Copyright"));
    w = o; if (w) {/* empty */}
    { Fl_Return_Button* o = new Fl_Return_Button(5, 320, 340, 25, gettext("OK"));
      o->labelfont(1);
      o->callback((Fl_Callback*)cb_OK);
    } // Fl_Return_Button* o
    { Fl_Help_View* o = new Fl_Help_View(5, 5, 340, 310);
      o->box(FL_THIN_DOWN_BOX);
      o->value(copyright);
    } // Fl_Help_View* o
    Fl_RGB_Image rgb_sane((const Fl_Pixmap*)image_sane());o->icon(&rgb_sane);
    o->set_modal();
    o->end();
  } // Fl_Double_Window* o
  return w;
}

Fl_Double_Window *wDevList=(Fl_Double_Window *)0;

static void cb_OK1(Fl_Return_Button* o, void*) {
  ((Fl_Window*)(o->parent()))->hide();
}

Fl_Browser *lsDevList=(Fl_Browser *)0;

void FlScanDeviceSelection(void) {
  { wDevList = new Fl_Double_Window(350, 155, gettext("Device Selection"));
    { Fl_Return_Button* o = new Fl_Return_Button(5, 125, 340, 25, gettext("OK"));
      o->labelfont(1);
      o->callback((Fl_Callback*)cb_OK1);
    } // Fl_Return_Button* o
    { lsDevList = new Fl_Browser(5, 20, 340, 100, gettext("Choose the device from the below list:"));
      lsDevList->type(2);
      lsDevList->labelfont(1);
      lsDevList->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      lsDevList->when(3);
    } // Fl_Browser* lsDevList
    Fl_RGB_Image rgb_sane((const Fl_Pixmap*)image_sane());wDevList->icon(&rgb_sane);
    wDevList->set_modal();
    wDevList->end();
  } // Fl_Double_Window* wDevList
  const SANE_Device *dev = 0;
  int numDev = sane->num_devices();
  char *devName = 0;
  
      if (numDev>1) {
          lsDevList->clear();
          for (int i=0; i<numDev; i++) {
              dev = sane->device(i);
              if (dev && dev->name) {
                  lsDevList->add(dev->name,(void*)dev);
              }
          }
          wDevList->position (
              Fl::x() + (Fl::w()/2 - wDevList->w()/2),
              Fl::y() + (Fl::h()/2 - wDevList->h()/2)
          );
          wDevList->show();
          while (wDevList->visible()) {
              Fl::wait();
          }
          dev = (SANE_Device*)lsDevList->data (
              lsDevList->value()
          );
      } else if (numDev>0) {
          dev = sane->device(0);
      }
      if (dev && dev->name) {
          devName = (char*)strdup(dev->name);
          sane->open(devName);
          free((void*)devName);
          FlScanLoadCurrentDevice();
      }
      delete wDevList;
      wDevList = 0;
}
