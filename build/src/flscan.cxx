// generated by Fast Light User Interface Designer (fluid) version 1.0104

#include <libintl.h>
#include "flscan.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <strings.h>
#include <FL/filename.H>
#include <FL/fl_ask.H>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include "Output_File.H"
Trigger running;
#define TEXT_TO_SLIDER 1
#define SLIDER_TO_TEXT !TEXT_TO_SLIDER
#define DECREASE_SIZE -1
#define INCREASE_SIZE -2
#define FIT_TO_SCREEN -3
#define FL_SCAN_OUTPUT_FILE_RESOLUTION -4
#define FL_SCAN_CONVERTERS_SETTINGS -3
#define FL_SCAN_HISTOGRAM -2
#define FL_SCAN_DEVICE_SELECTION -1
#define FL_SCAN_SCAN_MODE 0
#define FL_SCAN_VIEW_MODE !FL_SCAN_SCAN_MODE
static int preview_ndx=-1;
static int tl_x_ndx=-1;
static int tl_y_ndx=-1;
static int br_x_ndx=-1;
static int br_y_ndx=-1;
C_Sane *sane;
static C_Sane_Option *currentOption=0;
static SANE_Int currentOption_num=0;
static Fl_Group *lastOption=0;
static Fl_Window *copyrightWindow=0;
char *sane_host;
static char *scan_buf=0;
static Output_File FlScanOutputFile;
static int FlScanZoomFilter=Image_Stream::UNDEFINED_FILTER;

EatEvent::EatEvent(int x,int y,int w,int h,const char *l): Fl_Box(x,y,w,h,l) {
}

int EatEvent::handle(int e) {
  //
  switch (e) {
      case FL_PUSH:
      case FL_RELEASE:
          return 1;
      default:
          return 0;
  }
  return 0;
}

void ImageSavingMonitor::thread() {
  bool allSaved=false;
const char *pStrProgress;

    FL_TOGGLE_THREAD();
    while (!allSaved) {
//        Fl::wait(1);
        allSaved=true;
        for (
            int i=0;
            (pStrProgress=FlScanConversionArea->get_value(i,2));
            i++
        ) {
            if (strcmp(pStrProgress,"Completed")) {
                allSaved=false;
                break;
            }
        }
        FlScanEeWaitForSaving->redraw();
        sleep(1);
    }
    FlScanPbExit->do_callback();
    FL_TOGGLE_THREAD();
}

ImageSavingMonitor::ImageSavingMonitor() {
  #ifdef THREADED_SAVING
     create();
#else
     thread();
#endif
}

void auth_callback(SANE_String_Const domain,SANE_Char username[SANE_MAX_USERNAME_LEN],SANE_Char password[SANE_MAX_PASSWORD_LEN]) {
  printf ("Client '%s' requested authorization.\nUser:\n", domain);
    scanf ("%s", username);
    printf ("Password:\n");
    scanf ("%s", password);
}

Fl_Double_Window *FlScan=(Fl_Double_Window *)0;

Fl_Group *FlScanContainer=(Fl_Group *)0;

Fl_Tree_Browser *FlScanScannerOptions=(Fl_Tree_Browser *)0;

Fl_Group *FlScanSettings=(Fl_Group *)0;

Fl_Group *FlScanMisc=(Fl_Group *)0;

Fl_Sorted_Choice *FlScanScanFileType=(Fl_Sorted_Choice *)0;

static void cb_FlScanScanFileTypeJPEG(Fl_Menu_*, void*) {
  FlScanOutputFile.type(Output_File::JPEG);
}

static void cb_FlScanScanFileTypePNG(Fl_Menu_*, void*) {
  FlScanOutputFile.type(Output_File::PNG);
}

static void cb_FlScanScanFileTypePNM(Fl_Menu_*, void*) {
  /* FlScanOutputFile.type(Output_File::PNM); */;
}

static void cb_FlScanScanFileTypeRAW(Fl_Menu_*, void*) {
  /* FlScanOutputFile.type(Output_File::RAW);*/;
}

static void cb_FlScanScanFileTypeTIFF(Fl_Menu_*, void*) {
  /* FlScanOutputFile.type(Output_File::TIFF);*/;
}

Fl_Menu_Item menu_FlScanScanFileType[] = {
 {gettext(".jpeg"), 0,  (Fl_Callback*)cb_FlScanScanFileTypeJPEG, 0, 0, 0, 1, 12, 56},
 {gettext(".png"), 0,  (Fl_Callback*)cb_FlScanScanFileTypePNG, 0, 0, 0, 1, 12, 56},
 {gettext(".pnm"), 0,  (Fl_Callback*)cb_FlScanScanFileTypePNM, 0, 16, 0, 1, 12, 56},
 {gettext(".raw"), 0,  (Fl_Callback*)cb_FlScanScanFileTypeRAW, 0, 16, 0, 1, 12, 56},
 {gettext(".tiff"), 0,  (Fl_Callback*)cb_FlScanScanFileTypeTIFF, 0, 16, 0, 1, 12, 56},
 {0}
};

Fl_Input *FlScanTxFileName=(Fl_Input *)0;

static void cb_FlScanTxFileName(Fl_Input*, void*) {
  if (strlen(FlScanTxFileName->value())) {
    FlScanPbScan->activate();
} else {
    FlScanPbScan->deactivate();
};
}

Fl_Box *FlScanLbSeparator=(Fl_Box *)0;

Fl_Button *FlScanPbFileSelector=(Fl_Button *)0;

static void cb_FlScanPbFileSelector(Fl_Button*, void*) {
  char *outputName;

    outputName=fl_file_chooser("Save Scan As ...",FlScanOutputFile.filter(),NULL);
    if (outputName) {
        FlScanTxFileName->value(outputName);
    } else {
        FlScanTxFileName->value("");
    }
    FlScanTxFileName->do_callback();
}

#include <FL/Fl_Pixmap.H>
static const char *idata_file[] = {
"19 19 4 1",
" \tc white",
".\tc gray50",
"X\tc gray30",
"o\tc none",
"                   ",
" .................X",
" .................X",
" .XX...........XX.X",
" .XX...........XX.X",
" .................X",
" .................X",
" .................X",
" .................X",
" .................X",
" .................X",
" .................X",
" .................X",
" ....         ....X",
" .... ....    ....X",
" .... ....    ....X",
" .... ....    ....X",
"oX... ....    ....X",
"ooXXXXXXXXXXXXXXXXX"
};
static Fl_Pixmap image_file(idata_file);

Fl_Button *FlScanPbPreview=(Fl_Button *)0;

static void cb_FlScanPbPreview(Fl_Button*, void*) {
  FlScanPreviewCB(0,0,C_Sane::USER_MODE);
}

Fl_Button *FlScanPbScan=(Fl_Button *)0;

static void cb_FlScanPbScan(Fl_Button*, void*) {
  FlScanPbCancel->activate();
FlScanScanCB(0,0,C_Sane::USER_MODE);
FlScanPbCancel->deactivate();
}

Fl_Button *FlScanPbReset=(Fl_Button *)0;

static void cb_FlScanPbReset(Fl_Button*, void*) {
  FlScanSaveCurrentDevice();
sane->open(NULL); /* reopen current device */
FlScanLoadCurrentDevice();
update_tree();
}

Fl_Button *FlScanPbCancel=(Fl_Button *)0;

static void cb_FlScanPbCancel(Fl_Button*, void*) {
  sane->cancel();
}

Fl_Group *FlScanSetOption=(Fl_Group *)0;

Fl_Button *FlScanPbAutoOption=(Fl_Button *)0;

static void cb_FlScanPbAutoOption(Fl_Button*, void*) {
  FlScanSaneSetCB(true);
}

Fl_Button *FlScanPbSetOption=(Fl_Button *)0;

static void cb_FlScanPbSetOption(Fl_Button*, void*) {
  FlScanSaneSetCB(false);
FlScanPbSetOption->hide();
}

Fl_Group *FlScanBoolGroup=(Fl_Group *)0;

Fl_Light_Button *FlScanTbBoolType=(Fl_Light_Button *)0;

static void cb_FlScanTbBoolType(Fl_Light_Button*, void*) {
  FlScanSaneSetCB(false);
}

Fl_Group *FlScanFixedGroup=(Fl_Group *)0;

Fl_Input *FlScanTxFixedType=(Fl_Input *)0;

static void cb_FlScanTxFixedType(Fl_Input*, void*) {
  FlScanPbSetOption->show();
}

Fl_Group *FlScanIntGroup=(Fl_Group *)0;

Fl_Input *FlScanTxIntType=(Fl_Input *)0;

static void cb_FlScanTxIntType(Fl_Input*, void*) {
  FlScanPbSetOption->show();
}

Fl_Group *FlScanStringGroup=(Fl_Group *)0;

Fl_Input *FlScanTxStringType=(Fl_Input *)0;

static void cb_FlScanTxStringType(Fl_Input*, void*) {
  FlScanPbSetOption->show();
}

Fl_Group *FlScanButtonGroup=(Fl_Group *)0;

Fl_Button *FlScanPbButtonType=(Fl_Button *)0;

static void cb_FlScanPbButtonType(Fl_Button*, void*) {
  FlScanSaneSetCB(false);
}

Fl_Group *FlScanRangeGroup=(Fl_Group *)0;

Fl_Slider *FlScanSlRangeType=(Fl_Slider *)0;

static void cb_FlScanSlRangeType(Fl_Slider*, void*) {
  FlScanViRangeType->value(FlScanSlRangeType->value());
FlScanPbSetOption->show();
}

Fl_Value_Input *FlScanViRangeType=(Fl_Value_Input *)0;

static void cb_FlScanViRangeType(Fl_Value_Input*, void*) {
  FlScanSlRangeType->value(FlScanViRangeType->value());
FlScanPbSetOption->show();
}

Fl_Group *FlScanListGroup=(Fl_Group *)0;

Fl_Sorted_Choice *FlScanMnListType=(Fl_Sorted_Choice *)0;

Fl_Group *FlScanMessage=(Fl_Group *)0;

Fl_Group *FlScanTableGroup=(Fl_Group *)0;

Fl_RaiseButton *FlScanRbSplineTable=(Fl_RaiseButton *)0;

static void cb_FlScanRbSplineTable(Fl_RaiseButton*, void*) {
  FlScanTableGammaCurve->type(Fl_Curve::SPLINE);
}

static const char *idata_spline[] = {
"16 16 4 1",
". c None",
"B c #000000",
"+ c #BC2D2D",
"r c #FF0000",
"..............BB",
".........rrrrrrB",
".......rr.......",
".....B+.........",
"....BBB.........",
"....+B..........",
"....r...........",
"...r............",
"...r............",
"..r.............",
"..r.............",
".r..............",
".r..............",
".r..............",
"B+..............",
"BB.............."
};
static Fl_Pixmap image_spline(idata_spline);

Fl_RaiseButton *FlScanRbLinearTable=(Fl_RaiseButton *)0;

static void cb_FlScanRbLinearTable(Fl_RaiseButton*, void*) {
  FlScanTableGammaCurve->type(Fl_Curve::LINEAR);
}

static const char *idata_linear[] = {
"16 16 5 1",
". c None",
"B c #000000",
"\' c #7F7F7F",
"+ c #824141",
"r c #FF0000",
"..............BB",
"..............+B",
"..............r.",
".............r..",
".............r..",
"....\'B\'.....r...",
"....BBB.....r...",
"....+B+....r....",
"....r.r....r....",
"...r...r..r.....",
"...r...r..r.....",
"..r.....rB+.....",
"..r.....BBB.....",
".r......\'B\'.....",
"B+..............",
"BB.............."
};
static Fl_Pixmap image_linear(idata_linear);

Fl_RaiseButton *FlScanRbFreeTable=(Fl_RaiseButton *)0;

static void cb_FlScanRbFreeTable(Fl_RaiseButton*, void*) {
  FlScanTableGammaCurve->type(Fl_Curve::FREE);
}

static const char *idata_free[] = {
"16 16 2 1",
". c None",
"r c #FF0000",
"................",
"................",
"......r.........",
"......r.........",
".......r........",
".......r........",
".......r........",
"........r.......",
"........r.......",
"........r.......",
".....r...r.rrrrr",
"....r....r......",
"...r.....r......",
"..r.......r.....",
".r........r.....",
"r..............."
};
static Fl_Pixmap image_free(idata_free);

Fl_RaiseButton *FlScanPbGammaTable=(Fl_RaiseButton *)0;

static void cb_FlScanPbGammaTable(Fl_RaiseButton*, void*) {
  FlScanTableSetGamma();
}

static const char *idata_gamma[] = {
"16 16 10 1",
". c None",
"B c #000000",
"& c #171717",
"# c #2F2F2F",
"X c #464646",
"= c #5E5E5E",
"/ c #757575",
"+ c #8C8C8C",
"- c #A4A4A4",
"` c #BBBBBB",
"................",
"................",
"................",
"....B=..+B+.....",
"....X&`./&-.....",
"...../+.XX......",
"......B.B+......",
"......X.X.......",
"......X&+.......",
"......-B........",
"....../=........",
"......#B........",
"......BB........",
"......B#........",
"................",
"................"
};
static Fl_Pixmap image_gamma(idata_gamma);

Fl_Input *FlScanTxGammaTable=(Fl_Input *)0;

static void cb_FlScanTxGammaTable(Fl_Input*, void*) {
  FlScanTableSetGamma();
}

Fl_RaiseButton *FlScanPbResetTable=(Fl_RaiseButton *)0;

static void cb_FlScanPbResetTable(Fl_RaiseButton*, void*) {
  FlScanTableGammaCurve->reset();
}

static const char *idata_reset[] = {
"16 16 4 1",
". c None",
"B c #000000",
"+ c #824141",
"r c #FF0000",
"..............BB",
"..............+B",
".............r..",
"............r...",
"...........r....",
"..........r.....",
".........r......",
"........r.......",
".......r........",
"......r.........",
".....r..........",
"....r...........",
"...r............",
"..r.............",
"B+..............",
"BB.............."
};
static Fl_Pixmap image_reset(idata_reset);

Fl_Group *FlScanGroupTableType=(Fl_Group *)0;

Fl_Curve *FlScanTableGammaCurve=(Fl_Curve *)0;

static void cb_FlScanTableGammaCurve(Fl_Curve*, void*) {
  switch (FlScanTableGammaCurve->type()) {
    case Fl_Curve::FREE:
        FlScanRbFreeTable->setonly();
        break;
    case Fl_Curve::LINEAR:
        FlScanRbLinearTable->setonly();
        break;
    case Fl_Curve::SPLINE:
        FlScanRbSplineTable->setonly();
        break;
}
FlScanPbSetOption->show();
}

Fl_Group *FlScanOutputResolutions=(Fl_Group *)0;

Fl_Browser *FlScanLsOutputGeometries=(Fl_Browser *)0;

Fl_Sorted_Choice *FlScanOmZoomFilter=(Fl_Sorted_Choice *)0;

static void cb_Point(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::POINT_FILTER;
}

static void cb_Box(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::BOX_FILTER;
}

static void cb_Triangle(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::TRIANGLE_FILTER;
}

static void cb_Hermite(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::HERMITE_FILTER;
}

static void cb_Hanning(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::HANNING_FILTER;
}

static void cb_Hamming(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::HAMMING_FILTER;
}

static void cb_Blackman(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::BLACKMAN_FILTER;
}

static void cb_Gaussian(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::GAUSSIAN_FILTER;
}

static void cb_Quadratic(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::QUADRATIC_FILTER;
}

static void cb_Cubic(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::CUBIC_FILTER;
}

static void cb_Catrom(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::CATROM_FILTER;
}

static void cb_Mitchell(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::MITCHELL_FILTER;
}

static void cb_Lanczos(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::LANCZOS_FILTER;
}

static void cb_Bessel(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::BESSEL_FILTER;
}

static void cb_Sinc(Fl_Menu_*, void*) {
  FlScanZoomFilter=Image_Stream::SINC_FILTER;
}

Fl_Menu_Item menu_FlScanOmZoomFilter[] = {
 {gettext("Point"), 0,  (Fl_Callback*)cb_Point, 0, 0, 0, 1, 12, 56},
 {gettext("Box"), 0,  (Fl_Callback*)cb_Box, 0, 0, 0, 1, 12, 56},
 {gettext("Triangle"), 0,  (Fl_Callback*)cb_Triangle, 0, 0, 0, 1, 12, 56},
 {gettext("Hermite"), 0,  (Fl_Callback*)cb_Hermite, 0, 0, 0, 1, 12, 56},
 {gettext("Hanning"), 0,  (Fl_Callback*)cb_Hanning, 0, 0, 0, 1, 12, 56},
 {gettext("Hamming"), 0,  (Fl_Callback*)cb_Hamming, 0, 0, 0, 1, 12, 56},
 {gettext("Blackman"), 0,  (Fl_Callback*)cb_Blackman, 0, 0, 0, 1, 12, 56},
 {gettext("Gaussian"), 0,  (Fl_Callback*)cb_Gaussian, 0, 0, 0, 1, 12, 56},
 {gettext("Quadratic"), 0,  (Fl_Callback*)cb_Quadratic, 0, 0, 0, 1, 12, 56},
 {gettext("Cubic"), 0,  (Fl_Callback*)cb_Cubic, 0, 0, 0, 1, 12, 56},
 {gettext("Catrom"), 0,  (Fl_Callback*)cb_Catrom, 0, 0, 0, 1, 12, 56},
 {gettext("Mitchell"), 0,  (Fl_Callback*)cb_Mitchell, 0, 0, 0, 1, 12, 56},
 {gettext("Lanczos"), 0,  (Fl_Callback*)cb_Lanczos, 0, 0, 0, 1, 12, 56},
 {gettext("Bessel"), 0,  (Fl_Callback*)cb_Bessel, 0, 0, 0, 1, 12, 56},
 {gettext("Sinc"), 0,  (Fl_Callback*)cb_Sinc, 0, 0, 0, 1, 12, 56},
 {0}
};

Fl_Group *FlScanHistogram=(Fl_Group *)0;

Fl_Button *FlScanHistogramPbIntensity=(Fl_Button *)0;

static void cb_FlScanHistogramPbIntensity(Fl_Button*, void*) {
  FlScanHistogramTgIntensity->value(!FlScanHistogramTgIntensity->value());
FlScanHistogramTgIntensity->do_callback();
}

Fl_Button *FlScanHistogramPbRed=(Fl_Button *)0;

static void cb_FlScanHistogramPbRed(Fl_Button*, void*) {
  FlScanHistogramTgRed->value(!FlScanHistogramTgRed->value());
FlScanHistogramTgRed->do_callback();
}

Fl_Button *FlScanHistogramPbBlue=(Fl_Button *)0;

static void cb_FlScanHistogramPbBlue(Fl_Button*, void*) {
  FlScanHistogramTgBlue->value(!FlScanHistogramTgBlue->value());
FlScanHistogramTgBlue->do_callback();
}

Fl_Button *FlScanHistogramPbGreen=(Fl_Button *)0;

static void cb_FlScanHistogramPbGreen(Fl_Button*, void*) {
  FlScanHistogramTgGreen->value(!FlScanHistogramTgGreen->value());
FlScanHistogramTgGreen->do_callback();
}

Fl_Button *FlScanHistogramPbLog=(Fl_Button *)0;

static void cb_FlScanHistogramPbLog(Fl_Button*, void*) {
  FlScanHistogramTgLog->value(!FlScanHistogramTgLog->value());
FlScanHistogramTgLog->do_callback();
}

Fl_Button *FlScanHistogramPbPixel=(Fl_Button *)0;

static void cb_FlScanHistogramPbPixel(Fl_Button*, void*) {
  FlScanHistogramTgPixel->value(!FlScanHistogramTgPixel->value());
FlScanHistogramTgPixel->do_callback();
}

Fl_Group *FlScanHistogramCanvas=(Fl_Group *)0;

Fl_Light_Button *FlScanHistogramTgIntensity=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgIntensity(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgRed=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgRed(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgGreen=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgGreen(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgBlue=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgBlue(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgPixel=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgPixel(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Light_Button *FlScanHistogramTgLog=(Fl_Light_Button *)0;

static void cb_FlScanHistogramTgLog(Fl_Light_Button*, void*) {
  printf("toggle\n");
}

Fl_Group *FlScanSetupJPEG=(Fl_Group *)0;

Fl_Input *FlScanFFmtTxQltJPEG=(Fl_Input *)0;

static void cb_FlScanFFmtTxQltJPEG(Fl_Input*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlQltJPEG,
        FlScanFFmtTxQltJPEG,
        TEXT_TO_SLIDER
    );
}

Fl_Slider *FlScanFFmtSlQltJPEG=(Fl_Slider *)0;

static void cb_FlScanFFmtSlQltJPEG(Fl_Slider*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlQltJPEG,
        FlScanFFmtTxQltJPEG,
        SLIDER_TO_TEXT
    );
}

Fl_Input *FlScanFFmtTxSmtJPEG=(Fl_Input *)0;

static void cb_FlScanFFmtTxSmtJPEG(Fl_Input*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlSmtJPEG,
        FlScanFFmtTxSmtJPEG,
        TEXT_TO_SLIDER
    );
}

Fl_Slider *FlScanFFmtSlSmtJPEG=(Fl_Slider *)0;

static void cb_FlScanFFmtSlSmtJPEG(Fl_Slider*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlSmtJPEG,
        FlScanFFmtTxSmtJPEG,
        SLIDER_TO_TEXT
    );
}

Fl_Light_Button *FlScanFFmtTbOptJPEG=(Fl_Light_Button *)0;

Fl_Box *FlScanLbJPEGSeparator=(Fl_Box *)0;

Fl_Input *FlScanFFmtTxCompressionPNG=(Fl_Input *)0;

static void cb_FlScanFFmtTxCompressionPNG(Fl_Input*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlCompressionPNG,
        FlScanFFmtTxCompressionPNG,
        TEXT_TO_SLIDER
    );
}

Fl_Slider *FlScanFFmtSlCompressionPNG=(Fl_Slider *)0;

static void cb_FlScanFFmtSlCompressionPNG(Fl_Slider*, void*) {
  FlScanSliderGlue (
        FlScanFFmtSlCompressionPNG,
        FlScanFFmtTxCompressionPNG,
        SLIDER_TO_TEXT
    );
}

Fl_Group *FlScanSaneLogo=(Fl_Group *)0;

static const char *idata_sane[] = {
"116 124 63 1",
" \tc none",
"X\tc #EFBEEFBEEFBE",
"o\tc #CF3CBEFBA699",
"O\tc #DF7DD75CC71B",
"+\tc #F7DEEBADD75C",
"@\tc #EFBEDF7DCF3C",
"#\tc #DF7DDF7DD75C",
"$\tc #D75CCF3CB6DA",
"%\tc #CF3CCB2BA699",
"&\tc #BEFBB6DA9E79",
"*\tc #C71BA6998E38",
"=\tc #AEBAA6999E79",
"-\tc #CF3CC30B8E38",
";\tc #D75CCF3CA699",
":\tc #DF7DCB2B9E79",
">\tc #D75CC30B9658",
",\tc #E79DD75CB6DA",
"<\tc #CF3CD34C9658",
"1\tc #CF3CBAEA9658",
"2\tc #AEBAAEBA8E38",
"3\tc #CF3CB2CA8E38",
"4\tc #AEBAAAAA8617",
"5\tc #B6DA9E798617",
"6\tc #9E799E7979E7",
"7\tc #CF3CC30B9658",
"8\tc #CF3CC30B9E79",
"9\tc #CF3CBAEA9E79",
"0\tc #CF3CAEBA9658",
"q\tc #AEBA9A6979E7",
"w\tc #BEFBBAEA9658",
"e\tc #BEFBC30B9658",
"r\tc #BEFBBEFB8E38",
"t\tc #C71BB2CA9658",
"y\tc #CF3CB6DA8E38",
"u\tc #BEFBAAAA79E7",
"i\tc #D75CB2CA9658",
"p\tc #C71BB2CA79E7",
"a\tc #C71BB2CA8E38",
"s\tc #B6DAB6DA79E7",
"d\tc #BEFBA2898E38",
"f\tc #B6DABAEA8617",
"g\tc #BEFBBEFBBEFB",
"h\tc #CF3CB2CA9E79",
"j\tc #BEFBAAAA8E38",
"k\tc #B6DA9E7979E7",
"l\tc #9E798E386185",
"z\tc #8E3882076185",
"x\tc #AEBAAAAA71C6",
"c\tc #8E38820779E7",
"v\tc #71C669A65144",
"b\tc #49245144C71B",
"n\tc #79E779E75965",
"m\tc #59654D3430C2",
"M\tc #61855D755144",
"N\tc #30C234D35965",
"B\tc #30C230C228A2",
"V\tc #208120811040",
"C\tc #104010400820",
"Z\tc #000004100000",
"A\tc #B6DAC30BFFFF",
"S\tc #10401C71D75C",
"D\tc #596571C6FFFF",
"F\tc #38E34924FFFF",
"                                                                             \
                                       ",
"                                                                             \
                                       ",
"                                                                             \
                                       ",
"                                                 XoOO++@++@#@@@++#O@$O%&     \
                                       ",
"                                      +XXXX&*=-;$;;;:;O>%,$;<;,O:%-12=34o%56X\
#X                                     ",
"                                 +;#@@%o:7:$:,<<::$O$,;%$,$$:<$:o;89<o0-oo<<<\
q*#%o                                  ",
"                            OX$w,,$,O;O,@$:,;,;8:8o8%;<o:9e88:%:o0889or0to99;\
:o=y*uw#O                              ",
"                       X $$O&:O@$,+,$;o%<,%<;e00<*i=w>99e>:10p0&o989-5*8q0a0%\
88ooo80669oX                           ",
"                     X+O<,;:,,$:;;:;%077::%%>9sddf*ft8w08ii1qd-9<888ifqttff&:\
39888itat7t=qOg                        ",
"                  XX+O,,@$:;<$o18hp*s*i9<i1%ji=eiks0>uuw*4kdp0hihh>*-i7wkfp-*\
phadudp&>oosolz2#X                     ",
"                X$%O@:,+$$<%&>oif3=qdtr04rhoks8&e-0ro9tss04*sypsfp8qs98f-3eie\
w2f0quw3aaf&7ykdpz&#                   ",
"              X@,O@;O,e,:e91o0804x0uwaf4pa5dsf87*9f8>ojjqyq=p=puy4jja970w4i8>\
yuxs2as=adpj5318-wlceX                 ",
"            #O@@OO:os98198h9817=yx2658>f*4jqq*9ye*a9w*eaq0qqiwfa2*qq49prir&1f\
1&qdqqi1rtjpk549r1euql&X               ",
"           g$$@O;;::d933<1r>**f1as5skw*r7w:sty=%pe>32y00fx4x4wjie:dar*8ej:y4s\
t1fx4xptu&e>2t-*:9s:=qzl0+             ",
"          @O+;$,>%::r9o898988<0251s=uxo10<9-w>3o898<7ysxs0adx19yooy0>89889o<e\
jxs0adxw-0o%w3>-99<9o8=qzvbX           ",
"        #OO;$:o:>8o1yf790897;;8ap56pd-1<098hft<0ei0;;>ttd61xai77h9yfte3h81::8\
0au6wx*88811i2h89991::>0qlvcO          ",
"       ##@,$e:08<08w4=woyjy9%31&rudky*h<oh<51f>rq3&:=ww*4=qjsto99o*jt9<*s9o70\
wfx*q=s*<9y<**so9948>7=1aq6nm2         ",
"      #@+O,<*dyd899&k1h9-ah98dss*w1cl4lq*%34j:&zse88uu2p*7xkeas1>&40:09wp9&0f\
ufw-4ke*fi97sho3w=1h8wssjs*6zv*        ",
"     #+@,,:ipjq04p8i8ry80-u0->0xi91llnzln2&7fi2c0p0r%3qeyhs*qd3x<iofwriywpw7w\
x-w0s=k4aqe98uhr7ar*wi>u8eh46lMnO      ",
"    #+X+$<8*4tdx=qetrt88&pks*o<he8p5jju*lnx9j:xqpqs0eo9a9fktf4*ufy1f>8edsj3-<\
&h:0q*f2p4j0--99>audre793i-k5qzMmO     ",
"    +XX,$:7tjs0fs&7*aafsp*5w-9ee&3&p20jsi2n6y6l*s4j9:weew3wq3s4=82aua*st60>he\
e8y8y4sf=y>d=s3s*r5r>8&87e0rx*knNmO    ",
"   +++O><df-riuua97sha2qxpwty&jo*4e3>f5awilznzq6*rr3*fwiqp*axqpuh4t5kqqx7=yi5\
e34hriaurj<*p&kkcuriyy=ehq9yiszvMmN    ",
"  XO+,ohw04t>wte31oysq7xjau35p=t=x*%st-j19>5vqs4u5qkx6qklxf5q4qkxd66dqq55p4xp\
*a4y%ef&e197f*wy4afst5pswu4>odl5lnmb   ",
"  ++O:esxd38h1y*e8hfpq*5qetjprfkdf8hwas3>fr5nzql66cnznvvMvvnvvvnnnnvnnnqqkq5d\
x5ue0&e*s7iwsu55xri=sf34k4e1rcqafzmB#  ",
" ##+,<s1u5xs9s=w&s*9isq5q*>fw*rd6qs-sutdx4ucvnvMvMNmmBBBBVVVVVVVVBVBmmNMllzlq\
cqqs-f=fieu&hfquq2<0*-uwkufyclfatcvBn  ",
" XO@;e9;*d<r8o->e*sjss*p4ur3s8<i=%5siq5lzzvmmmBVCZVVVVVCmg&g=gg&gggzVBBmBBmvz\
c6su=;teoe*rssy4x5sedioej%iz2&ee*qnmVg ",
" g,O,1oo8y0890:&o%<3dfusaxwiw&iy5x4lzlnMMBVCZZBMNNg XXXX                czcNm\
vvzkud>98;<1df4=tx*88h88y0q4>889oilMC6 ",
"X+@,,oh<af=>ra0h<:9-ask5s*y>yffqlznvmBCZZVCcg=#                            #O\
nMNvlq4i9;9>fpqx4*38o9h8t6q13&18<i4mBB ",
"%,@:%:iaq3388t*97tdy=fykq=pr5kcnMBVCZZNMb                                    \
  &Mvlzk>ejy120sqsf*89874cq88*a88plvBCX",
"#$O:9auclw0e0r*7&8turd%uqwk6zvmVCCVM#g                                       \
   X&nn6*8edsjt-5kwu4ri*lnkiw-ie=1kzBVX",
"@+;sxncw>ire1yfdf-8d1885rqzvBVZZNg                                           \
      %q4i<-*oij4y6=fxd6qnt:yos0f8wnmC=",
"$wwncu1920i%7=k471<880f4q6vBZVc#X                                            \
       +y<@;89is5sixt44w46%w9xxw&<iqMZN",
"@w24*r8u*sp5x*sf881yo1fjdnBZB                                                \
        O$@%e&rffad2*eysj2fqdpjyi9*uNCN",
"++,<8=8ry=tuq5t012aiek-wuvCN                                                 \
        #,,:okje8>sfy&1y0=rqq=-0s4*6MZN",
"##,:1887sf51kwasup2faxf94vCg                                                 \
       XOOOra0s9>fw0r9op2k8s*rjsjsdlvCN",
",O,>o89iaux4ls>y2tu2ku*yqnVB                                                 \
       X@@:8qqs8r9*s18h=3qs6ky8ps*5lMZN",
"X@$$>jsf>w5sqqf0pe13q-sr*zmm                                                 \
      X@@@i<2jjdees:a2de9j54queuywy6MZN",
" @,O%e1f45-*juxw&y8<*y>w7qvVb                                                \
     X,+@$;;yi:7h8e8oe94xshsdxhr=>:xMZN",
" %@,:::8jt5q&43i<7980f>8ajlMm#                                               \
    XOO@O;o7&fa819>0::o0*sq=fuio7=&kMZN",
" $;$,;7h7xpqusf1ohohsf08rfqzmN                                               \
 X+O,O;:;e&>ysfo30r9:i&1r*kqdpto0y&cMZN",
" +:,$>pu=*3-ku9uw889ke%1iudqvm=                                              \
@;fykcccqkqs6d1t9rji8wds*s>dqwdrw8pnBZN",
" Ot$:7ojje*wxuk0du>>1a3-&y34zvm=                                             \
  $$6mMmmv66lk4=*-3wy89q7f-ds5u*2i1nmZN",
"  ;::;o<y8-d5wxqyqwa&he%trkpq6nB6                                            \
     #XcvMBMvzqx4skdrf>1h>&xy*4u52unVZ#",
"  %e:;$e8&wyqu&s*t-fs=1y04kdewcvMX                                           \
         Xg2mMmnlc66h>e<81-=qp&4u&lvVZX",
"  Xw$:%*<0p9eixjs8060f4qxj1-tp2lvM*                                          \
             Ozvmvzqqa=ei2iy8tle5>lmCZX",
"   $-:e*8s5ho0t-=98-jswx5ss32u*kzvMX                                         \
               X=Nmnllq2fxu<iytyt=6NZc ",
"   X89<14=sw>wtwy>8r5xjxfys*fssk6zzM&                                        \
                  6Mmn66q*j9ej0ri4nBZ= ",
"    %<78qk=-re3f9y*7h2uqqr>ss=4kq6lzN&                                       \
                   ##6Mnz6fe*efrwqvZBX ",
"    oi:,ta858ejo&s3=yfp5qqwpho>su0qczm&                                      \
                      #nvqxd<*-h5zmZN  ",
"    Xy$,:9o89ho8<<03qjrwpky%y1oet19pqcv&X                                    \
                       Xon6u0o8oinBZg  ",
"     $e:>90o319h<%<-sdq4*sio9h8wu2y46zvmN#                                   \
                         $2l491y2MCZ#  ",
"     X-:&e987yjho&=1wuax=s*e9a8fx6qlvNBBZC#                                  \
                           j6df0lBZc   ",
"      $8te<8hea-0eu2p41fl=pdr*2cznMBVZZZccg                              ###+\
+OOg                        260svCC#   ",
"       ;<iooyw=yr8oj1etxp2qjl5zvNVVZBNOX                 X+#XX++##+      X #@\
$<;$;of6XOX                  =6kmZN    ",
"       +a8%<:ax4-h<>0-1q4kkcnvmVZZC=X               X&$O+$8o1-o:%02$gwX      \
X;e;,,%10xog#                OnzBZ#    ",
"        oh89=yd*8>7f>f145czMmVZCMX              ++ooO;;;%,<$o:%,O;,7wa*x2+OX \
  X0qs=:;;<*7qoOX             $lVc     ",
"         jtp4ue31s=-%l5x6vmVZZM#            AXO+$:O,+$;,<e91<;:<>o:9>o>:5s6*g\
    #snj%::9:uqq6$             vB#     ",
"         $4>f9323q=4pqzzNBZCM#            #+o$@+,@,$:,:w9hjh99tjth8tw8>0o9ipd\
q$    ol6d*7y%siwckO           nz      ",
"          ;qu17r=sdllvmBZZM#           Xg@$:;O@$:<o<$e**41ls8st3su2kw:e8iw<7t\
qzcgX  #llk4ufw:jr5zqOX        XX      ",
"          Xq4p%w5sqzMBCZVc           ++:O,@>::::io79j8o0x5kq9i4yf0q2**9fe09rt\
iuzznX   $z54qar87j=qzlg               ",
"           #qd1exqzNVCCbX          #g;@@@+O<;%e:18>&tjs41=jq5ayw<otpow87w<hrs\
ssulzn+   gkuj<w8oe>&2zn=#             ",
"            &6p=lvmCZN           +%@,@OO:$;008i&&*k9<94x4qdq4shfh>ff=%yh>1oo>\
t5ac6vn&   %zki8oho9o<ulnMO            ",
"             qqcvVZCO          #$;$;;;;;-t34lk2klzlx46k6llc6xku46dqqqfusfa>8w\
8p4qqlzm=   &ndo&8y9%88*qnMgX          ",
"             OnvVZc#         #O@@,;ijjqq66cvnnnvNMnvvvMvvvMMvvnnzznzz66cl5d66\
5kxpql6vvX   %68193oo*jp5qcmn          ",
"              gBBc         #$+@,;w5nvvMNNmmBBBBBCVVVVVCVVVVVVVBBBmBmNNmmvnzzz\
zlcxqq6zmM#   $6t890-<*us5xzNnX        ",
"               gX         @@@OeqnMBVVCCVBVBVVBCNOgggggogggggggggoBBBBNNNmVBBm\
MnnznlzznBc    Of1-=38ia9>4lzmv        ",
"                        XO;8qnmVCZNnMMNo                                #vccc\
mBBBmNvnvmB=    wdd18ooo9eaqlnNv       ",
"                      +g9qvvMBc#ggX                 X #2oosczOX#             \
#OOONNMVMmBN    #5w7ooho9p&ujqvmn      ",
"                     Xpc%gz+                      O@&o@,;,7kcqqcgg           \
      #bnBBC=    gu>80fpeq-7iqcnmO     ",
"                    X$ +                        #;%:,,:es=f2x0:9klzOX        \
        X#=Bz     &98ewutu*i73qzMBO    ",
"                                               g%++;s4zvvMMzzl4-%hqMcg       \
           #c     #s><ywxxfi*ydqzmN    ",
"                                             Ow,O$4nmVVVCVBVBmvzcj95vBg      \
                   o-;ooq1wpor-&cmB=   ",
"                                            #o@OpzBCCBNSSSSSSNNmzl6d5zNO     \
                   X%,,;a8>9i889fcBNX  ",
"                                           #g@$qmCCNSbDDbbbbFDSSNNnkqqlmg    \
                    O:,:8*8e=>h9:jvVM  ",
"                                          +w+;lBCBSSSSFDFSbSFFSFSSNnq5qvBg   \
                    X>@;ts9earpo8kzBN  ",
"                                          O+$qBZNbSSSSFDFbFFDFSFSSSNzuqqvBX  \
                    XOO;s-9892a87qzmV& ",
"                                         O,+fBZNbFSbSSFDFFFFDFbFSSFbSzf*lmc  \
                     @@,%8y13-0*yolMBN ",
"                                         ++$MCNSSFbbbSSDDFFFDFFSSFFSSN6%qvVg \
                     $;@8888954*y<=zBCX",
"                                        XX+6VBSSSbFFSFSDAFFDDFFSFFbSSSNs:cmN \
                     $$,oe0rw0qp%ircMCc",
"                                        O+&mZNSSSSFDFbSFADDADFbbFSSSbbSc:sMB=\
                      @;$efqkseiwf34MCM",
"                                       $,O6ZNFSSSbbFDFFFAAAAADFDFSSSFFDc>:zVn\
                      +@:tp2u*stskpqnVM",
"                                       O@$MZSFFFSSbSFADDAAAAADADSSFDDDDb2<*mB\
#                     +Oo3fu41f2*auqvBV",
"                       #X             #w+2VZSSbFFFbbFAAAA   AAADDDAADDFbc,ovZ\
g                     +@gy246r:drj4qvBZ",
"                    go4&              X$+5VNbSSbFFDFDAA     A AAAAADFbFSb,$nB\
#                     @,$7p25jr=a8%4zmZ",
"               X+#e%vn*               X@@cVNSSbbFFFDAAA       A ADDFFFDDb$@yM\
b                    #+Oo959kdfoy78izmZ",
"            X +#$:6NNX                 +,mZNSSSSFbFDAA         AAADDDFFFbo+;z\
m                     +@1rqdpshoo0ofzNZ",
"           X$%,,fmC&                   #emCSSSSSbbFDAA          AAADDDDFbg+:z\
M                    +@,:uekdyf&>yi2zmZ",
"         XO@;$rvCM#                   XewMCSbbbbFbFDAX         AADDDDDDFbg+ov\
N                   X@+:<*od4pf*y19kzNZ",
"        X++@;qNZN                     X02vCNSSbbDDAAAX        AAAAFFbSSSSg@2m\
V                   +++%78h4=*q&qr8hzmZ",
"      XX@+@:zmZN                      #s0vVNFFDDDDDDAA        AADFFFFFFSb$@lC\
=                  #+++:1<yqxr0x*uyuzmZ",
"     X+X++:kmZN                       +s$qBNFFFFFbSFAAA    XA AAAFbSSbFSb@$vZ\
g                  @X+O>8&&1*rkaqp*knBZ",
"    X@@#@%svCV                        #j,wmBSbbSSFDDDDAXAA AAAAADFDFSSSSb+%mZ\
O                 X+@$ioix=->0stc6wqvVZ",
"   +O@@$<=zmZb                         $;;zVNSSSFFFFFAAAAA ADAADDFFFFSSSg,qCB\
                 X@+,78*w3do1p&>5coqMZB",
"  X$+@;7*lnBZ#                         O$:qBNSbFFFFbDDDDAAAASFADFDFSbFSb+$nZM\
                #O++$<d34ut7f8xt:6znmZN",
"  XX@O%>4lzVN                           4%7zBNFbbbbDFFFFDDAAbSFDFFDFSSSgX=BZO\
               #%,+Oo1144-d1e0eh&xzvBZM",
"  O+@,o;w5zBC#                          6t>qMBSbSSFFFFFFFFDDFSSFDSFFFSb@;nZN \
              X:+O$<77;:de-0>188&dqMVZX",
" +$+O:87e6cNV#                           %oalmNSSbFFFSbFFFDDFSSbDFSFSb@$qBZg \
             XO@@;:>oh7oat81w890<8lmZCX",
" XO@@:187kqnB=                           g4:=nmNbFFbbbbFFFFDFSSSFDbSbg@&mZN  \
           X++O$:o88o998f*eepyy9>5vBZ= ",
" +$,;<9oquuqvB=                           v2f2zNNSSFSSFSbFFFFSSSSFbb,+<vCC#  \
          X#OO,$e00t>98y41>9<2p>2zmZB  ",
" X$::9<1*e*qlvmw                          +zq85lvNSSSFFSbFFFFSSSSSb,+>vCC#   \
        #OO@@$;<*xr=uy8yp0fe3efdkvVZb  ",
" Oy;%u=oyfe7fznvoX                         Xcqqj5nvNSSSSSbFFFSSSbg++$MCC#    \
       X#@+O,;:df9ks=4eiy1e8w5u6nmZVX  ",
" Xo;:889fs10-5clnqg                         Xzl6jauqnMNSSSSbbbboX+,2MCC#     \
     #$$++@O$891kswjx3wrf*93-26cMCC#   ",
"  O0o882ttskqsd0f5llcO                       #Mz664=<ijpk*0e>$@@$fcmZC#      \
   X;O,@OO;<:1t&wiu4teid72kq4qzvVZM    ",
"   8;o>erjsjlsfy04czqz=&                      #2Mv6l*>8o<<&>;;icnmCZc#       \
XOOO:,$;$7=teuse7rw*f8<3sdrqqkvVZN     ",
"   Oy;$8s5xwxt*p4z**f*rai*w#O                   XbNmvzcq0-s5cvNVCZB=      X#X\
O;$O;;<o=jaudyj1>s1-w9itqu*4cvBZC      ",
"   Xi:ihofqkkq:t6l4fq50:-9-y4%o4#XX               #cmvmvnzmVVZVCcgX   X o$@$@\
@,$:y0oo3sffqkfwh9sa1e*1*46lvBCZ=      ",
"    Ok=&y7*squ=ez2;e58e&<&o<>u1w0s5w#Oo#              =c2&2ccMg    $Xg$+O+O;:\
#<<0*5y0*88-2f1x<90<i5stwqlMBCZ=       ",
"     %yaw*wjf5u=l=:;rio&oooo%:8*r97yufu<$:;=w#XXXXX           $o$@O%,@@+@@O@:\
&=9s32xte3o:ito1e:o98ey4llvBZZ=        ",
"     #q*4a5xau-oc5991fi8hh88;;<h>s*&3<;;oe:-w:%e:%:OO$>ewye8>;O,$,$,$,:;,:$:;\
-fdq0u=-o809r*38*w1yooiqzmVZZ=         ",
"      #lq45fksj>e2:&uy198*0oe1e0ypfs&h%,;:$:e:,,::;O$::$oo<%,;@O;@::;,:>7::e&\
y74aqut0899:42&oyrdi9a6vmVZNX          ",
"       +zzqrkkeu&>8eqe18ir088jjtu=-k58*99;808:o:<:;::oe;<;08ooe:;8099%1e3999f\
ts*euqf=u&>&sj1&>*4*kzMVCZN            ",
"        #466l*qr4si>iys7-iphy>jj:h02pkwito888ioeie:7o9078e*&*=8p%87y91800w*7i\
qe1i43jxyq7hwf1r0t6lvmVZCO             ",
"          &vzqqkdq=ef3>9ejxjt8oyw<j4wuufkyy=f>98fd=h><8080x*s4fd3i7f>8-uxsa7<\
-h>fq*f5jdsw0j9aqlvmBZZc#              ",
"           gzv6ckf*5a4ts*2dp-89ooa8s5ejp=ery*tt0fqt>;ho:t-a5-yfwef&p=s&2ur&o8\
9owaekw2ut844q4lnNBCZBb                ",
"            XzMvlqsqa4k6qs07390i=p11&u2a17de=pqqpw30e0>rj0-os5*y>5*e*6k2a7*10\
8wu4yeakf*yq6zvmBVZC=X                 ",
"              Ocmncqlqukqjs*sksp3q1%13hy19:uujru327q4sa34t%ejofhoej4*=2ysas4s\
23ua91k1464zvmBCZBb                    ",
"                OzMMvzlcq4*5u3254581wepwiedsksqx1afat*dx4etwyt3:hyx4suqs334*f\
5qsafx5qlnMmVZZV=X                     ",
"                  $nmmmMvcq6qquqqusaa=trur8-6u5qu:sads5qk3r*rris*ye*25q5%pp2k\
2clqkzzMNBZZZcc                        ",
"                   XX=MmVmMnll=q634shpi8skjsws5k4*=38%e*er0:0<9y4a4ju4dld5k2u\
5zzvMmBCZZBg#                          ",
"                       g=MBmmmmvnnl666qu&rkc65xuq5tdy3>us3arp*r%-5qqqq6l6qcnn\
vNBVZZZMb=                             ",
"                         XX#MMnBBBmMNvvzzcllznzzcqxk6qq6cq6qxqks6lzzvvvvMmmBV\
CZCNB=XX                               ",
"                               g=gNBBmmBBBBBmMMmMMvvvvvvvvvvMvvMMMmNBVVCCCCZN\
gbg                                    ",
"                                   XX #vnnncNCCVVVVVVVVVVVVVVVVCCCCZNMMNNg X \
                                       ",
"                                            +gggggggggggggggggogggg=X        \
                                       "
};
static Fl_Pixmap image_sane(idata_sane);

Fl_Button *showCopyright=(Fl_Button *)0;

static void cb_showCopyright(Fl_Button*, void*) {
  if (copyrightWindow) {
    copyrightWindow->show();
};
}

Fl_Group *FlScanImageSelector=(Fl_Group *)0;

FileBrowser *FlScanFileBrowser=(FileBrowser *)0;

static void cb_FlScanFileBrowser(FileBrowser*, void*) {
  FlScanChangeDirectory();
}

Fl_Progress *FlScanProgressBar=(Fl_Progress *)0;

Fl_Tabs *FlScanTabs=(Fl_Tabs *)0;

static void cb_FlScanTabs(Fl_Tabs*, void*) {
  if (FlScanTabs->value()==FlScanTabView) {
    FlScanSetMode(FL_SCAN_VIEW_MODE);
} else {
    FlScanSetMode(FL_SCAN_SCAN_MODE);
};
}

Fl_Group *FlScanTabThumbnails=(Fl_Group *)0;

static const char *idata_Thumbnails[] = {
"20 20 4 1",
" \tc none",
"X\tc gray30",
"a\tc white",
"o\tc black",
"aaaaaaaaaaaaaaaaaaaa",
"a        Xa        X",
"a        Xa        X",
"a XXXXXX Xa XXXXXX X",
"a Xooooa Xa Xooooa X",
"a Xooooa Xa Xooooa X",
"a Xaaaaa Xa Xaaaaa X",
"a        Xa        X",
"a        Xa        X",
"aXXXXXXXXXaXXXXXXXXX",
"aaaaaaaaaaaaaaaaaaaa",
"a        Xa        X",
"a        Xa        X",
"a XXXXXX Xa XXXXXX X",
"a Xooooa Xa Xooooa X",
"a Xooooa Xa Xooooa X",
"a Xaaaaa Xa Xaaaaa X",
"a        Xa        X",
"a        Xa        X",
"aXXXXXXXXXaXXXXXXXXX"
};
static Fl_Pixmap image_Thumbnails(idata_Thumbnails);

Fl_Pack *FlScanThumbsRows=(Fl_Pack *)0;

Fl_Group *FlScanTabPreview=(Fl_Group *)0;

static const char *idata_Preview[] = {
"19 19 4 1",
" \tc none",
"X\tc gray30",
"a\tc white",
"o\tc black",
"aaaaaaaaaaaaaaaaaaa",
"a                 X",
"a                 X",
"a                 X",
"a                 X",
"a  XXXXXXXXXXXXX  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xoooooooooooa  X",
"a  Xaaaaaaaaaaaa  X",
"a                 X",
"a                 X",
"a                 X",
"a                 X",
"aXXXXXXXXXXXXXXXXXX"
};
static Fl_Pixmap image_Preview(idata_Preview);

Fl_Image_Preview *FlScanPreviewArea=(Fl_Image_Preview *)0;

static void cb_FlScanPreviewArea(Fl_Image_Preview*, void*) {
  FlScanUpdateSelection();
}

Fl_Group *FlScanTabConversion=(Fl_Group *)0;

Conversions_List *FlScanConversionArea=(Conversions_List *)0;

Fl_Group *FlScanTabView=(Fl_Group *)0;

static const char *idata_Acquire[] = {
"20 14 4 1",
" \tc None",
".\tc black",
"X\tc white",
"o\tc gray50",
"       ........     ",
"      .XXXXXXXX.    ",
" .....Xo.....oX.... ",
".XXXXX.........XXXX.",
"........ooooo.......",
".Xooo..oXXXooo..ooo.",
".Xooo..oXooooo..ooo.",
".Xooo..oXooooo..ooo.",
".Xooo..ooooooo..ooo.",
".Xooo..ooooooo..ooo.",
".Xoooo..ooooo..oooo.",
".Xoooo.........oooo.",
".Xoooooo.....oooooo.",
" .................. "
};
static Fl_Pixmap image_Acquire(idata_Acquire);

Fl_Scrolled_Image *FlScanSwViewArea=(Fl_Scrolled_Image *)0;

Fl_Image_View *FlScanViewArea=(Fl_Image_View *)0;

Fl_Group *FlScanToolBar=(Fl_Group *)0;

Fl_Group *FlScanPreviewTools=(Fl_Group *)0;

Fl_RaiseButton *FlScanThumbnailsRotateCCW=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsRotateCCW(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->rotate_cw();
}

static const char *idata_rotate_cw90[] = {
"19 19 2 1",
" \tnone",
".\tc black",
"                 ..",
"            .      ",
"            ..   ..",
"          .....  ..",
"        ........ ..",
"      .........  ..",
"     .....  ..     ",
"    ....    .    ..",
"   ....          ..",
"   ...           ..",
"  ....           ..",
"  ...              ",
" ....            ..",
" ...             ..",
" ...             ..",
" ...             ..",
"                   ",
"...................",
"..................."
};
static Fl_Pixmap image_rotate_cw90(idata_rotate_cw90);

Fl_RaiseButton *FlScanThumbnailsRotateCW=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsRotateCW(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->rotate_ccw();
}

static const char *idata_rotate_ccw90[] = {
"19 19 2 1",
" \tc black",
".\tnone",
"  .................",
"...... ............",
"  ...  ............",
"  ..     ..........",
"  .        ........",
"  ..         ......",
".....  ..     .....",
"  .... ....    ....",
"  ..........    ...",
"  ...........   ...",
"  ...........    ..",
"..............   ..",
"  ............    .",
"  .............   .",
"  .............   .",
"  .............   .",
"...................",
"                   ",
"                   "
};
static Fl_Pixmap image_rotate_ccw90(idata_rotate_ccw90);

Fl_RaiseButton *FlScanThumbnailsSetHorizont=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsSetHorizont(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->set_horizont(FlScanThumbnailsSetHorizont->value(),FlScanThumbnailsSetHorizont);
}

static const char *idata_set_horizont[] = {
"19 19 5 1",
" \tc gray80",
".\tc black",
"X\tnone",
"o\tc gray40",
"b\tc gray20",
"                   ",
"       .....       ",
"       .X.X.       ",
"       .X.X.       ",
"      .......      ",
"      .X.X.X.      ",
"      .X.X.X.      ",
"      .X.X.X.      ",
"      .......      ",
"      .X.X.X.      ",
"      .X.X.X.      ",
"      .X.X.X.      ",
"      .......      ",
"      .X.X.X. ooooo",
"     o.X.X.X.oooooo",
"oooooo.X.X.X.oooooo",
"oooobbbbbbbbbbboooo",
"oooobbbbbbbbbbboooo",
"oooobbbbbbbbbbboooo"
};
static Fl_Pixmap image_set_horizont(idata_set_horizont);

Fl_RaiseButton *FlScanThumbnailsUndoRotate=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsUndoRotate(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->undo_rotate();
}

static const char *idata_undo_rotate[] = {
"19 19 2 1",
" \tnone",
".\tc #000000000000",
"                   ",
"                   ",
"       .....       ",
"     .........     ",
"    ...........    ",
"   ....     ....   ",
"   ...       ...   ",
"  ...         ...  ",
"  ...         ...  ",
"  ...         ...  ",
"  ...  .      ...  ",
"  ... ..      ...  ",
"   .....     ...   ",
"   .....    ....   ",
"   .....  .....    ",
"  ......  ....     ",
" .......  ..       ",
"                   ",
"                   "
};
static Fl_Pixmap image_undo_rotate(idata_undo_rotate);

Fl_RaiseButton *FlScanThumbnailsHorizontalMirror=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsHorizontalMirror(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->flip_horizontal();
}

static const char *idata_horizontal_mirror[] = {
"    19    19        3            1",
". c black",
"  none",
"a c white",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"   .           .   ",
"  ..           ..  ",
" ................. ",
"...................",
" ................. ",
"  ..           ..  ",
"   .           .   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   ",
"                   "
};
static Fl_Pixmap image_horizontal_mirror(idata_horizontal_mirror);

Fl_RaiseButton *FlScanThumbnailsVerticalMirror=(Fl_RaiseButton *)0;

static void cb_FlScanThumbnailsVerticalMirror(Fl_RaiseButton*, void*) {
  FlScanPreviewArea->flip_vertical();
}

static const char *idata_vertical_mirror[] = {
"    19    19        3            1",
". c black",
"  none",
"a c white",
"         .         ",
"        ...        ",
"       .....       ",
"      .......      ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"        ...        ",
"      .......      ",
"       .....       ",
"        ...        ",
"         .         "
};
static Fl_Pixmap image_vertical_mirror(idata_vertical_mirror);

Fl_RaiseButton *FlScanPreviewZoomPlus=(Fl_RaiseButton *)0;

static void cb_FlScanPreviewZoomPlus(Fl_RaiseButton*, void*) {
  FlScanResize(INCREASE_SIZE);
}

static const char *idata_zoom_in[] = {
"    19    19        3            1",
"  none",
". c black",
"a c white",
"...................",
".aaaaaaaaa.aaaaaaa.",
"...................",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
"...........       .",
".                 .",
".           .     .",
".          ...  . .",
".           ..... .",
".            .... .",
".            .... .",
".           ..... .",
".                 .",
"..................."
};
static Fl_Pixmap image_zoom_in(idata_zoom_in);

Fl_RaiseButton *FlScanPreviewZoomMinus=(Fl_RaiseButton *)0;

static void cb_FlScanPreviewZoomMinus(Fl_RaiseButton*, void*) {
  FlScanResize(DECREASE_SIZE);
}

static const char *idata_zoom_out[] = {
"    19    19        3            1",
"  none",
". c black",
"a c white",
"...................",
".aaaaaaaaa.aaaaaaa.",
"...................",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
".         .       .",
"...........       .",
".                 .",
".          .....  .",
".          ....   .",
".          ....   .",
".          .....  .",
".          .  ... .",
".              .  .",
".                 .",
"..................."
};
static Fl_Pixmap image_zoom_out(idata_zoom_out);

Fl_RaiseButton *FlScanPreviewZoomScreen=(Fl_RaiseButton *)0;

static void cb_FlScanPreviewZoomScreen(Fl_RaiseButton*, void*) {
  FlScanResize(FIT_TO_SCREEN);
}

static const char *idata_zoom_undo[] = {
"    19    19        3            1",
"  none",
". c black",
"a c white",
"         .         ",
"        ...        ",
"       .....       ",
"                   ",
"    ...........    ",
"    .aaaaaaaaa.    ",
"    ...........    ",
"  . .         . .  ",
" .. .         . .. ",
"... .         . ...",
" .. .         . .. ",
"  . .         . .  ",
"    .         .    ",
"    .         .    ",
"    ...........    ",
"                   ",
"       .....       ",
"        ...        ",
"         .         "
};
static Fl_Pixmap image_zoom_undo(idata_zoom_undo);

Fl_RaiseButton *FlScanPreviewZoomMinimize=(Fl_RaiseButton *)0;

static void cb_FlScanPreviewZoomMinimize(Fl_RaiseButton*, void*) {
  FlScanResize(0);
}

static const char *idata_zoom_mini[] = {
"    19    19        3            1",
"  none",
". c black",
"a c white",
"       .....       ",
"        ...        ",
"         .         ",
"                   ",
"    ...........    ",
"    .aaaaaaaaa.    ",
"    ...........    ",
".   .         .   .",
"..  .         .  ..",
"... .         . ...",
"..  .         .  ..",
".   .         .   .",
"    .         .    ",
"    .         .    ",
"    ...........    ",
"                   ",
"         .         ",
"        ...        ",
"       .....       "
};
static Fl_Pixmap image_zoom_mini(idata_zoom_mini);

Fl_RaiseButton *FlScanPbExit=(Fl_RaiseButton *)0;

static void cb_FlScanPbExit(Fl_RaiseButton*, void*) {
  if (FlScanCheckForImagesNotSaved()) {
    FlScanSaveSettings();
    FlScanSaveCurrentDevice();
    delete sane;
    exit(0);
};
}

static const char *idata_zoom_quit[] = {
"    19    19        4            1",
"  c none",
"X c gray30",
"q c black",
"a c white",
"  q             q  ",
" qqq           qqq ",
"qqqqq         qqqqq",
" qqqqq       qqqqq ",
"  qqqqq     qqqqq  ",
"   qqqqq   qqqqq   ",
"    qqqqq qqqqq    ",
"     qqqqqqqqq     ",
"      qqqqqqq      ",
"       qqqqq       ",
"      qqqqqqq      ",
"     qqqqqqqqq     ",
"    qqqqq qqqqq    ",
"   qqqqq   qqqqq   ",
"  qqqqq     qqqqq  ",
" qqqqq       qqqqq ",
"qqqqq         qqqqq",
" qqq           qqq ",
"  q             q  "
};
static Fl_Pixmap image_zoom_quit(idata_zoom_quit);

Fl_RaiseButton *FlScanShowCopyright=(Fl_RaiseButton *)0;

static void cb_FlScanShowCopyright(Fl_RaiseButton*, void*) {
  if (copyrightWindow) {
    copyrightWindow->show();
};
}

EatEvent *FlScanEeLockView=(EatEvent *)0;

EatEvent *FlScanEeWaitForSaving=(EatEvent *)0;

Fl_Double_Window* makeFlSCAN(bool enable_scan) {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = FlScan = new Fl_Double_Window(640, 480, gettext("Fl Scan"));
    w = o;
    { Fl_Group* o = FlScanContainer = new Fl_Group(0, 0, 640, 480);
      { Fl_Group* o = new Fl_Group(460, 0, 175, 480);
        o->box(FL_FLAT_BOX);
        { Fl_Tree_Browser* o = FlScanScannerOptions = new Fl_Tree_Browser(460, 5, 175, 200, gettext("Scanner"));
          o->tooltip(gettext("Scanner Specific Settings"));
          o->type(1);
          o->box(FL_THIN_DOWN_BOX);
          o->color(49);
          o->selection_color(49);
          o->labeltype(FL_NO_LABEL);
          o->labelfont(1);
          o->labelsize(12);
          o->labelcolor(56);
          o->textsize(12);
          o->callback((Fl_Callback*)cb_selectoption);
          o->align(FL_ALIGN_TOP);
          o->when(FL_WHEN_RELEASE);
          Fl_Group::current()->resizable(o);
        }
        { Fl_Group* o = FlScanSettings = new Fl_Group(460, 350, 175, 100);
          o->box(FL_THIN_DOWN_BOX);
          { Fl_Group* o = FlScanMisc = new Fl_Group(461, 351, 173, 98);
            o->box(FL_FLAT_BOX);
            o->labeltype(FL_NO_LABEL);
            o->align(FL_ALIGN_CENTER);
            { Fl_Sorted_Choice* o = FlScanScanFileType = new Fl_Sorted_Choice(570, 355, 60, 20);
              o->box(FL_ENGRAVED_BOX);
              o->down_box(FL_BORDER_BOX);
              o->color(7);
              o->selection_color(15);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(14);
              o->labelcolor(56);
              o->align(FL_ALIGN_LEFT);
              o->when(FL_WHEN_RELEASE);
              o->menu(menu_FlScanScanFileType);
            }
            { Fl_Input* o = FlScanTxFileName = new Fl_Input(465, 355, 105, 20);
              o->tooltip(gettext("Output file name"));
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->textfont(1);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanTxFileName);
              o->when(FL_WHEN_CHANGED);
            }
            { Fl_Box* o = FlScanLbSeparator = new Fl_Box(465, 379, 165, 2);
              o->box(FL_THIN_DOWN_FRAME);
              o->labeltype(FL_NO_LABEL);
              o->hide();
            }
            { Fl_Button* o = FlScanPbFileSelector = new Fl_Button(465, 355, 20, 20);
              o->box(FL_ENGRAVED_BOX);
              o->image(image_file);
              o->callback((Fl_Callback*)cb_FlScanPbFileSelector);
              o->hide();
            }
            { Fl_Button* o = FlScanPbPreview = new Fl_Button(465, 380, 80, 30, gettext("Preview"));
              o->box(FL_ENGRAVED_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanPbPreview);
            }
            { Fl_Button* o = FlScanPbScan = new Fl_Button(550, 380, 80, 30, gettext("Scan"));
              o->box(FL_ENGRAVED_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanPbScan);
              o->deactivate();
            }
            { Fl_Button* o = FlScanPbReset = new Fl_Button(550, 415, 80, 30, gettext("Reset"));
              o->box(FL_ENGRAVED_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanPbReset);
              o->hide();
            }
            { Fl_Button* o = FlScanPbCancel = new Fl_Button(465, 415, 80, 30, gettext("Cancel"));
              o->box(FL_ENGRAVED_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanPbCancel);
              o->deactivate();
            }
            o->end();
          }
          o->end();
        }
        { Fl_Group* o = FlScanSetOption = new Fl_Group(460, 205, 175, 145);
          o->box(FL_THIN_DOWN_BOX);
          o->labelsize(12);
          o->align(69|FL_ALIGN_INSIDE);
          { Fl_Button* o = FlScanPbAutoOption = new Fl_Button(465, 325, 80, 20, gettext("Auto"));
            o->box(FL_ENGRAVED_BOX);
            o->labelfont(1);
            o->labelsize(12);
            o->callback((Fl_Callback*)cb_FlScanPbAutoOption);
            o->hide();
          }
          { Fl_Button* o = FlScanPbSetOption = new Fl_Button(550, 325, 80, 20, gettext("Set"));
            o->box(FL_ENGRAVED_BOX);
            o->labelfont(1);
            o->labelsize(12);
            o->callback((Fl_Callback*)cb_FlScanPbSetOption);
            o->hide();
          }
          { Fl_Group* o = FlScanBoolGroup = new Fl_Group(461, 206, 173, 143);
            o->labeltype(FL_NO_LABEL);
            o->labelsize(12);
            o->align(FL_ALIGN_CLIP);
            o->hide();
            { Fl_Light_Button* o = FlScanTbBoolType = new Fl_Light_Button(461, 270, 173, 20);
              o->box(FL_NO_BOX);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanTbBoolType);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            o->end();
          }
          { Fl_Group* o = FlScanFixedGroup = new Fl_Group(461, 206, 173, 119);
            o->labeltype(FL_NO_LABEL);
            o->labelsize(12);
            o->align(FL_ALIGN_CLIP);
            o->hide();
            { Fl_Input* o = FlScanTxFixedType = new Fl_Input(535, 275, 95, 20, gettext("Real Input:"));
              o->type(1);
              o->box(FL_THIN_DOWN_BOX);
              o->labelsize(12);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanTxFixedType);
              o->when(FL_WHEN_CHANGED);
            }
            o->end();
          }
          { Fl_Group* o = FlScanIntGroup = new Fl_Group(461, 206, 173, 119);
            o->labeltype(FL_NO_LABEL);
            o->labelsize(12);
            o->align(FL_ALIGN_CLIP);
            o->hide();
            { Fl_Input* o = FlScanTxIntType = new Fl_Input(550, 275, 80, 20, gettext("Integer Input:"));
              o->type(2);
              o->box(FL_THIN_DOWN_BOX);
              o->labelsize(12);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanTxIntType);
              o->when(FL_WHEN_CHANGED);
            }
            o->end();
          }
          { Fl_Group* o = FlScanStringGroup = new Fl_Group(461, 206, 173, 119);
            o->labeltype(FL_NO_LABEL);
            o->labelsize(12);
            o->align(FL_ALIGN_CLIP);
            o->hide();
            { Fl_Input* o = FlScanTxStringType = new Fl_Input(465, 275, 165, 20, gettext("Input:"));
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelsize(12);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanTxStringType);
              o->when(FL_WHEN_CHANGED);
            }
            o->end();
          }
          { Fl_Group* o = FlScanButtonGroup = new Fl_Group(461, 206, 173, 143);
            o->labeltype(FL_NO_LABEL);
            o->labelsize(12);
            o->align(FL_ALIGN_CLIP);
            o->hide();
            { Fl_Button* o = FlScanPbButtonType = new Fl_Button(465, 260, 165, 45, gettext("Execute"));
              o->box(FL_ENGRAVED_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanPbButtonType);
            }
            o->end();
          }
          { Fl_Group* o = FlScanRangeGroup = new Fl_Group(461, 206, 173, 119);
            o->labeltype(FL_NO_LABEL);
            o->labelsize(12);
            o->align(FL_ALIGN_CLIP);
            o->hide();
            { Fl_Slider* o = FlScanSlRangeType = new Fl_Slider(520, 275, 110, 20);
              o->type(5);
              o->box(FL_THIN_DOWN_BOX);
              o->callback((Fl_Callback*)cb_FlScanSlRangeType);
            }
            { Fl_Value_Input* o = FlScanViRangeType = new Fl_Value_Input(465, 275, 55, 20);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelsize(12);
              o->textfont(1);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanViRangeType);
            }
            o->end();
          }
          { Fl_Group* o = FlScanListGroup = new Fl_Group(461, 206, 173, 143);
            o->labeltype(FL_NO_LABEL);
            o->labelsize(12);
            o->align(FL_ALIGN_CLIP);
            o->hide();
            { Fl_Sorted_Choice* o = FlScanMnListType = new Fl_Sorted_Choice(465, 275, 165, 20);
              o->box(FL_ENGRAVED_BOX);
              o->down_box(FL_BORDER_BOX);
              o->color(7);
              o->selection_color(15);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(0);
              o->labelsize(12);
              o->labelcolor(56);
              o->textsize(12);
              o->align(FL_ALIGN_LEFT);
              o->when(FL_WHEN_RELEASE);
            }
            o->end();
          }
          { Fl_Group* o = FlScanMessage = new Fl_Group(461, 220, 173, 129);
            o->box(FL_FLAT_BOX);
            o->labelsize(12);
            o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            o->hide();
            o->end();
          }
          { Fl_Group* o = FlScanTableGroup = new Fl_Group(461, 220, 173, 105);
            o->box(FL_FLAT_BOX);
            o->labelfont(1);
            o->labelsize(12);
            o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            o->hide();
            { Fl_RaiseButton* o = FlScanRbSplineTable = new Fl_RaiseButton(465, 220, 20, 20);
              o->tooltip(gettext("Spline Curve"));
              o->type(102);
              o->box(FL_FLAT_BOX);
              o->down_box(FL_THIN_DOWN_BOX);
              o->color(49);
              o->selection_color(3);
              o->image(image_spline);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(0);
              o->labelsize(14);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanRbSplineTable);
              o->align(FL_ALIGN_CENTER);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_RaiseButton* o = FlScanRbLinearTable = new Fl_RaiseButton(485, 220, 20, 20);
              o->tooltip(gettext("Linear Curve"));
              o->type(102);
              o->box(FL_FLAT_BOX);
              o->down_box(FL_THIN_DOWN_BOX);
              o->color(49);
              o->selection_color(3);
              o->image(image_linear);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(0);
              o->labelsize(14);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanRbLinearTable);
              o->align(FL_ALIGN_CENTER);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_RaiseButton* o = FlScanRbFreeTable = new Fl_RaiseButton(505, 220, 20, 20);
              o->tooltip(gettext("Free Curve"));
              o->type(102);
              o->box(FL_FLAT_BOX);
              o->down_box(FL_THIN_DOWN_BOX);
              o->color(49);
              o->selection_color(3);
              o->image(image_free);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(0);
              o->labelsize(14);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanRbFreeTable);
              o->align(FL_ALIGN_CENTER);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_Box* o = new Fl_Box(527, 220, 2, 20);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
            }
            { Fl_RaiseButton* o = FlScanPbGammaTable = new Fl_RaiseButton(530, 220, 20, 20);
              o->tooltip(gettext("Gamma"));
              o->box(FL_FLAT_BOX);
              o->down_box(FL_THIN_DOWN_BOX);
              o->color(49);
              o->selection_color(3);
              o->image(image_gamma);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(0);
              o->labelsize(14);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanPbGammaTable);
              o->align(FL_ALIGN_CENTER);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_Input* o = FlScanTxGammaTable = new Fl_Input(550, 220, 55, 20);
              o->type(1);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelsize(12);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanTxGammaTable);
              o->when(FL_WHEN_ENTER_KEY);
            }
            { Fl_Box* o = new Fl_Box(607, 220, 2, 20);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
            }
            { Fl_RaiseButton* o = FlScanPbResetTable = new Fl_RaiseButton(610, 220, 20, 20);
              o->tooltip(gettext("Reset Curve"));
              o->box(FL_FLAT_BOX);
              o->down_box(FL_THIN_DOWN_BOX);
              o->color(49);
              o->selection_color(49);
              o->image(image_reset);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(0);
              o->labelsize(14);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanPbResetTable);
              o->align(FL_ALIGN_CENTER);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_Group* o = FlScanGroupTableType = new Fl_Group(465, 240, 165, 80);
              o->box(FL_THIN_DOWN_BOX);
              { Fl_Curve* o = FlScanTableGammaCurve = new Fl_Curve(466, 241, 163, 78);
                o->box(FL_FLAT_BOX);
                o->color(7);
                o->selection_color(49);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(0);
                o->labelsize(14);
                o->labelcolor(56);
                o->callback((Fl_Callback*)cb_FlScanTableGammaCurve);
                o->align(FL_ALIGN_CENTER);
                o->when(FL_WHEN_CHANGED);
              }
              o->end();
            }
            o->end();
          }
          { Fl_Group* o = FlScanOutputResolutions = new Fl_Group(461, 220, 173, 129);
            o->box(FL_FLAT_BOX);
            o->labeltype(FL_NO_LABEL);
            o->hide();
            { Fl_Browser* o = FlScanLsOutputGeometries = new Fl_Browser(465, 220, 165, 105, gettext("Output Image will..."));
              o->tooltip(gettext("Select the geometries of the output image files"));
              o->type(3);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelsize(12);
              o->align(FL_ALIGN_TOP_LEFT);
              FlScanFillInGeometries(o);
            }
            { Fl_Sorted_Choice* o = FlScanOmZoomFilter = new Fl_Sorted_Choice(505, 325, 125, 20, gettext("Filter"));
              o->box(FL_ENGRAVED_BOX);
              o->down_box(FL_BORDER_BOX);
              o->color(7);
              o->selection_color(15);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(0);
              o->labelsize(12);
              o->labelcolor(56);
              o->textsize(12);
              o->align(FL_ALIGN_LEFT);
              o->when(FL_WHEN_RELEASE);
              o->menu(menu_FlScanOmZoomFilter);
              o->value(1);
              FlScanZoomFilter=Image_Stream::BOX_FILTER;
            }
            o->end();
          }
          { Fl_Group* o = FlScanHistogram = new Fl_Group(461, 220, 173, 129);
            o->tooltip(gettext("Histogram"));
            o->box(FL_FLAT_BOX);
            o->labeltype(FL_NO_LABEL);
            o->hide();
            { Fl_Button* o = FlScanHistogramPbIntensity = new Fl_Button(475, 330, 15, 15, gettext("I"));
              o->tooltip(gettext("Toggle Intensity"));
              o->box(FL_BORDER_BOX);
              o->color(0);
              o->selection_color(0);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(7);
              o->callback((Fl_Callback*)cb_FlScanHistogramPbIntensity);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            { Fl_Button* o = FlScanHistogramPbRed = new Fl_Button(510, 330, 15, 15, gettext("R"));
              o->tooltip(gettext("Toggle Red"));
              o->box(FL_BORDER_BOX);
              o->color(1);
              o->selection_color(1);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(7);
              o->callback((Fl_Callback*)cb_FlScanHistogramPbRed);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            { Fl_Button* o = FlScanHistogramPbBlue = new Fl_Button(560, 330, 15, 15, gettext("B"));
              o->tooltip(gettext("Toggle Blue"));
              o->box(FL_BORDER_BOX);
              o->color(4);
              o->selection_color(4);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(7);
              o->callback((Fl_Callback*)cb_FlScanHistogramPbBlue);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            { Fl_Button* o = FlScanHistogramPbGreen = new Fl_Button(535, 330, 15, 15, gettext("G"));
              o->tooltip(gettext("Toggle Green"));
              o->box(FL_BORDER_BOX);
              o->color(2);
              o->selection_color(2);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanHistogramPbGreen);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            { Fl_Button* o = FlScanHistogramPbLog = new Fl_Button(615, 330, 15, 15, gettext("L"));
              o->tooltip(gettext("Toggle Logarithmic Representation"));
              o->box(FL_BORDER_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanHistogramPbLog);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            { Fl_Button* o = FlScanHistogramPbPixel = new Fl_Button(590, 330, 15, 15, gettext("P"));
              o->tooltip(gettext("Toggle Point Representation"));
              o->box(FL_BORDER_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanHistogramPbPixel);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            { Fl_Group* o = FlScanHistogramCanvas = new Fl_Group(465, 220, 165, 110);
              o->box(FL_THIN_DOWN_BOX);
              o->color(7);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->end();
            }
            { Fl_Light_Button* o = FlScanHistogramTgIntensity = new Fl_Light_Button(465, 330, 10, 15);
              o->tooltip(gettext("Toggle Intensity"));
              o->box(FL_NO_BOX);
              o->color(50);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(10);
              o->callback((Fl_Callback*)cb_FlScanHistogramTgIntensity);
            }
            { Fl_Light_Button* o = FlScanHistogramTgRed = new Fl_Light_Button(500, 330, 10, 15);
              o->tooltip(gettext("Toggle Red"));
              o->box(FL_NO_BOX);
              o->color(50);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->callback((Fl_Callback*)cb_FlScanHistogramTgRed);
            }
            { Fl_Light_Button* o = FlScanHistogramTgGreen = new Fl_Light_Button(525, 330, 10, 15);
              o->tooltip(gettext("Toggle Green"));
              o->box(FL_NO_BOX);
              o->color(50);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(10);
              o->callback((Fl_Callback*)cb_FlScanHistogramTgGreen);
            }
            { Fl_Light_Button* o = FlScanHistogramTgBlue = new Fl_Light_Button(550, 330, 10, 15);
              o->tooltip(gettext("Toggle Blue"));
              o->box(FL_NO_BOX);
              o->color(50);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(10);
              o->callback((Fl_Callback*)cb_FlScanHistogramTgBlue);
            }
            { Fl_Light_Button* o = FlScanHistogramTgPixel = new Fl_Light_Button(580, 330, 10, 15);
              o->tooltip(gettext("Toggle Point Representation"));
              o->box(FL_NO_BOX);
              o->color(50);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(10);
              o->callback((Fl_Callback*)cb_FlScanHistogramTgPixel);
            }
            { Fl_Light_Button* o = FlScanHistogramTgLog = new Fl_Light_Button(605, 330, 10, 15);
              o->tooltip(gettext("Toggle Logarithmic Representation"));
              o->box(FL_NO_BOX);
              o->color(50);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelsize(10);
              o->callback((Fl_Callback*)cb_FlScanHistogramTgLog);
            }
            o->end();
          }
          { Fl_Group* o = FlScanSetupJPEG = new Fl_Group(461, 220, 173, 129);
            o->box(FL_FLAT_BOX);
            o->labeltype(FL_NO_LABEL);
            o->hide();
            { Fl_Input* o = FlScanFFmtTxQltJPEG = new Fl_Input(465, 235, 35, 15, gettext("JPEG image quality:"));
              o->tooltip(gettext("Quality in percent of the JPEG compressed file"));
              o->type(2);
              o->box(FL_THIN_DOWN_BOX);
              o->labelsize(12);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanFFmtTxQltJPEG);
              o->align(FL_ALIGN_TOP_LEFT);
              o->when(FL_WHEN_CHANGED);
            }
            { Fl_Slider* o = FlScanFFmtSlQltJPEG = new Fl_Slider(500, 235, 130, 15);
              o->tooltip(gettext("Quality in percent of the JPEG compressed file"));
              o->type(5);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->maximum(100);
              o->step(1);
              o->value(100);
              o->callback((Fl_Callback*)cb_FlScanFFmtSlQltJPEG);
              FlScanSliderGlue(FlScanFFmtSlQltJPEG,FlScanFFmtTxQltJPEG,SLIDER_TO_TEXT);
            }
            { Fl_Input* o = FlScanFFmtTxSmtJPEG = new Fl_Input(465, 270, 35, 15, gettext("JPEG smoothing factor:"));
              o->tooltip(gettext("Smoothing factor in percent of the JPEG compressed file"));
              o->type(2);
              o->box(FL_THIN_DOWN_BOX);
              o->labelsize(12);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanFFmtTxSmtJPEG);
              o->align(FL_ALIGN_TOP_LEFT);
              o->when(FL_WHEN_CHANGED);
            }
            { Fl_Slider* o = FlScanFFmtSlSmtJPEG = new Fl_Slider(500, 270, 130, 15);
              o->tooltip(gettext("Smoothing factor in percent of the JPEG compressed file"));
              o->type(5);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->maximum(100);
              o->step(1);
              o->callback((Fl_Callback*)cb_FlScanFFmtSlSmtJPEG);
              FlScanSliderGlue(FlScanFFmtSlSmtJPEG,FlScanFFmtTxSmtJPEG,SLIDER_TO_TEXT);
            }
            { Fl_Light_Button* o = FlScanFFmtTbOptJPEG = new Fl_Light_Button(465, 288, 165, 20, gettext("JPEG optimization"));
              o->tooltip(gettext("Enable/disable JPEG encoding optimization"));
              o->box(FL_NO_BOX);
              o->value(1);
              o->labelsize(12);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            { Fl_Box* o = FlScanLbJPEGSeparator = new Fl_Box(465, 310, 165, 2);
              o->box(FL_THIN_DOWN_FRAME);
              o->labeltype(FL_NO_LABEL);
            }
            { Fl_Input* o = FlScanFFmtTxCompressionPNG = new Fl_Input(465, 330, 35, 15, gettext("PNG compression:"));
              o->tooltip(gettext("Compression factor [1-9] of the PNG compressed file"));
              o->type(2);
              o->box(FL_THIN_DOWN_BOX);
              o->labelsize(12);
              o->textsize(12);
              o->callback((Fl_Callback*)cb_FlScanFFmtTxCompressionPNG);
              o->align(FL_ALIGN_TOP_LEFT);
              o->when(FL_WHEN_CHANGED);
            }
            { Fl_Slider* o = FlScanFFmtSlCompressionPNG = new Fl_Slider(500, 330, 130, 15);
              o->tooltip(gettext("Compression factor [1-9] of the PNG compressed file"));
              o->type(5);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->minimum(1);
              o->maximum(9);
              o->step(1);
              o->value(9);
              o->callback((Fl_Callback*)cb_FlScanFFmtSlCompressionPNG);
              FlScanSliderGlue(FlScanFFmtSlCompressionPNG,FlScanFFmtTxCompressionPNG,SLIDER_TO_TEXT);
            }
            o->end();
          }
          { Fl_Group* o = FlScanSaneLogo = new Fl_Group(460, 205, 175, 145);
            o->box(FL_THIN_DOWN_BOX);
            o->image(image_sane);
            o->align(FL_ALIGN_TOP|FL_ALIGN_INSIDE);
            { Fl_Box* o = new Fl_Box(465, 210, 165, 65, gettext("FlScan 1.0.2"));
              o->labeltype(FL_SHADOW_LABEL);
              o->labelfont(1);
              o->labelsize(24);
              o->labelcolor(3);
            }
            { Fl_Box* o = new Fl_Box(465, 310, 165, 20, gettext("\251""2001-2003 by"));
              o->labeltype(FL_SHADOW_LABEL);
              o->labelfont(1);
              o->labelcolor(3);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            }
            { Fl_Box* o = new Fl_Box(461, 329, 173, 20, gettext("Francesco Bradascio"));
              o->labeltype(FL_SHADOW_LABEL);
              o->labelfont(1);
              o->labelcolor(3);
              o->align(FL_ALIGN_WRAP);
            }
            { Fl_Button* o = showCopyright = new Fl_Button(461, 206, 173, 143);
              o->tooltip(gettext("Show Copyright ..."));
              o->box(FL_NO_BOX);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(1);
              o->labelcolor(7);
              o->callback((Fl_Callback*)cb_showCopyright);
              o->align(194|FL_ALIGN_INSIDE);
            }
            o->end();
          }
          o->end();
        }
        { Fl_Group* o = FlScanImageSelector = new Fl_Group(460, 5, 175, 445);
          o->box(FL_THIN_DOWN_BOX);
          o->hide();
          { FileBrowser* o = FlScanFileBrowser = new FileBrowser(460, 5, 175, 445);
            o->type(1);
            o->box(FL_THIN_DOWN_BOX);
            o->color(7);
            o->selection_color(15);
            o->labeltype(FL_NO_LABEL);
            o->labelfont(0);
            o->labelsize(14);
            o->labelcolor(56);
            o->callback((Fl_Callback*)cb_FlScanFileBrowser);
            o->align(FL_ALIGN_BOTTOM);
            o->when(FL_WHEN_RELEASE_ALWAYS);
            o->filter("*.{png|jpeg|jpg}");
            o->load(".");
          }
          o->end();
        }
        { Fl_Progress* o = FlScanProgressBar = new Fl_Progress(460, 455, 175, 20);
          o->box(FL_THIN_DOWN_BOX);
          o->color(49);
          o->selection_color(3);
        }
        o->end();
      }
      { Fl_Group* o = new Fl_Group(0, 0, 455, 480);
        o->box(FL_FLAT_BOX);
        { Fl_Tabs* o = FlScanTabs = new Fl_Tabs(5, 0, 450, 475);
          o->callback((Fl_Callback*)cb_FlScanTabs);
          { Fl_Group* o = FlScanTabThumbnails = new Fl_Group(5, 25, 450, 450);
            o->tooltip(gettext("Thumbnails"));
            o->box(FL_UP_BOX);
            o->image(image_Thumbnails);
            o->labelfont(1);
            o->labelsize(12);
            o->hide();
            o->deactivate();
            { Fl_Scroll* o = new Fl_Scroll(10, 30, 440, 424);
              o->type(6);
              o->box(FL_DOWN_BOX);
              o->color(7);
              o->labeltype(FL_NO_LABEL);
              o->align(FL_ALIGN_CENTER);
              o->hide();
              { Fl_Pack* o = FlScanThumbsRows = new Fl_Pack(12, 32, 420, 420);
                { Fl_Pack* o = new Fl_Pack(12, 32, 420, 140);
                o->type(1);
                { Fl_Group* o = new Fl_Group(12, 32, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(20, 55, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(152, 32, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(160, 56, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(292, 32, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(300, 56, 123, 90);
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelsize(12);
                o->align(FL_ALIGN_BOTTOM);
                o->end();
                }
                o->end();
                }
                o->end();
                }
                { Fl_Pack* o = new Fl_Pack(12, 172, 420, 140);
                o->type(1);
                { Fl_Group* o = new Fl_Group(12, 172, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(20, 195, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(152, 172, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(160, 195, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(292, 172, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(300, 195, 123, 90);
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelsize(12);
                o->align(FL_ALIGN_BOTTOM);
                o->end();
                }
                o->end();
                }
                o->end();
                }
                { Fl_Pack* o = new Fl_Pack(12, 312, 420, 140);
                o->type(1);
                { Fl_Group* o = new Fl_Group(12, 312, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(20, 335, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(152, 312, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(160, 335, 123, 90, gettext("1"));
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(292, 312, 140, 140, gettext("1"));
                o->box(FL_UP_BOX);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelsize(12);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                { Fl_Group* o = new Fl_Group(300, 335, 123, 90);
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                o->labelsize(12);
                o->align(FL_ALIGN_BOTTOM);
                o->end();
                }
                o->end();
                }
                o->end();
                }
                o->end();
                Fl_Group::current()->resizable(o);
              }
              o->end();
            }
            { Fl_Scroll* o = new Fl_Scroll(10, 30, 440, 424);
              o->type(6);
              o->box(FL_DOWN_BOX);
              o->color(7);
              o->labeltype(FL_NO_LABEL);
              o->align(FL_ALIGN_CENTER);
              o->hide();
              { Fl_Group* o = new Fl_Group(12, 32, 420, 420);
                o->color(7);
                { Fl_Group* o = new Fl_Group(12, 32, 210, 210);
                o->box(FL_UP_BOX);
                { Fl_Group* o = new Fl_Group(42, 88, 150, 100);
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(12, 242, 210, 210);
                o->box(FL_UP_BOX);
                { Fl_Group* o = new Fl_Group(42, 297, 150, 100);
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(222, 242, 210, 210);
                o->box(FL_UP_BOX);
                { Fl_Group* o = new Fl_Group(252, 297, 150, 100);
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->end();
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(222, 32, 210, 210);
                o->box(FL_UP_BOX);
                { Fl_Group* o = new Fl_Group(252, 88, 150, 100);
                o->box(FL_DOWN_BOX);
                o->color(0);
                o->end();
                }
                o->end();
                }
                { Fl_Button* o = new Fl_Button(17, 37, 200, 200, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(17, 247, 200, 200, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(227, 247, 200, 200, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(227, 37, 200, 200, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                o->end();
                Fl_Group::current()->resizable(o);
              }
              o->end();
            }
            { Fl_Box* o = new Fl_Box(10, 455, 440, 15, gettext("Foto 1/6"));
              o->box(FL_THIN_DOWN_BOX);
              o->labelfont(1);
              o->labelsize(12);
              o->align(FL_ALIGN_BOTTOM|FL_ALIGN_INSIDE);
            }
            { Fl_Group* o = new Fl_Group(10, 30, 440, 424);
              o->box(FL_DOWN_BOX);
              o->color(7);
              { Fl_Group* o = new Fl_Group(10, 31, 422, 421);
                { Fl_Group* o = new Fl_Group(12, 32, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(29, 67, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(31, 69, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(152, 32, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(169, 67, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(171, 69, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(292, 32, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(309, 67, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(311, 69, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(12, 172, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(29, 207, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(31, 209, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(152, 172, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(169, 207, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(171, 209, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(292, 172, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(309, 207, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(311, 209, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(12, 312, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(29, 347, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(31, 349, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(152, 312, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(169, 347, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(171, 349, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Group* o = new Fl_Group(292, 312, 140, 140);
                o->box(FL_UP_BOX);
                { Fl_Box* o = new Fl_Box(309, 347, 106, 70);
                o->box(FL_THIN_DOWN_BOX);
                o->labeltype(FL_NO_LABEL);
                }
                { Fl_Box* o = new Fl_Box(311, 349, 102, 66);
                o->box(FL_THIN_DOWN_BOX);
                o->color(0);
                o->labeltype(FL_NO_LABEL);
                }
                o->end();
                }
                { Fl_Button* o = new Fl_Button(17, 37, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(17, 177, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(17, 317, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(157, 37, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(157, 177, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(157, 317, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(297, 37, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(297, 177, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                { Fl_Button* o = new Fl_Button(297, 317, 130, 130, gettext("99"));
                o->type(102);
                o->box(FL_BORDER_FRAME);
                o->down_box(FL_BORDER_FRAME);
                o->selection_color(0);
                o->labeltype(FL_SHADOW_LABEL);
                o->labelfont(1);
                o->labelcolor(7);
                o->align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE);
                }
                o->end();
                Fl_Group::current()->resizable(o);
              }
              { Fl_Slider* o = new Fl_Slider(432, 32, 16, 420);
                o->type(4);
                o->box(FL_FLAT_BOX);
                o->color(45);
                o->minimum(1);
                o->maximum(5);
                o->step(1);
                o->slider_size(0.2);
              }
              o->end();
              Fl_Group::current()->resizable(o);
            }
            o->end();
          }
          { Fl_Group* o = FlScanTabPreview = new Fl_Group(5, 25, 450, 450);
            o->tooltip(gettext("Image Previewer"));
            o->box(FL_THIN_UP_BOX);
            o->image(image_Preview);
            o->labelfont(1);
            o->labelsize(12);
            { Fl_Group* o = new Fl_Group(10, 30, 440, 440);
              o->box(FL_DOWN_BOX);
              o->color(7);
              o->labeltype(FL_NO_LABEL);
              { Fl_Image_Preview* o = FlScanPreviewArea = new Fl_Image_Preview(12, 32, 436, 436);
                o->box(FL_FLAT_BOX);
                o->color(7);
                o->selection_color(49);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(0);
                o->labelsize(14);
                o->labelcolor(56);
                o->callback((Fl_Callback*)cb_FlScanPreviewArea);
                o->align(FL_ALIGN_CENTER);
                o->when(FL_WHEN_CHANGED);
              }
              o->end();
              Fl_Group::current()->resizable(o);
            }
            o->end();
          }
          { Fl_Group* o = FlScanTabConversion = new Fl_Group(5, 25, 450, 450);
            o->tooltip(gettext("Conversions Status"));
            o->box(FL_THIN_UP_BOX);
            o->image(image_file);
            o->labelfont(1);
            o->labelsize(12);
            o->hide();
            { Conversions_List* o = FlScanConversionArea = new Conversions_List(10, 30, 440, 440, gettext("Conversions In Progress"));
              o->box(FL_DOWN_BOX);
              o->color(7);
              o->selection_color(49);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(0);
              o->labelsize(14);
              o->labelcolor(56);
              o->align(FL_ALIGN_TOP|FL_ALIGN_INSIDE);
              o->when(FL_WHEN_CHANGED);
              Fl_Group::current()->resizable(o);
            }
            o->end();
            Fl_Group::current()->resizable(o);
          }
          { Fl_Group* o = FlScanTabView = new Fl_Group(5, 25, 450, 450);
            o->tooltip(gettext("Image Viewer"));
            o->box(FL_THIN_UP_BOX);
            o->image(image_Acquire);
            o->labelfont(1);
            o->labelsize(12);
            o->hide();
            { Fl_Scrolled_Image* o = FlScanSwViewArea = new Fl_Scrolled_Image(10, 30, 440, 440);
              o->box(FL_DOWN_BOX);
              o->color(7);
              o->selection_color(49);
              o->labeltype(FL_NO_LABEL);
              o->labelfont(0);
              o->labelsize(14);
              o->labelcolor(56);
              o->align(FL_ALIGN_TOP);
              o->when(FL_WHEN_RELEASE);
              { Fl_Image_View* o = FlScanViewArea = new Fl_Image_View(12, 32, 436, 436);
                o->box(FL_FLAT_BOX);
                o->color(7);
                o->selection_color(49);
                o->labeltype(FL_NO_LABEL);
                o->labelfont(0);
                o->labelsize(14);
                o->labelcolor(56);
                o->align(FL_ALIGN_CENTER);
                o->when(FL_WHEN_CHANGED);
              }
              o->end();
              Fl_Group::current()->resizable(o);
            }
            o->end();
          }
          o->end();
          Fl_Group::current()->resizable(o);
        }
        { Fl_Group* o = FlScanToolBar = new Fl_Group(130, 0, 325, 25);
          o->box(FL_FLAT_BOX);
          { Fl_Box* o = new Fl_Box(130, 0, 2, 25);
            o->box(FL_THIN_DOWN_BOX);
            o->labeltype(FL_NO_LABEL);
          }
          { Fl_Group* o = FlScanPreviewTools = new Fl_Group(133, 0, 160, 25);
            { Fl_RaiseButton* o = FlScanThumbnailsRotateCCW = new Fl_RaiseButton(133, 0, 25, 25);
              o->tooltip(gettext("Rotate Clockwise"));
              o->box(FL_FLAT_BOX);
              o->color(49);
              o->selection_color(49);
              o->image(image_rotate_cw90);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanThumbnailsRotateCCW);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_RaiseButton* o = FlScanThumbnailsRotateCW = new Fl_RaiseButton(158, 0, 25, 25);
              o->tooltip(gettext("Rotate Counter Clockwise"));
              o->box(FL_FLAT_BOX);
              o->color(49);
              o->selection_color(49);
              o->image(image_rotate_ccw90);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanThumbnailsRotateCW);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_RaiseButton* o = FlScanThumbnailsSetHorizont = new Fl_RaiseButton(183, 0, 25, 25);
              o->tooltip(gettext("Set the horizont\nClick, drag the rubber line and release.\nThe image will be\
 rotaded by the closest\nangle of the rubber line near 0\260 or 90\260."));
              o->type(1);
              o->box(FL_FLAT_BOX);
              o->down_box(FL_THIN_DOWN_BOX);
              o->color(49);
              o->selection_color(3);
              o->image(image_set_horizont);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanThumbnailsSetHorizont);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
              o->when(FL_WHEN_CHANGED);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_RaiseButton* o = FlScanThumbnailsUndoRotate = new Fl_RaiseButton(208, 0, 25, 25);
              o->tooltip(gettext("Undo/Redo last rotation"));
              o->box(FL_FLAT_BOX);
              o->color(49);
              o->selection_color(49);
              o->image(image_undo_rotate);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanThumbnailsUndoRotate);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_Box* o = new Fl_Box(235, 0, 2, 25);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
            }
            { Fl_RaiseButton* o = FlScanThumbnailsHorizontalMirror = new Fl_RaiseButton(238, 0, 25, 25);
              o->tooltip(gettext("Flip Horizontal"));
              o->box(FL_FLAT_BOX);
              o->color(49);
              o->selection_color(49);
              o->image(image_horizontal_mirror);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanThumbnailsHorizontalMirror);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_RaiseButton* o = FlScanThumbnailsVerticalMirror = new Fl_RaiseButton(263, 0, 25, 25);
              o->tooltip(gettext("Flip Vertical"));
              o->box(FL_FLAT_BOX);
              o->color(49);
              o->selection_color(49);
              o->image(image_vertical_mirror);
              o->labeltype(FL_NORMAL_LABEL);
              o->labelfont(1);
              o->labelsize(12);
              o->labelcolor(56);
              o->callback((Fl_Callback*)cb_FlScanThumbnailsVerticalMirror);
              o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
              o->when(FL_WHEN_RELEASE);
              o->hilighted_box(FL_THIN_UP_BOX);
            }
            { Fl_Box* o = new Fl_Box(290, 0, 2, 25);
              o->box(FL_THIN_DOWN_BOX);
              o->labeltype(FL_NO_LABEL);
            }
            o->end();
          }
          { Fl_Box* o = new Fl_Box(295, 0, 10, 25);
            o->labeltype(FL_NO_LABEL);
            Fl_Group::current()->resizable(o);
          }
          { Fl_RaiseButton* o = FlScanPreviewZoomPlus = new Fl_RaiseButton(330, 0, 25, 25);
            o->tooltip(gettext("Increase Window Size"));
            o->box(FL_FLAT_BOX);
            o->color(49);
            o->selection_color(49);
            o->image(image_zoom_in);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(1);
            o->labelsize(12);
            o->labelcolor(56);
            o->callback((Fl_Callback*)cb_FlScanPreviewZoomPlus);
            o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            o->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          }
          { Fl_RaiseButton* o = FlScanPreviewZoomMinus = new Fl_RaiseButton(355, 0, 25, 25);
            o->tooltip(gettext("Decrease Window Size"));
            o->box(FL_FLAT_BOX);
            o->color(49);
            o->selection_color(49);
            o->image(image_zoom_out);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(1);
            o->labelsize(12);
            o->labelcolor(56);
            o->callback((Fl_Callback*)cb_FlScanPreviewZoomMinus);
            o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            o->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          }
          { Fl_RaiseButton* o = FlScanPreviewZoomScreen = new Fl_RaiseButton(380, 0, 25, 25);
            o->tooltip(gettext("Fit Window Size to Screen Size"));
            o->box(FL_FLAT_BOX);
            o->color(49);
            o->selection_color(49);
            o->image(image_zoom_undo);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(1);
            o->labelsize(12);
            o->labelcolor(56);
            o->callback((Fl_Callback*)cb_FlScanPreviewZoomScreen);
            o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            o->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          }
          { Fl_RaiseButton* o = FlScanPreviewZoomMinimize = new Fl_RaiseButton(405, 0, 25, 25);
            o->tooltip(gettext("Resize Window to Minimum Size"));
            o->box(FL_FLAT_BOX);
            o->color(49);
            o->selection_color(49);
            o->image(image_zoom_mini);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(1);
            o->labelsize(12);
            o->labelcolor(56);
            o->callback((Fl_Callback*)cb_FlScanPreviewZoomMinimize);
            o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            o->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          }
          { Fl_RaiseButton* o = FlScanPbExit = new Fl_RaiseButton(430, 0, 25, 25);
            o->tooltip(gettext("Terminate Fl Scan"));
            o->box(FL_FLAT_BOX);
            o->color(49);
            o->selection_color(49);
            o->image(image_zoom_quit);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(1);
            o->labelsize(12);
            o->labelcolor(56);
            o->callback((Fl_Callback*)cb_FlScanPbExit);
            o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
            o->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          }
          { Fl_RaiseButton* o = FlScanShowCopyright = new Fl_RaiseButton(305, 0, 25, 25, gettext("\251"));
            o->tooltip(gettext("Show Copyright..."));
            o->box(FL_FLAT_BOX);
            o->color(49);
            o->selection_color(49);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(1);
            o->labelsize(24);
            o->labelcolor(56);
            o->callback((Fl_Callback*)cb_FlScanShowCopyright);
            o->align(192|FL_ALIGN_INSIDE);
            o->when(FL_WHEN_RELEASE);
            o->hilighted_box(FL_THIN_UP_BOX);
          }
          o->end();
        }
        { EatEvent* o = FlScanEeLockView = new EatEvent(5, 0, 125, 25);
          o->box(FL_NO_BOX);
          o->color(49);
          o->selection_color(49);
          o->labeltype(FL_NO_LABEL);
          o->labelfont(0);
          o->labelsize(14);
          o->labelcolor(56);
          o->align(FL_ALIGN_CENTER);
          o->when(FL_WHEN_RELEASE);
          o->hide();
        }
        o->end();
        Fl_Group::current()->resizable(o);
      }
      { EatEvent* o = FlScanEeWaitForSaving = new EatEvent(0, 0, 640, 480, gettext("Wait for Saving Completion"));
        o->box(FL_NO_BOX);
        o->color(49);
        o->selection_color(49);
        o->labeltype(FL_SHADOW_LABEL);
        o->labelfont(1);
        o->labelsize(30);
        o->labelcolor(3);
        o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
        o->when(FL_WHEN_RELEASE);
        o->hide();
      }
      o->end();
    }
    o->size_range(640,480,640,480);
    copyrightWindow=make_copyright_window(copyrightText);
    o->set_modal();
    o->end();
  }
  if (!enable_scan) {
    FlScanTabThumbnails->deactivate();
    FlScanTabPreview->deactivate();
    FlScanTabConversion->deactivate();
    FlScanTabs->push(0);
    FlScanTabs->value(FlScanTabView);
    FlScanTabs->do_callback();
    FlScanSwViewArea->activate();
    FlScanEeLockView->set_visible();
}
lastOption=FlScanSaneLogo;
update_tree();
  return w;
}

void FlScanSetMode(int mode) {
  if (mode==FL_SCAN_SCAN_MODE) {
    FlScanImageSelector->hide();
    FlScanScannerOptions->show();
    FlScanSettings->show();
    FlScanSetOption->show();
    FlScanPreviewTools->show();
} else {
    FlScanScannerOptions->hide();
    FlScanSettings->hide();
    FlScanSetOption->hide();
    FlScanPreviewTools->hide();
    FlScanImageSelector->show();
}
}

void FlScanSliderGlue(Fl_Valuator *slider, Fl_Input *text,bool textToSlider) {
  double val, cval;
char *ptr, str[256];

    if (text && slider) {
        if (textToSlider) {
            ptr=(char *)text->value();
            if (ptr) {
                val = atof(ptr);
                cval = slider->clamp(val);
                slider->value(cval);
                if (cval!=val) {
                    slider->format(str);
                    text->value((const char *)str);
                }
            }
        } else {
            slider->format(str);
            text->value((const char *)str);
        }
    }
}

void FlScanResize(int how) {
  static int hh[] = { 530, 600, 768, 864, 1024 };
static int res=0;
static int maxres=-1;
int reqres;
int numres;

numres=(sizeof(hh)/sizeof(int))-1;

if (maxres<0) {
    if (Fl::h()<=hh[0]) {
        maxres=0;
    } else if (Fl::h()>=hh[numres]) {
        maxres=numres;
    } else {
        for (int i=0; i<numres; i++) {
            if (Fl::h()==hh[i]) {
                maxres=i;
                break;
            } else if (
                Fl::h()>hh[i] &&
                Fl::h()<hh[i+1]
            ) {
                maxres=i;
                break;
            }
        }
    }
}
if (how==DECREASE_SIZE && res>0) {
    reqres=res-1;
} else if (how==INCREASE_SIZE && res<maxres) {
    reqres=res+1;
} else if (how==FIT_TO_SCREEN) {
    reqres=maxres;
} else {
    reqres=how;
}
if (reqres>=0) {
    reqres=(reqres<0)?0:(reqres>maxres)?maxres:reqres;
    if (reqres!=res) {
        res=reqres;
        FlScan->resize (
            FlScan->x(), FlScan->y(),
            hh[res]+110, hh[res]-50
        );
        FlScanContainer->resize(0,0,hh[res]+110,hh[res]-50);
        FlScanToolBar->resize(130,0,hh[res]-205,25);
        FlScanEeLockView->resize(5,0,125,26);
        FlScanEeWaitForSaving->resize(0,0,hh[res]+110,hh[res]-50);
    }
}
}

void cb_selectoption(Fl_Widget *w, void *v) {
  SANE_Int opt_num;
Fl_Tree_Browser* tree = (Fl_Tree_Browser*)w;
C_Sane_Option *opt;

    if (tree->selected()) {
        opt_num = (SANE_Int)((Fl_Tree_Item*)(tree->selected()))->data();

        tree->redraw();
        Fl::flush();

        if (opt_num>0) {
            opt = sane->option(opt_num);
            if (opt && opt->descriptor()) {
                if (opt_num != currentOption_num) {
                    currentOption_num = opt_num;
                    currentOption=opt;
                    FlScanSelOption();
                }
            } else {
                tree->deselect();
                tree->redraw();
                FlScanScannerOptions->damage(FL_DAMAGE_ALL);
                FlScanScannerOptions->redraw();
                Fl::flush();
            }
        } else if (opt_num<=0) { /* Other stuff */
            currentOption=(C_Sane_Option*)0;
            currentOption_num = opt_num;
            FlScanSelOption();
        }
    } else {
        currentOption=(C_Sane_Option*)0;
        currentOption_num = 0;
        FlScanSelOption();
    }
}

void update_tree() {
  int i;
int x,y;
int firstItem = 1;
int rows = 0;
Fl_Tree_Item *application = 0;
Fl_Tree_Item *scanner = 0;
Fl_Tree_Item *first = 0;
Fl_Tree_Item *group = 0;
Fl_Tree_Item *item = 0;

    preview_ndx=-1;
    tl_x_ndx=-1;
    tl_y_ndx=-1;
    br_x_ndx=-1;
    br_y_ndx=-1;

    FlScanScannerOptions->clear();
    FlScanScannerOptions->has_scrollbar(Fl_Browser_::BOTH);
    FlScanScannerOptions->draw_lines(false);
    FlScanScannerOptions->pixmap_offset(16);
    FlScanScannerOptions->label_offset(0);
    /*
     * fill tree
     */
    rows++;
    application = first = new Fl_Tree_Item (
        /* label     : */ "Application Settings",
        /* pixmap    : */ 0,
        /* tooltip   : */ 0,
        /* data      : */ 0,
        /* color     : */ FlScanScannerOptions->textcolor(),
        /* font      : */ FlScanScannerOptions->textfont()+1,
        /* font_size : */ FlScanScannerOptions->textsize(),
        /* can_open  : */ true,
        /* opened    : */ true,
        /* parent    : */ FlScanScannerOptions,
        /* father    : */ 0,
        /* prev      : */ 0,
        /* next      : */ 0
    );
        rows++;
        group = new Fl_Tree_Item (
            /* label     : */ "Output file resolutions",
            /* pixmap    : */ 0,
            /* tooltip   : */ 0,
            /* data      : */ (void*)FL_SCAN_OUTPUT_FILE_RESOLUTION,
            /* color     : */ FlScanScannerOptions->textcolor(),
            /* font      : */ FlScanScannerOptions->textfont(),
            /* font_size : */ FlScanScannerOptions->textsize(),
            /* can_open  : */ false,
            /* opened    : */ true,
            /* parent    : */ FlScanScannerOptions,
            /* father    : */ application,
            /* prev      : */ 0,
            /* next      : */ 0
        );
        rows++;
        group = new Fl_Tree_Item (
            /* label     : */ "Image Convertes Settings",
            /* pixmap    : */ 0,
            /* tooltip   : */ 0,
            /* data      : */ (void*)FL_SCAN_CONVERTERS_SETTINGS,
            /* color     : */ FlScanScannerOptions->textcolor(),
            /* font      : */ FlScanScannerOptions->textfont(),
            /* font_size : */ FlScanScannerOptions->textsize(),
            /* can_open  : */ false,
            /* opened    : */ true,
            /* parent    : */ FlScanScannerOptions,
            /* father    : */ application,
            /* prev      : */ group,
            /* next      : */ 0
        );
    rows++;
    scanner = new Fl_Tree_Item (
        /* label     : */ "Scanner Settings",
        /* pixmap    : */ 0,
        /* tooltip   : */ 0,
        /* data      : */ 0,
        /* color     : */ FlScanScannerOptions->textcolor(),
        /* font      : */ FlScanScannerOptions->textfont()+1,
        /* font_size : */ FlScanScannerOptions->textsize(),
        /* can_open  : */ true,
        /* opened    : */ true,
        /* parent    : */ FlScanScannerOptions,
        /* father    : */ 0,
        /* prev      : */ application,
        /* next      : */ 0
    );
    group = 0;
#if 0
        rows++;
        group = new Fl_Tree_Item (
            /* label     : */ "Device Selection",
            /* pixmap    : */ 0,
            /* tooltip   : */ 0,
            /* data      : */ 0,
            /* color     : */ FlScanScannerOptions->textcolor(),
            /* font      : */ FlScanScannerOptions->textfont(),
            /* font_size : */ FlScanScannerOptions->textsize(),
            /* can_open  : */ false,
            /* opened    : */ true,
            /* parent    : */ FlScanScannerOptions,
            /* father    : */ scanner,
            /* prev      : */ 0,
            /* next      : */ 0
        );
            rows++;
            item = new Fl_Tree_Item (
                /* label     : */ "Device",
                /* pixmap    : */ 0,
                /* tooltip   : */ 0,
                /* data      : */ (void*)FL_SCAN_DEVICE_SELECTION,
                /* color     : */ FlScanScannerOptions->textcolor(),
                /* font      : */ FlScanScannerOptions->textfont(),
                /* font_size : */ FlScanScannerOptions->textsize(),
                /* can_open  : */ false,
                /* opened    : */ true,
                /* parent    : */ FlScanScannerOptions,
                /* father    : */ group,
                /* prev      : */ 0,
                /* next      : */ 0
            );
#endif
    C_Sane_Option *opt;
    for (i=1;i<sane->num_options() && (opt=sane->option(i));i++) {
        const SANE_Option_Descriptor *sod = opt->descriptor();
        if (sod && sod->title && strlen(sod->title)) {
            if (sod->type==SANE_TYPE_GROUP) {
                if (!firstItem && !item && group) {
                    /*
                     * The previous group is empty, remove it
                     */
                    Fl_Tree_Item *prev = group->prev();
                    if (prev) {
                        prev->next(0);
                    }
                    Fl_Tree_Item *father = group->father();
                    if (father && father->childs() == group) {
                        father->childs(0);
                    }
                    group = prev;
                    rows--;
                }
                group = new Fl_Tree_Item (
                    /* label     : */ (char*)sod->title,
                    /* pixmap    : */ 0,
                    /* tooltip   : */ (char*)sod->desc,
                    /* data      : */ 0,
                    /* color     : */ FlScanScannerOptions->textcolor(),
                    /* font      : */ FlScanScannerOptions->textfont(),
                    /* font_size : */ FlScanScannerOptions->textsize(),
                    /* can_open  : */ false,
                    /* opened    : */ true,
                    /* parent    : */ FlScanScannerOptions,
                    /* father    : */ scanner,
                    /* prev      : */ group,
                    /* next      : */ 0
                );
                rows++;
                item = 0;
#if 0
            } else if (SANE_OPTION_IS_ACTIVE(sod->cap)) {
                if (!strcmp(sod->name,SANE_NAME_PREVIEW)) {
                    preview_ndx=i;
                } else if (!strcmp(sod->name,SANE_NAME_SCAN_TL_X)) {
                    tl_x_ndx=i;
                } else if (!strcmp(sod->name,SANE_NAME_SCAN_TL_Y)) {
                    tl_y_ndx=i;
                } else if (!strcmp(sod->name,SANE_NAME_SCAN_BR_X)) {
                    br_x_ndx=i;
                } else if (!strcmp(sod->name,SANE_NAME_SCAN_BR_Y)) {
                    br_y_ndx=i;
                } else {
                    item = new Fl_Tree_Item (
                        /* label     : */ (char*)sod->title,
                        /* pixmap    : */ 0,
                        /* tooltip   : */ (char*)sod->desc,
                        /* data      : */ (void*)opt->number(),
                        /* color     : */ FlScanScannerOptions->textcolor(),
                        /* font      : */ FlScanScannerOptions->textfont(),
                        /* font_size : */ FlScanScannerOptions->textsize(),
                        /* can_open  : */ false,
                        /* opened    : */ true,
                        /* parent    : */ FlScanScannerOptions,
                        /* father    : */ (group) ? group : scanner,
                        /* prev      : */ item,
                        /* next      : */ 0
                    );
                    firstItem = 0;
                    rows++;
                }
#else
            } else if (sod->title) {
                if (!strcmp(sod->name,SANE_NAME_PREVIEW)) {
                    preview_ndx=i;
                } else if (!strcmp(sod->name,SANE_NAME_SCAN_TL_X)) {
                    tl_x_ndx=i;
                } else if (!strcmp(sod->name,SANE_NAME_SCAN_TL_Y)) {
                    tl_y_ndx=i;
                } else if (!strcmp(sod->name,SANE_NAME_SCAN_BR_X)) {
                    br_x_ndx=i;
                } else if (!strcmp(sod->name,SANE_NAME_SCAN_BR_Y)) {
                    br_y_ndx=i;
                }
                item = new Fl_Tree_Item (
                    /* label     : */ (char*)sod->title,
                    /* pixmap    : */ 0,
                    /* tooltip   : */ (char*)sod->desc,
                    /* data      : */ (void*)opt->number(),
                    /* color     : */ FlScanScannerOptions->textcolor(),
                    /* font      : */ FlScanScannerOptions->textfont(),
                    /* font_size : */ FlScanScannerOptions->textsize(),
                    /* can_open  : */ false,
                    /* opened    : */ true,
                    /* parent    : */ FlScanScannerOptions,
                    /* father    : */ (group) ? group : scanner,
                    /* prev      : */ item,
                    /* next      : */ 0
                );
                firstItem = 0;
                rows++;
#endif
            }
        }
    }
    FlScanScannerOptions->items(first);
    /*
     * Show the tree
     */
    FlScanScannerOptions->damage(FL_DAMAGE_ALL);
    FlScanScannerOptions->redraw();
    Fl::flush();
}

void FlScanSaneSetCB(bool automatic) {
  void *optval;
bool to_be_freed=false;
bool ok_to_set=false;
double dval;
SANE_Int val;
const SANE_Option_Descriptor *sod;

    optval=0;
    if (currentOption) {
        /*
         * Get the value from the interface
         */
        sod = currentOption->descriptor();
        switch (sod->type) {
            case SANE_TYPE_BOOL:
                if (
                    sod->size==sizeof(SANE_Word) &&
                    sod->constraint_type==SANE_CONSTRAINT_NONE
                ) {
                    ok_to_set=true;
                    val=FlScanTbBoolType->value();
                    optval=(void*)&val;
                }
                break;
            case SANE_TYPE_INT:
                if (sod->size==sizeof(SANE_Word)) {
                    switch (sod->constraint_type) {
                        case SANE_CONSTRAINT_NONE:
                            sscanf (
                                FlScanTxIntType->value(),
                                "%d",
                                &val
                            );
                            ok_to_set=true;
                            optval=(void*)&val;
                            break;
                        case SANE_CONSTRAINT_RANGE:
                            ok_to_set=true;
                            val=(int)FlScanViRangeType->value();
                            optval=(void*)&val;
                            break;
                        case SANE_CONSTRAINT_WORD_LIST:
                            sscanf (
                                FlScanMnListType->text (
                                    FlScanMnListType->value()
                                ),
                                "%d",
                                &val
                            );
                            ok_to_set=true;
                            optval=(void*)&val;
                            break;
                         default:
                            break;
                    }
                } else { /* table or array */
                    int size=sod->size/sizeof(SANE_Word);
                    double *vector=new double[size];
                    SANE_Int *ivect=new SANE_Int[size];
                    if (vector && ivect) {
                        FlScanTableGammaCurve->get_vector(size,vector);
                        for (int i=0;i<size;i++) {
                            ivect[i]=(int)vector[i];
                        }
                        to_be_freed=true;
                        ok_to_set=true;
                        optval=(void*)ivect;
                    }
                    if (vector) {
                        delete vector;
                    }
                }
                break;
            case SANE_TYPE_FIXED:
                if (sod->size==sizeof(SANE_Word)) {
                    switch (sod->constraint_type) {
                        case SANE_CONSTRAINT_NONE:
                            sscanf (
                                FlScanTxFixedType->value(),
                                "%lf",
                                &dval
                            );
                            val=(SANE_Int)SANE_FIX(dval);
                            ok_to_set=true;
                            optval=(void*)&val;
                            break;
                        case SANE_CONSTRAINT_RANGE:
                            val=(int)SANE_FIX(FlScanViRangeType->value());
                            ok_to_set=true;
                            optval=(void*)&val;
                            break;
                         default:
                            break;
                    }
                } else { /* table or array */
                    int size=sod->size/sizeof(SANE_Word);
                    double *vector=new double[size];
                    SANE_Int *ivect=new SANE_Int[size];
                    if (vector && ivect) {
                        FlScanTableGammaCurve->get_vector(size,vector);
                        for (int i=0;i<size;i++) {
                            ivect[i]=(int)SANE_FIX(vector[i]);
                        }
                        to_be_freed=true;
                        ok_to_set=true;
                        optval=(void*)ivect;
                    }
                    if (vector) {
                        delete vector;
                    }
                }
                break;
            case SANE_TYPE_STRING:
                switch (sod->constraint_type) {
                    case SANE_CONSTRAINT_NONE:
                        ok_to_set=true;
                        optval=(void*)FlScanTxStringType->value();
                        break;
                    case SANE_CONSTRAINT_STRING_LIST:
                        FlScanMnListType->value();
                        ok_to_set=true;
                        optval=(void*)FlScanMnListType->text (
                            FlScanMnListType->value()
                        );
                        break;
                    default:
                        break;
                }
                break;
            case SANE_TYPE_BUTTON:
                ok_to_set=true;
                optval=(void*)0;
                break;
            default:
                break;
        }
        /*
         * Set the SANE value
         */
        if (automatic) {
            currentOption->auto_value(optval);
        } else {
            currentOption->value(optval);
        }
        if (currentOption->status()==SANE_STATUS_GOOD) {
            if (currentOption->status()==SANE_INFO_RELOAD_OPTIONS) {
                update_tree();
            }
#if 0
            if (currentOption->status()==SANE_INFO_RELOAD_PARAMS) {
                get_params(sane);
            }
#endif
            if (currentOption->status()==SANE_INFO_INEXACT) {
//                fprintf(stderr,"\nInexact Value for %s\n",optname);
            }
            C_Sane_Option *opt = sane->option(currentOption_num);
            if (opt && opt->descriptor()) {
                currentOption=opt;
                FlScanSelOption();
            }
        } else {
/*
            fprintf (
                stderr,
                "\n%s [%s]\n",
                (SANE_String_Const)currentOption->status(),
                optname
            );
*/
        }
        if (to_be_freed) {
            delete (int *)optval;
        }
    }
}

void FlScanSelOption() {
  int i,d;
char *curdevice=0,*message=0;
Fl_Group *group=0;
C_Sane_Value val;
static char buff[256];
#define INVALID_FORMAT "Invalid Format"
#define NOT_YET_IMPLEMENTED "Tables and Arrays\nare not yet implemented"

    if (currentOption) {
        const SANE_Option_Descriptor *sod = currentOption->descriptor();
        FlScanPbAutoOption->hide();
        if (sod->cap & SANE_CAP_AUTOMATIC) {
            FlScanPbAutoOption->show();
        }
        val=currentOption->value();
        switch (sod->type) {
            case SANE_TYPE_BOOL:
                if (sod->size==sizeof(SANE_Word)) {
                    switch (sod->constraint_type) {
                        case SANE_CONSTRAINT_NONE:
                            group=FlScanBoolGroup;
                            FlScanTbBoolType->value((bool)val);
                            FlScanTbBoolType->label(currentOption->string_value());
                            break;
                        case SANE_CONSTRAINT_RANGE:
                        case SANE_CONSTRAINT_WORD_LIST:
                        case SANE_CONSTRAINT_STRING_LIST:
                        default:
                            message=INVALID_FORMAT;
                            break;
                    }
                } else { /* table or array */
                    message=INVALID_FORMAT;
                }
                break;
            case SANE_TYPE_INT:
                if (sod->size==sizeof(SANE_Word)) {
                    switch (sod->constraint_type) {
                        case SANE_CONSTRAINT_NONE:
                            group=FlScanIntGroup;
                            FlScanTxIntType->value (
                                (char*)currentOption->string_value()
                            );
                            break;
                        case SANE_CONSTRAINT_RANGE:
                            group=FlScanRangeGroup;
                            FlScanViRangeType->value((double)((int)val));
                            FlScanViRangeType->minimum (
                                (double)sod->constraint.range->min
                            );
                            FlScanViRangeType->maximum (
                                (double)sod->constraint.range->max
                            );
                            FlScanViRangeType->step (
                                (double)sod->constraint.range->quant
                            );
                            FlScanSlRangeType->value((double)((int)val));
                            FlScanSlRangeType->minimum (
                                (double)sod->constraint.range->min
                            );
                            FlScanSlRangeType->maximum (
                                (double)sod->constraint.range->max
                            );
                            FlScanSlRangeType->step (
                                (double)sod->constraint.range->quant
                            );
                            break;
                        case SANE_CONSTRAINT_WORD_LIST:
                            group=FlScanListGroup;
                            FlScanMnListType->clear();
                            for (d=0,i=1;i<=sod->constraint.word_list[0];i++) {
                                sprintf(buff,"%d",sod->constraint.word_list[i]);
                                FlScanMnListType->add (
                                    FlScanMenuize(buff),
                                    0,
                                    (Fl_Callback *)FlScanChoiceCB,
                                    (void*)0
                                );
                                if ((int)val==sod->constraint.word_list[i]) {
                                    d=i-1;
                                }
                            }
                            FlScanMnListType->value(d);
                            break;
                        case SANE_CONSTRAINT_STRING_LIST:
                        default:
                            message=INVALID_FORMAT;
                            break;
                    }
                } else { /* table or array */
                    int size=sod->size/sizeof(SANE_Word);
                    double *vector=new double[size];
                    if (vector) {
                        group=FlScanTableGroup;
                        switch (sod->constraint_type) {
                            case SANE_CONSTRAINT_RANGE:
                                FlScanTableGammaCurve->bounds (
                                    (double)0,
                                    (double)sod->constraint.range->min,
                                    (double)(size-1),
                                    (double)sod->constraint.range->max
                                );
                                break;
                            case SANE_CONSTRAINT_WORD_LIST: {
                                double min, max, v;
                                    if (sod->constraint.word_list[0]>1) {
                                        max=(double)sod->constraint.word_list[1];
                                        min=max;
                                        for (
                                            i=2;
                                            i<sod->constraint.word_list[0];
                                            i++
                                        ) {
                                            v=(double)sod->constraint.word_list[i];
                                            if (v<min) {
                                                min=v;
                                            }
                                            if (v>max) {
                                                max=v;
                                            }
                                        }
                                    } else {
                                        min=max=0;
                                    }
                                    if (min==max) {
                                        message=INVALID_FORMAT;
                                        group=0;
                                    } else {
                                        FlScanTableGammaCurve->bounds (
                                            (double)0,
                                            min,
                                            (double)(size-1),
                                            max
                                        );
                                    }
                                }
                                break;
                            case SANE_CONSTRAINT_NONE:
                            case SANE_CONSTRAINT_STRING_LIST:
                            default:
                                message=INVALID_FORMAT;
                                break;
                        }
                        if (group) {
                            SANE_Int *pval=(SANE_Int*)((void*)val);
                            for (i=0;i<size;i++) {
                                vector[i]=(double)pval[i];
                            }
                            FlScanTableGammaCurve->set_vector(size,vector);                            
                        }
                        delete vector;
                    } else {
                        message=INVALID_FORMAT;
                    }
                }
                break;
            case SANE_TYPE_FIXED:
                if (sod->size==sizeof(SANE_Word)) {
                    switch (sod->constraint_type) {
                        case SANE_CONSTRAINT_NONE:
                            group=FlScanFixedGroup;
                            FlScanTxFixedType->value (
                                (char*)currentOption->string_value()
                            );
                            break;
                        case SANE_CONSTRAINT_RANGE:
                            group=FlScanRangeGroup;
                            FlScanViRangeType->value((double)val);
                            FlScanViRangeType->minimum (
                                (double)SANE_UNFIX(sod->constraint.range->min)
                            );
                            FlScanViRangeType->maximum (
                                (double)SANE_UNFIX(sod->constraint.range->max)
                            );
                            FlScanViRangeType->step (
                                (double)SANE_UNFIX(sod->constraint.range->quant)
                            );
                            FlScanSlRangeType->value((double)val);
                            FlScanSlRangeType->minimum (
                                (double)SANE_UNFIX(sod->constraint.range->min)
                            );
                            FlScanSlRangeType->maximum (
                                (double)SANE_UNFIX(sod->constraint.range->max)
                            );
                            FlScanSlRangeType->step (
                                (double)SANE_UNFIX(sod->constraint.range->quant)
                            );
                            break;
                        case SANE_CONSTRAINT_WORD_LIST:
                        case SANE_CONSTRAINT_STRING_LIST:
                        default:
                            message=INVALID_FORMAT;
                            break;
                    }
                } else { /* table or array */
                    int size=sod->size/sizeof(SANE_Word);
                    double *vector=new double[size];
                    if (vector) {
                        group=FlScanTableGroup;
                        switch (sod->constraint_type) {
                            case SANE_CONSTRAINT_RANGE:
                                FlScanTableGammaCurve->bounds (
                                    (double)0,
                                    (double)SANE_UNFIX(sod->constraint.range->min),
                                    (double)(size-1),
                                    (double)SANE_UNFIX(sod->constraint.range->max)
                                );
                                break;
                            case SANE_CONSTRAINT_WORD_LIST: {
                                double min, max, val;
                                    if (sod->constraint.word_list[0]>1) {
                                        min=max=(double)SANE_UNFIX (
                                            sod->constraint.word_list[1]
                                        );
                                        for (
                                            i=2;
                                            i<sod->constraint.word_list[0];
                                            i++
                                        ) {
                                            val=(double)SANE_UNFIX (
                                                sod->constraint.word_list[i]
                                            );
                                            if (val<min) {
                                                min=val;
                                            }
                                            if (val>max) {
                                                max=val;
                                            }
                                        }
                                    } else {
                                        min=max=0;
                                    }
                                    if (min==max) {
                                        message=INVALID_FORMAT;
                                        group=0;
                                    } else {
                                        FlScanTableGammaCurve->bounds (
                                            (double)0,
                                            min,
                                            (double)(size-1),
                                            max
                                        );
                                    }
                                }
                                break;
                            case SANE_CONSTRAINT_NONE:
                            case SANE_CONSTRAINT_STRING_LIST:
                            default:
                                message=INVALID_FORMAT;
                                break;
                        }
                        if (group) {
                            SANE_Int *pval=(SANE_Int*)((void*)val);
                            for (i=0;i<size;i++) {
                                vector[i]=(double)SANE_UNFIX(pval[i]);
                            }
                            FlScanTableGammaCurve->set_vector(size,vector);                            
                        }
                        delete vector;
                    } else {
                        message=INVALID_FORMAT;
                    }
                }
                break;
            case SANE_TYPE_STRING:
                switch (sod->constraint_type) {
                    case SANE_CONSTRAINT_NONE:
                        group=FlScanStringGroup;
                        FlScanTxStringType->value((char*)val);
                        break;
                    case SANE_CONSTRAINT_STRING_LIST:
                        group=FlScanListGroup;
                        FlScanMnListType->clear();
                        for (d=0,i=0;sod->constraint.string_list[i];i++) {
                            FlScanMnListType->add (
                                FlScanMenuize(sod->constraint.string_list[i]),
                                0,
                                (Fl_Callback *)FlScanChoiceCB,
                                (void*)0
                            );
                            if (!strcmp((char*)val,sod->constraint.string_list[i])) {
                                d=i;
                            }
                        }
                        FlScanMnListType->value(d);
                        break;
                    case SANE_CONSTRAINT_RANGE:
                    case SANE_CONSTRAINT_WORD_LIST:
                    default:
                        message=INVALID_FORMAT;
                        break;
                }
                break;
            case SANE_TYPE_BUTTON:
                group=FlScanButtonGroup;
                break;
            default:
                group=0;
                break;
        }
        FlScanPbSetOption->hide();
        if (sod->unit==SANE_UNIT_NONE) {
            strcpy(buff,sod->title);
        } else {
            sprintf (
                buff,
                "%s [%s]",
                sod->title,
                (sod->unit==SANE_UNIT_PIXEL      ) ? "pixel" :
                (sod->unit==SANE_UNIT_BIT        ) ? "bit"   :
                (sod->unit==SANE_UNIT_DPI        ) ? "dpi"   :
                (sod->unit==SANE_UNIT_PERCENT    ) ? "%"     :
                (sod->unit==SANE_UNIT_MM         ) ? "mm"    :
                (sod->unit==SANE_UNIT_MICROSECOND) ? "\256s" : "none"
            );
        }
        if (group) {
            FlScanShowOption(group,buff,sod->desc);
        } else {
            FlScanMessage->label(message);
            FlScanShowOption(FlScanMessage,buff,(char*)0);
        }
    } else { /* Device Selection */
        switch (currentOption_num) {
            case FL_SCAN_DEVICE_SELECTION:
                FlScanMnListType->clear();
                d=0;
                if (sane->device() && sane->device()->name) {
                    curdevice=strdup(sane->device()->name);
                }
                for (i=0;i<sane->num_devices() && sane->device(i);i++) {
                    FlScanMnListType->add (
                        FlScanMenuize(sane->device(i)->name),
                        0,
                        (Fl_Callback *)FlScanChoiceCB,
                        (void*)sane->device(i)
                    );
                    if (
                        curdevice && 
                        sane->device(i)->name &&
                        !strcmp(sane->device(i)->name,curdevice)
                    ) {
                        d=i;
                    }
                }
                FlScanMnListType->value(d);
                FlScanShowOption(FlScanListGroup,"Device","Select a device");
                break;
            case FL_SCAN_CONVERTERS_SETTINGS:
                FlScanShowOption(FlScanSetupJPEG,"Image Converters Setting","Configure Image converters");
                break;
            case FL_SCAN_HISTOGRAM:
                FlScanShowOption(FlScanHistogram,"Histogram","Show image histogram");
                break;
            case FL_SCAN_OUTPUT_FILE_RESOLUTION:
                FlScanShowOption(FlScanOutputResolutions,"Output file resolution will...","Select the output files resolutions\nand zoom filter type");
                break;
            default:
                FlScanShowOption(FlScanSaneLogo,NULL,"Powered by...");
                break;
        }
    }
}

void FlScanShowOption(Fl_Group *w,const char *l,const char *t) {
  /**/
    if (lastOption) {
        lastOption->hide();
    }
    if (l) {
        FlScanSetOption->label(l);
        FlScanSetOption->redraw();
    }
    if (w) {
        w->tooltip(t);
        w->show();
        w->redraw();
        lastOption=w;
    }
}

char * FlScanMenuize(const char *str) {
  static char title[256];
int i=0,j=0;

    for (i=0,j=0; str && str[i]; i++, j++) {
        if (str[i]=='/' || str[i]=='|' || str[i]=='\\') {
            title[j]='\\'; j++;
        }
        title[j]=str[i];
    }
    title[j]='\0';
    return title;
}

void FlScanChoiceCB(Fl_Widget *w,void *d) {
  /**/
    if (currentOption) {
        FlScanSaneSetCB(false);
    } else { /* Device Selection */
        if (sane->device()!=(SANE_Device*)d) {
            FlScanSaveCurrentDevice();
            sane->open(((SANE_Device*)d)->name);
            FlScanLoadCurrentDevice();
            update_tree();
            FlScanSelOption();
        }
    }
    return;
}

void FlScanTableSetGamma() {
  double val;
const char *cval;

    cval=FlScanTxGammaTable->value();
    if (cval && sscanf(cval,"%lf",&val)!=EOF) {
        FlScanTableGammaCurve->gamma(val);
    }
    FlScanTxGammaTable->value("");
}

void FlScanScannerCB(int fd,void *d) {
  /**/
    if (d) {
        sane->scanner (
            scan_buf,
            4096*3,
            (C_Sane_ScanCB)d
        );
    }
}

bool FlScanPreviewCB(void *d,int l,int m) {
  SANE_Parameters *p;
static int started=0;
static int frame=-1;
static int scan_fd=0;
int zoomFilter;

    p=(SANE_Parameters*)d;
    switch (m) {
        case C_Sane::USER_MODE:
            if (!scan_buf) {
                scan_buf = new char[4096*3];
            }
            if (scan_buf) {
                if (preview_ndx>=0) {
                    void *optval=0;
                    SANE_Bool set=true;
                    C_Sane_Option *opt = sane->option(preview_ndx);
                    if (opt) {
                        optval=(void*)&set;
                        opt->value(optval);
                    }
                }
                FlScanPbPreview->deactivate();
                FlScanPbScan->deactivate();
                FlScanPbReset->deactivate();
                FlScanPbCancel->activate();
                FlScanUpdateProgress("Device Initialization",false);
                sane->scan (
                    scan_buf,
                    4096*3,
                    (C_Sane_ScanCB)FlScanPreviewCB
                );
            }
            // started=0;
            break;
        case C_Sane::START_FRAME:
            frame=(p->format==SANE_FRAME_GRAY)?Image_Stream::FRAME_GRAY:
                  (p->format==SANE_FRAME_RGB)?Image_Stream::FRAME_RGB:
                  (p->format==SANE_FRAME_RED)?Image_Stream::FRAME_RED:
                  (p->format==SANE_FRAME_GREEN)?Image_Stream::FRAME_GREEN:
                  (p->format==SANE_FRAME_BLUE)?Image_Stream::FRAME_BLUE:-1;
            FlScanUpdateProgress (
                 (p->format==SANE_FRAME_GRAY)?"Receiving GRAY data":
                 (p->format==SANE_FRAME_RGB)?"Receiving RGB data":
                 (p->format==SANE_FRAME_RED)?"Receiving RED data":
                 (p->format==SANE_FRAME_GREEN)?"Receiving GREEN data":
                 (p->format==SANE_FRAME_BLUE)?"Receiving BLUE data":"Receiving data",
                 false
            );
            if (!started) {
                FlScanPreviewArea->begin (
                    p->pixels_per_line,
                    p->depth,
                    (frame!=SANE_FRAME_GRAY)
                );
            } else {
                FlScanPreviewArea->rewind();
            }
            started=1;
            scan_fd=l;
            if (scan_fd) {
                Fl::add_fd(scan_fd,FL_READ|FL_EXCEPT,FlScanScannerCB,(void*)FlScanPreviewCB);
            } else {
                FlScanScannerCB(0,(void*)FlScanPreviewCB);
            }
            break;
        case C_Sane::END_OF_DATA:
            started=0;
            if (scan_fd) {
                Fl::remove_fd(scan_fd);
            }
            FlScanUpdateProgress("Updating Preview Window",false);
            zoomFilter = FlScanPreviewArea->filter();
            FlScanPreviewArea->filter(Image_Stream::UNDEFINED_FILTER);
            FlScanPreviewArea->end();
            FlScanPreviewArea->filter(zoomFilter);
            FlScanPbCancel->deactivate();
            FlScanPbPreview->activate();
            FlScanPbReset->activate();
            if (strlen(FlScanTxFileName->value())) {
                FlScanPbScan->activate();
            }
            FlScanUpdateProgress("",false);
            break;
        case C_Sane::NEW_DATA:
            if (frame>=0) {
                FlScanUpdateProgress(0,true);
                FlScanPreviewArea->add_row_data((unsigned char*)d,l,frame);
            }
            break;
        case C_Sane::DATA_ERROR:
            started=0;
            if (scan_fd) {
                Fl::remove_fd(scan_fd);
            }
            FlScanPbCancel->deactivate();
            FlScanPbPreview->activate();
            FlScanPbReset->activate();
            if (strlen(FlScanTxFileName->value())) {
                FlScanPbScan->activate();
            }
            FlScanUpdateProgress("ERROR",false);
            FlScanPreviewArea->reset();
            break;
    }
    return true;
}

void FlScanUpdateSelection() {
  double sx,sy,sw,sh;

    FlScanPreviewArea->selection(sx,sy,sw,sh);
/*
    printf (
        "\nsx=%f\nsy=%f\nsw=%f\nsh=%f",
        sx*100.0,
        sy*100.0,
        sw*100.0,
        sh*100.0
    );
*/
    fflush(stdout);
}

void FlScanUpdateProgress(const char *msg,bool working) {
  static char *message=0;
static int sense=1;
double val;

    if (msg) {
        message=(char *)msg;
    }
    FlScanProgressBar->label((message)?message:"");
    if (working) {
        val=FlScanProgressBar->value() + sense;
        if (sense>0 && val>=FlScanProgressBar->maximum()) {
           sense=-1;
           val=FlScanProgressBar->maximum();
        } else if (sense<0 && val<=FlScanProgressBar->minimum()) {
           sense=+1;
           val=FlScanProgressBar->minimum();
        }
        FlScanProgressBar->value(val);
    } else {
        FlScanProgressBar->value(FlScanProgressBar->minimum());
        sense=+1;
    }
    FlScanProgressBar->damage(FL_DAMAGE_ALL);
    FlScanProgressBar->redraw();
    Fl::flush();
}

bool FlScanScanCB(void *d,int l,int m) {
  SANE_Parameters *p;
static int started=0;
static int frame=-1;
static int scan_fd=0;
double cx,cy,cw,ch;
char *fname=NULL;
int zoomFilter;

    p=(SANE_Parameters*)d;
    switch (m) {
        case C_Sane::USER_MODE:
            if (!scan_buf) {
                scan_buf = new char[4096*3];
            }
            if (scan_buf) {
                if (preview_ndx>=0) {
                    void *optval=0;
                    SANE_Bool set=false;
                    C_Sane_Option *opt = sane->option(preview_ndx);
                    if (opt) {
                        optval=(void*)&set;
                        opt->value(optval);
                    }
                }
                FlScanPbPreview->deactivate();
                FlScanPbScan->deactivate();
                FlScanPbReset->deactivate();
                FlScanPbCancel->activate();
                FlScanUpdateProgress("Device Initialization",false);
                sane->scan (
                    scan_buf,
                    4096*3,
                    (C_Sane_ScanCB)FlScanScanCB
                );
            }
            // started=0;
            break;
        case C_Sane::START_FRAME:
            frame=(p->format==SANE_FRAME_GRAY)?Image_Stream::FRAME_GRAY:
                  (p->format==SANE_FRAME_RGB)?Image_Stream::FRAME_RGB:
                  (p->format==SANE_FRAME_RED)?Image_Stream::FRAME_RED:
                  (p->format==SANE_FRAME_GREEN)?Image_Stream::FRAME_GREEN:
                  (p->format==SANE_FRAME_BLUE)?Image_Stream::FRAME_BLUE:-1;
            FlScanUpdateProgress (
                 (p->format==SANE_FRAME_GRAY)?"Receiving GRAY data":
                 (p->format==SANE_FRAME_RGB)?"Receiving RGB data":
                 (p->format==SANE_FRAME_RED)?"Receiving RED data":
                 (p->format==SANE_FRAME_GREEN)?"Receiving GREEN data":
                 (p->format==SANE_FRAME_BLUE)?"Receiving BLUE data":"Receiving data",
                 false
            );
            if (!started) {
                FlScanOutputFile.begin (
                    p->pixels_per_line,
                    p->depth,
                    (frame!=SANE_FRAME_GRAY)
                );
                OutputImageFile *of=FlScanOutputFile.format(Output_File::JPEG);
                if (of) {
                    of->set_quality((int)FlScanFFmtSlQltJPEG->value());
                    of->set_smoothing((int)FlScanFFmtSlSmtJPEG->value());
                    of->set_optimization((int)FlScanFFmtTbOptJPEG->value());
                }
                of=FlScanOutputFile.format(Output_File::PNG);
                if (of) {
                    of->set_quality((int)FlScanFFmtSlCompressionPNG->value());
                }
            } else {
                FlScanOutputFile.rewind();
            }
            started=1;
            scan_fd=l;
            if (scan_fd) {
                Fl::add_fd(scan_fd,FL_READ|FL_EXCEPT,FlScanScannerCB,(void*)FlScanScanCB);
            } else {
                FlScanScannerCB(0,(void*)FlScanScanCB);
            }
            break;
        case C_Sane::END_OF_DATA:
            started=0;
            if (scan_fd) {
                Fl::remove_fd(scan_fd);
            }
            fname=new char[strlen(FlScanTxFileName->value())+4+9+1];
            if (fname) {
                bool one_saved=false;
                char msg[40];
                int ext_len=0;
                if (FlScanOutputFile.extension()) {
                    ext_len=strlen(FlScanOutputFile.extension());
                }
                strcpy(fname,FlScanTxFileName->value());
                char *strbuf = new char [strlen(fname)+4+9+1+ext_len];
                if (strbuf) {
                    if (
                        FlScanOutputFile.extension() &&
                        !strcasecmp (
                            &fname[strlen(fname)-ext_len],
                            FlScanOutputFile.extension()
                        )
                    ) {
                        fname[strlen(fname)-ext_len]='\0';
                    }
                    zoomFilter = FlScanOutputFile.Image_Stream::filter();
                    FlScanOutputFile.Image_Stream::filter(FlScanZoomFilter);
                    // FlScanOutputFile.matrix(FlScanPreviewArea->matrix());
                    FlScanPreviewArea->selection(cx,cy,cw,ch);
                    // FlScanOutputFile.clip(cx,cy,cw,ch);
                    FlScanUpdateCounterInFilename(&fname,1,1,4);
                    FlScanTxFileName->value(fname);
                    for (int i=1;i<=FlScanLsOutputGeometries->size();i++) {
                        if (FlScanLsOutputGeometries->selected(i)) {
                            int geom = (int)FlScanLsOutputGeometries->data(i);
                            if (geom) {
                                sprintf(msg,"Saving File - %d x %d",geom,geom);
                                sprintf(strbuf,"%s_%d",fname,geom);
                            } else {
                                sprintf(msg,"Saving File - Full Size");
                                sprintf(strbuf,"%s_FullSize",fname);
                            }
                            if (FlScanOutputFile.extension()) {
                                strcat(strbuf,FlScanOutputFile.extension());
                            }
                            FlScanUpdateProgress(msg,false);
                            FlScanOutputFile.matrix(FlScanPreviewArea->matrix());
                            FlScanOutputFile.clip(cx,cy,cw,ch);
                            FlScanOutputFile.write(strbuf,geom,FlScanSaveProgressCB);
                            FlScanOutputFile.clip(0.0,0.0,1.0,1.0);
                            one_saved=true;
                        }
                    }
                    if (!one_saved) {
                        sprintf(msg,"Saving File - Full Size");
                        FlScanUpdateProgress(msg,false);
                        sprintf(strbuf,"%s_FullSize",fname);
                        if (FlScanOutputFile.extension()) {
                            strcat(strbuf,FlScanOutputFile.extension());
                        }
                        FlScanOutputFile.matrix(FlScanPreviewArea->matrix());
                        FlScanOutputFile.clip(cx,cy,cw,ch);
                        FlScanOutputFile.write(strbuf,0,FlScanSaveProgressCB);
                        FlScanOutputFile.clip(0.0,0.0,1.0,1.0);
                    }
                    FlScanOutputFile.Image_Stream::filter(zoomFilter);
                    delete strbuf;
                }
                FlScanOutputFile.reset();
                delete fname;
            }
            // FlScanOutputFile.clip(0.0,0.0,1.0,1.0);
            FlScanPbCancel->deactivate();
            FlScanPbPreview->activate();
            FlScanPbScan->activate();
            FlScanPbReset->activate();
            FlScanUpdateProgress("",false);
            break;
        case C_Sane::NEW_DATA:
            if (frame>=0) {
                FlScanUpdateProgress(0,true);
                FlScanOutputFile.add_row_data((unsigned char*)d,l,frame);
            }
            break;
        case C_Sane::DATA_ERROR:
            started=0;
            if (scan_fd) {
                Fl::remove_fd(scan_fd);
            }
            FlScanPbCancel->deactivate();
            FlScanPbPreview->activate();
            FlScanPbScan->activate();
            FlScanPbReset->activate();
            FlScanUpdateProgress("ERROR",false);
            FlScanOutputFile.reset();
            break;
    }
    return true;
}

void dump_sane() {
  int hlp, x;
SANE_Parameters *pars;
const SANE_Option_Descriptor *sod;

    for (hlp=0;sane->num_devices() && sane->device(hlp);++hlp) {
        fprintf(stderr,"Device[%d].name   : %s\n",hlp,sane->device(hlp)->name);
        fprintf(stderr,"Device[%d].vendor : %s\n",hlp,sane->device(hlp)->vendor);
        fprintf(stderr,"Device[%d].model  : %s\n",hlp,sane->device(hlp)->model);
        fprintf(stderr,"Device[%d].type   : %s\n",hlp,sane->device(hlp)->type);
    }
    for (hlp = 0; hlp < sane->num_options() && sane->option(hlp); hlp++) {
        sod = sane->option(hlp)->descriptor();
        if (sod == NULL) {
            break;
        }
        fprintf (stderr, "Gopt(%d) : stat=%p {\n", hlp, sod);
        fprintf (stderr, "\tname : %s\n", sod->name);
        fprintf (stderr, "\ttitle: %s\n", sod->title);
        fprintf (stderr, "\tdesc : %s\n", sod->desc);

        fprintf (
            stderr,
            "\ttype : %d [%s]\n",
            sod->type,
            (sod->type==SANE_TYPE_BOOL)?"bool":
            (sod->type==SANE_TYPE_INT)?"int":
            (sod->type==SANE_TYPE_FIXED)?"fixed":
            (sod->type==SANE_TYPE_STRING)?"string":
            (sod->type==SANE_TYPE_BUTTON)?"button":
            (sod->type==SANE_TYPE_GROUP)?"group":"UNKNOWN"
        );
        fprintf (
            stderr,
            "\tunit : %d [%s]\n",
            sod->unit,
            (sod->unit==SANE_UNIT_NONE)?"unit-less (e.g., # of scans)":
            (sod->unit==SANE_UNIT_PIXEL)?"number of pixels":
            (sod->unit==SANE_UNIT_BIT)?"number of bits":
            (sod->unit==SANE_UNIT_MM)?"millimeters":
            (sod->unit==SANE_UNIT_DPI)?"resolution in dots/inch":
            (sod->unit==SANE_UNIT_PERCENT)?"percentage":
            (sod->unit==SANE_UNIT_MICROSECOND)?"micro seconds":"UNKNOWN"
        );
        fprintf (stderr, "\tsize : %d\n", sod->size);
        fprintf (stderr, "\tcap  : %d [", sod->cap);
        if (sod->cap&SANE_CAP_SOFT_SELECT) {
            fprintf (stderr, " SOFT_SELECT");
        }
        if (sod->cap&SANE_CAP_HARD_SELECT) {
            fprintf (stderr, " HARD_SELECT");
        }
        if (sod->cap&SANE_CAP_SOFT_DETECT) {
            fprintf (stderr, " SOFT_DETECT");
        }
        if (sod->cap&SANE_CAP_EMULATED) {
            fprintf (stderr, " EMULATED");
        }
        if (sod->cap&SANE_CAP_AUTOMATIC) {
            fprintf (stderr, " AUTOMATIC");
        }
        if (sod->cap&SANE_CAP_INACTIVE) {
            fprintf (stderr, " INACTIVE");
        }
        if (sod->cap&SANE_CAP_ADVANCED) {
            fprintf (stderr, " ADVANCED");
        }
/*        if (sod->cap&SANE_CAP_ALWAYS_SETTABLE) {
            fprintf (stderr, " ALWAYS_SETTABLE");
        }
*/	/// Removed from SANE
	fprintf (stderr, " ]\n");
        fprintf (
            stderr,
            "\tctyp : %d [%s]\n",
            sod->constraint_type,
            (sod->constraint_type==SANE_CONSTRAINT_NONE)?"no constraints":
            (sod->constraint_type==SANE_CONSTRAINT_RANGE)?"range":
            (sod->constraint_type==SANE_CONSTRAINT_WORD_LIST)?"word list":
            (sod->constraint_type==SANE_CONSTRAINT_STRING_LIST)?"string list":
            "UNKNOWN"
        );
        switch (sod->constraint_type) {
            case SANE_CONSTRAINT_NONE:
                break;
            case SANE_CONSTRAINT_STRING_LIST:
                fprintf(stderr,"\t\tstringlist:");
                for (x=0;sod->constraint.string_list[x];x++) {
                    fprintf(stderr," %s,",sod->constraint.string_list[x]);
                }
                fprintf(stderr,"\n");
                break;
            case SANE_CONSTRAINT_WORD_LIST:
                fprintf (
                    stderr,
                    "\t\twordlist (%d) : ",
                    sod->constraint.word_list[0]
                );
                if (sod->type==SANE_TYPE_FIXED) {
                    for (x = 1; x <= sod->constraint.word_list[0]; x++) {
                        fprintf (
                            stderr,
                            " %g ",
                            SANE_UNFIX(sod->constraint.word_list[x])
                        );
                    }
                } else {
                    for (x = 1; x <= sod->constraint.word_list[0]; x++) {
                        fprintf (
                            stderr,
                            " %d ",
                            sod->constraint.word_list[x]
                        );
                    }
                }
                fprintf(stderr,"\n");
                break;
            case SANE_CONSTRAINT_RANGE:
                if (sod->type==SANE_TYPE_FIXED) {
                    fprintf (
                        stderr,
                        "\t\trange: min=%g max=%g quantization=%g \n",
                        SANE_UNFIX(sod->constraint.range->min),
                        SANE_UNFIX(sod->constraint.range->max),
                        SANE_UNFIX(sod->constraint.range->quant)
                    );
                } else {
                    fprintf (
                        stderr,
                        "\t\trange: min=%d max=%d quantization=%d \n",
                        sod->constraint.range->min,
                        sod->constraint.range->max,
                        sod->constraint.range->quant
                    );
                }
                break;
        }
        if (
            SANE_OPTION_IS_ACTIVE(sod->cap) &&
            (sod->type==SANE_TYPE_STRING ||
            sod->size==sizeof(SANE_Word))
        ) {
            C_Sane_Value val;
            fprintf(stderr,"\tvalue: ");
            val = sane->option(hlp)->value();
            switch (sod->type) {
                case SANE_TYPE_BOOL:
                    fprintf(stderr,"%s",((bool)val)?"true":"false");
                    break;
                case SANE_TYPE_INT:
                    fprintf(stderr,"%d",(int)val);
                    break;
                case SANE_TYPE_FIXED:
                    fprintf(stderr,"%g",(double)val);
                    break;
                case SANE_TYPE_STRING:
                    fprintf(stderr,"%s",(char*)val);
                    break;
                default:
                    break;
            }
            fprintf(stderr,"\n");
        }
        fprintf(stderr,"}\n");
    }
    pars = sane->parameters();
    fprintf(stderr,"Parm : stat=%s {\n",(SANE_String_Const)sane->status());
    if (pars) {
        fprintf (
            stderr,
            "\tform=%d [%s]\n",
            pars->format,
            (pars->format==SANE_FRAME_GRAY)?
                "FRAME GRAY (band covering human visual range)":
            (pars->format==SANE_FRAME_RGB)?
                "FRAME RGB (pixel-interleaved red/green/blue bands)":
            (pars->format==SANE_FRAME_RED)?
                "FRAME RED (red band only)":
            (pars->format==SANE_FRAME_GREEN)?
                "FRAME GREEN (green band only)":
            (pars->format==SANE_FRAME_BLUE)?
                "FRAME BLUE (blue band only)":"UNKNOWN"
        );
        fprintf(stderr,"\tlast frame=%s\n",(pars->last_frame)?"true":"false");
        fprintf(stderr,"\tbytes per line=%d\n",pars->bytes_per_line);
        fprintf(stderr,"\tpixels per line=%d\n",pars->pixels_per_line);
        fprintf(stderr,"\tlines=%d\n",pars->lines);
        fprintf(stderr,"\tdepth=%d\n}\n",pars->depth);
    }
    fflush(stderr);
}

void FlScanSaveProgressCB(int prog) {
  static int lastProg=0;

    if (!FlScanEeWaitForSaving->visible()) {
        Fl::wait(0);
    }
    if (prog!=lastProg) {
        if (prog>=0) {
            FlScanUpdateProgress(0,true);
        } else {
            FlScanUpdateProgress("Flushing data to file",false);
        }
        lastProg=prog;
    }
}

char* FlScanGetCurrentDeviceConfigFileName(void) {
  static const char hexdigit[] = "0123456789abcdef";
static char cfgfile[1024];
char *devicename,ch;
int i,j;

    cfgfile[0]='\0';
    if (sane->device()) {
        if ((devicename=(char*)sane->device()->name)) {
            fl_filename_expand(cfgfile,"~/.sane");
            mkdir(cfgfile,0777);
            fl_filename_expand(cfgfile,"~/.sane/flscan-sane.cfg");
            mkdir(cfgfile,0777);
            strcat(cfgfile,"/");
            i=strlen(cfgfile);
            for (j=0;(ch=devicename[j])!='\0';j++) {
                if (isalnum(ch)) {
                    cfgfile[i++]=ch;
                } else {
                    cfgfile[i++]='-';
                    if (ch!='-') {
                        cfgfile[i++]=hexdigit[(ch>>4)&0x0f];
                        cfgfile[i++]=hexdigit[(ch>>0)&0x0f];
                    }
                    cfgfile[i++]='-';
                }
            }
            cfgfile[i]='\0';
            if ((devicename=strdup(cfgfile))) {
                fl_filename_expand(cfgfile,devicename);
                free(devicename);
            } else {
                cfgfile[0]='\0';
            }
        }
    }
    return cfgfile;
}

bool FlScanValidateOptionSaving(char *optname) {
  return (
    optname &&
    strcmp(optname,SANE_NAME_PREVIEW) &&
    strcmp(optname,SANE_NAME_SCAN_TL_X)
  /* &&
    strcmp(optname,SANE_NAME_SCAN_TL_Y) &&
    strcmp(optname,SANE_NAME_SCAN_BR_X) &&
    strcmp(optname,SANE_NAME_SCAN_BR_Y)
  */
);
}

void FlScanSaveCurrentDevice(void) {
  char *cfgfile;
FILE *pfcfg;

      cfgfile = FlScanGetCurrentDeviceConfigFileName();
      if (cfgfile && cfgfile[0]!='\0' && (pfcfg=fopen(cfgfile,"wb"))) {
          sane->save(pfcfg,FlScanValidateOptionSaving);
          fclose(pfcfg);
      }
}

void FlScanLoadCurrentDevice(void) {
  char *cfgfile;
FILE *pfcfg;

      cfgfile = FlScanGetCurrentDeviceConfigFileName();
      if (cfgfile && cfgfile[0]!='\0' && (pfcfg=fopen(cfgfile,"rb"))) {
          sane->load(pfcfg,FlScanValidateOptionSaving);
          fclose(pfcfg);
      }
}

void FlScanUpdateCounterInFilename(char **filename,int skip,int step,int min_counter_len) {
  FILE *testfile;
char *position_point = NULL;
char *position_counter;
char  buf[FILENAME_MAX];
int   counter, i, j;
int   counter_len;
int   set_counter_len = min_counter_len;
bool  last_was_space=false;

    for (i=0, j=0; (*filename)[i]; i++) {
        if (isspace((*filename)[i])) {
            last_was_space=true;
        } else {
            (*filename)[j++] = (last_was_space) ? toupper((*filename)[i])
                                                : (*filename)[i];
            last_was_space=false;
        }
    }
    (*filename)[j++] = '\0';
    position_point = strrchr(*filename, '.');
    if (!position_point) { /* nothing usable ? */
        /* here is no point, but position - 1 is last character */
        position_point = *filename + strlen(*filename);
    }
    if (position_point) {
        /* go to last number of counter (if counter exists) */
        position_counter = position_point - 1;
        /* search non numeric char */
        while (
            ( position_counter >= *filename) &&
            (*position_counter >= '0'      ) &&
            (*position_counter <= '9'      )
        ) {
            position_counter--; /* search fisrt numeric character */
        }
        position_counter++;     /* go to first numeric charcter */
        counter_len = position_point - position_counter;
        if (counter_len) {      /* we have a counter */
            sscanf(position_counter,"%d",&counter);

            while (1) { /* may be we have to skip existing files */
                counter += step;    /* update counter */
                if (counter < 0) {
                    counter = 0;
//                  xsane_back_gtk_warning (WARN_COUNTER_UNDERRUN, TRUE);
                    break;      /* last available number ("..999") */
                }
                /* set end of string mark to counter start */
                *position_counter = 0;
                if (set_counter_len == 0) {
                    set_counter_len = counter_len;
                }
                snprintf (
                    buf,
                    sizeof(buf),
                    "%s%0*d%s",
                    *filename,
                    set_counter_len,
                    counter,
                    position_point
                );
                if (skip) { /* test if filename already used */
                    /* read binary (b for win32) */
                    testfile = fopen(buf,"rb");
                    if (testfile) { /* filename used: skip */
                        fclose(testfile);
                    } else {
                        free(*filename);
                        *filename = strdup(buf);
                        break;  /* filename not used, ok */
                    }
                } else {        /* do not test if filename already used */
                    free(*filename);
                    *filename = strdup(buf);
                    break;      /* filename ok */
                }
            }
        }
    }
}

void FlScanFillInGeometries(Fl_Browser *o) {
  if (o) {
    o->add("... be Full Size",(void*)0);
    o->add("... fit in  400x 400",(void*)400);
    o->add("... fit in  512x 512",(void*)512);
    o->add("... fit in  700x 700",(void*)700);
    o->add("... fit in  912x 912",(void*)912);
    o->add("... fit in 1024x1024",(void*)1024);
}
}

void FlScanSaveSettings(void) {
  #if 0 /* TODO */
char cfgfile[1024];
FILE *pfcfg;

      cfgfile = FlScanGetCurrentConfigFileName();
      fl_filename_expand(cfgfile,"~/.sane");
      mkdir(cfgfile,0777);
      fl_filename_expand(cfgfile,"~/.sane/flscan-sane.cfg");
      mkdir(cfgfile,0777);
      strcat(cfgfile,"/global_settings");
      if (cfgfile && cfgfile[0]!='\0' && (pfcfg=fopen(cfgfile,"wb"))) {
          // save settings
          fclose(pfcfg);
      }
#endif
}

void FlScanLoadSettings(void) {
  #if 0 /* TODO */
char cfgfile[1024];
FILE *pfcfg;

      cfgfile = FlScanGetCurrentConfigFileName();
      fl_filename_expand(cfgfile,"~/.sane/flscan-sane.cfg/global_settings");
      if (cfgfile && cfgfile[0]!='\0' && (pfcfg=fopen(cfgfile,"rb"))) {
          // load settings
          fclose(pfcfg);
      }
#endif
}

void FlScanUpdateDirectory(void) {
  char *pathname = new char[strlen(FlScanFileBrowser->directory())+3];
    if (pathname) {
        sprintf(pathname,"%s/.",FlScanFileBrowser->directory());
        FlScanFileBrowser->load(pathname);
    }
}

void FlScanChangeDirectory() {
  const char *item = FlScanFileBrowser->text(FlScanFileBrowser->value());
if (item) {
    char *pathname = new char[strlen(FlScanFileBrowser->directory())+1+strlen(item)+1];
    if (pathname) {
        sprintf(pathname,"%s/%s",FlScanFileBrowser->directory(),item);
        if (fl_filename_isdir(pathname))  {
            FlScanFileBrowser->load(pathname);
        } else {
            FlScanShowImage(pathname);
        }
    }
}
}

void FlScanShowImage(char *pname) {
  char *pathname;

    pathname=pname;
    if (strrchr(pname,'/') == NULL ){
        char* cur_dir = new char[1024];
        if ((getcwd(cur_dir,sizeof(cur_dir)))==NULL) return;
        char *path_name = new char[strlen(cur_dir)+1+strlen(pname)+3];
        sprintf(path_name,"%s/%s",cur_dir,pname);
        pathname=path_name;
    }  
    char *ext = strrchr(pathname, '.');
    if (ext) {
        if (strcmp(ext,".jpg") == 0 || strcmp (ext,".JPG") == 0 ||
        strcmp (ext,".jpeg") == 0 || strcmp (ext,".JPEG") == 0 ) {
            readJPEG(pathname,FlScanReadImageCB);
        } else if (strcmp(ext,".png")==0 || strcmp(ext,".PNG")==0) {
            readPNG(pathname,FlScanReadImageCB);
        }
    }
}

bool FlScanReadImageCB(unsigned char *row,int w,int d,int c,int m) {
  static int started=0;
static int frame=-1;

    switch (m) {
        case 0:
            frame=(c==0)?Image_Stream::FRAME_GRAY:Image_Stream::FRAME_RGB;
            FlScanUpdateProgress (
                 (frame==Image_Stream::FRAME_GRAY)?"Receiving GRAY data":
                 (frame==Image_Stream::FRAME_RGB)?"Receiving RGB data":
                 (frame==Image_Stream::FRAME_RED)?"Receiving RED data":
                 (frame==Image_Stream::FRAME_GREEN)?"Receiving GREEN data":
                 (frame==Image_Stream::FRAME_BLUE)?"Receiving BLUE data":"Receiving data",
                 false
            );
            if (!started) {
                FlScanViewArea->begin(w,d,(frame!=SANE_FRAME_GRAY));
            } else {
                FlScanViewArea->rewind();
            }
            started=1;
            break;
        case 2:
            started=0;
            FlScanUpdateProgress("Updating Preview Window",false);
            FlScanViewArea->end();
            FlScanSwViewArea->position(0,0);
            FlScanSwViewArea->redraw();
            FlScanUpdateProgress("",false);
            break;
        case 1:
            if (frame>=0) {
                FlScanUpdateProgress(0,true);
                FlScanViewArea->add_row_data(row,d,frame);
            }
            break;
        case -1:
            started=0;
            FlScanUpdateProgress("ERROR",false);
            FlScanViewArea->reset();
            break;
    }
    return true;
}

bool FlScanCheckForImagesNotSaved() {
  bool allSaved=true;
const char *pStrProgress;
int exit=0;

    for (
        int i=0;
        (pStrProgress=FlScanConversionArea->get_value(i,2));
        i++
    ) {
        if (strcmp(pStrProgress,"Completed")) {
            allSaved=false;
            break;
        }
    }
    if (!allSaved) {
        // Show conversion area
        FlScanTabs->push(0);
        FlScanTabs->value(FlScanTabConversion);
        FlScanTabs->do_callback();
        fl_message_font(FL_HELVETICA_BOLD,12);
        exit=fl_choice (
            "There are still some images in saving progress",
            "Don't Exit",
            "Wait",
            "Exit Now"
        );
        if (exit==2) {
            allSaved=true;
        } else if (exit==1) {
            FlScanEeWaitForSaving->set_visible();
            new ImageSavingMonitor();
        }
    }
    return allSaved;
}

static void cb_OK(Fl_Return_Button* o, void*) {
  ((Fl_Window*)(o->parent()))->hide();
}

Fl_Double_Window* make_copyright_window(char *copyright) {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(350, 350, gettext("FlScan Copyright"));
    w = o;
    { Fl_Return_Button* o = new Fl_Return_Button(5, 320, 340, 25, gettext("OK"));
      o->labelfont(1);
      o->callback((Fl_Callback*)cb_OK);
    }
    { Fl_Help_View* o = new Fl_Help_View(5, 5, 340, 310);
      o->box(FL_THIN_DOWN_BOX);
      o->value(copyright);
    }
    o->set_modal();
    o->end();
  }
  return w;
}

Fl_Double_Window *wDevList=(Fl_Double_Window *)0;

static void cb_OK1(Fl_Return_Button* o, void*) {
  ((Fl_Window*)(o->parent()))->hide();
}

Fl_Browser *lsDevList=(Fl_Browser *)0;

void FlScanDeviceSelection(void) {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = wDevList = new Fl_Double_Window(350, 155, gettext("Device Selection"));
    w = o;
    { Fl_Return_Button* o = new Fl_Return_Button(5, 125, 340, 25, gettext("OK"));
      o->labelfont(1);
      o->callback((Fl_Callback*)cb_OK1);
    }
    { Fl_Browser* o = lsDevList = new Fl_Browser(5, 20, 340, 100, gettext("Choose the device from the below list:"));
      o->type(2);
      o->labelfont(1);
      o->align(FL_ALIGN_TOP_LEFT);
      o->when(3);
    }
    o->set_modal();
    o->end();
  }
  const SANE_Device *dev = 0;
int numDev = sane->num_devices();
char *devName = 0;

    if (numDev>1) {
        lsDevList->clear();
        for (int i=0; i<numDev; i++) {
            dev = sane->device(i);
            if (dev && dev->name) {
                lsDevList->add(dev->name,(void*)dev);
            }
        }
        wDevList->position (
            Fl::x() + (Fl::w()/2 - wDevList->w()/2),
            Fl::y() + (Fl::h()/2 - wDevList->h()/2)
        );
        wDevList->show();
        while (wDevList->visible()) {
            Fl::wait();
        }
        dev = (SANE_Device*)lsDevList->data (
            lsDevList->value()
        );
    } else if (numDev>0) {
        dev = sane->device(0);
    }
    if (dev && dev->name) {
        devName = (char*)strdup(dev->name);
        sane->open(devName);
        free((void*)devName);
        FlScanLoadCurrentDevice();
    }
    delete wDevList;
    wDevList = 0;
}
